[{"title":"","date":"2019-11-12T07:14:42.202Z","path":"2019/11/12/arctile_31/","text":"title: ES6中常用的10个新特性讲解date: 2019-10-14 17:22:40categories:tags: - ES6 ECMAScript 6(ES6) 目前基本成为业界标准，它的普及速度比 ES5 要快很多，主要原因是现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器，已经支持 ES6 中绝大多数的特性。 下面逐一为大家详解常用的ES6新特性： 1.不一样的变量声明：const和letES6推荐使用let声明局部变量，相比之前的var（无论声明在何处，都会被视为声明在函数的最顶部）let和var声明的区别： 123456var x = &apos;全局变量&apos;;&#123; let x = &apos;局部变量&apos;; console.log(x); // 局部变量&#125;console.log(x); // 全局变量 let表示声明变量，而const表示声明常量，两者都为块级作用域；const 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了： 12const a = 1a = 0 //报错 如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行： 1234const student = &#123; name: &apos;cc&apos; &#125;student.name = &apos;yy&apos;;// 不报错student = &#123; name: &apos;yy&apos; &#125;;// 报错 有几个点需要注意： let 关键词声明的变量不具备变量提升（hoisting）特性 let 和 const 声明只在最靠近的一个块中（花括号内）有效 当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING const 在声明时必须被赋值 2.模板字符串在ES6之前，我们往往这么处理模板字符串：通过“\\”和“+”来构建模板 123$(&quot;body&quot;).html(&quot;This demonstrates the output of HTML \\content to the page, including student&apos;s\\&quot; + name + &quot;, &quot; + seatNumber + &quot;, &quot; + sex + &quot; and so on.&quot;); 而对ES6来说 基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定； ES6反引号()直接搞定； 12$(&quot;body&quot;).html(`This demonstrates the output of HTML content to the page, including student&apos;s $&#123;name&#125;, $&#123;seatNumber&#125;, $&#123;sex&#125; and so on.`); 3.箭头函数（Arrow Functions） ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体； 箭头函数最直观的三个特点。 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字 1234567891011121314// ES5var add = function (a, b) &#123; return a + b;&#125;;// 使用箭头函数var add = (a, b) =&gt; a + b;// ES5[1,2,3].map((function(x)&#123; return x + 1;&#125;).bind(this)); // 使用箭头函数[1,2,3].map(x =&gt; x + 1); 细节：当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return； 4. 函数的参数默认值在ES6之前，我们往往这样定义参数的默认值： 12345678910111213// ES6之前，当未传入参数时，text = &apos;default&apos;；function printText(text) &#123; text = text || &apos;default&apos;; console.log(text);&#125;// ES6；function printText(text = &apos;default&apos;) &#123; console.log(text);&#125;printText(&apos;hello&apos;); // helloprintText();// default 5.Spread / Rest 操作符 Spread / Rest 操作符指的是 …，具体是 Spread 还是 Rest 需要看上下文语境。 当被用于迭代器中时，它是一个 Spread 操作符： 123456function foo(x,y,z) &#123; console.log(x,y,z);&#125; let arr = [1,2,3];foo(...arr); // 1 2 3 当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符： 1234function foo(...args) &#123; console.log(args);&#125;foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5] 6.二进制和八进制字面量 ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者0O 即可将其转换为八进制值： 12345let oValue = 0o10;console.log(oValue); // 8 let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`console.log(bValue); // 2 7.对象和数组解构123456789101112131415161718// 对象const student = &#123; name: &apos;Sam&apos;, age: 22, sex: &apos;男&apos;&#125;// 数组// const student = [&apos;Sam&apos;, 22, &apos;男&apos;];// ES5；const name = student.name;const age = student.age;const sex = student.sex;console.log(name + &apos; --- &apos; + age + &apos; --- &apos; + sex);// ES6const &#123; name, age, sex &#125; = student;console.log(name + &apos; --- &apos; + age + &apos; --- &apos; + sex); 8.对象超类ES6 允许在对象中使用 super 方法： 12345678910111213141516var parent = &#123; foo() &#123; console.log(&quot;Hello from the Parent&quot;); &#125;&#125; var child = &#123; foo() &#123; super.foo(); console.log(&quot;Hello from the Child&quot;); &#125;&#125; Object.setPrototypeOf(child, parent);child.foo(); // Hello from the Parent // Hello from the Child 9.for…of 和 for…infor…of 用于遍历一个迭代器，如数组： 123456let letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];letters.size = 3;for (let letter of letters) &#123; console.log(letter);&#125;// 结果: a, b, c for…in 用来遍历对象中的属性： 12345 let stus = [&quot;Sam&quot;, &quot;22&quot;, &quot;男&quot;]; for (let stu in stus) &#123; console.log(stus[stu]); &#125;// 结果: Sam, 22, 男 10.ES6中的类ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。 函数中使用 static 关键词定义构造函数的的方法和属性： 123456789101112131415161718class Student &#123; constructor() &#123; console.log(&quot;I&apos;m a student.&quot;); &#125; study() &#123; console.log(&apos;study!&apos;); &#125; static read() &#123; console.log(&quot;Reading Now.&quot;); &#125;&#125; console.log(typeof Student); // functionlet stu = new Student(); // &quot;I&apos;m a student.&quot;stu.study(); // &quot;study!&quot;stu.read(); // &quot;Reading Now.&quot; 类中的继承和超集： 1234567891011121314class Phone &#123; constructor() &#123; console.log(&quot;I&apos;m a phone.&quot;); &#125;&#125; class MI extends Phone &#123; constructor() &#123; super(); console.log(&quot;I&apos;m a phone designed by xiaomi&quot;); &#125;&#125; let mi8 = new MI(); extends 允许一个子类继承父类，需要注意的是，子类的constructor 函数中需要执行 super() 函数。当然，你也可以在子类方法中调用父类的方法，如super.parentMethodName()。在 这里 阅读更多关于类的介绍。 有几点值得注意的是： 类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误 在类中定义函数不需要使用 function 关键词","tags":[]},{"title":"webpack4简单实用配置解析","date":"2019-09-21T07:16:40.000Z","path":"2019/09/21/arctile_29/","text":"虽然webpack已经升级到了4，但网上大量webpack配置的博文依旧是2/3，按照2/3的一些方法去配置webpack4会出现很多问题，非常不利于学习（挫败感）。大家调侃webpack配置复杂，有各种像webpack配置工程师这样的段子。认真梳理起来其实并不难懂。 本文中Webpack4项目工程化构建配置简单，注释详细，且非常实用，附有github源码，利于学习。引申到新的概念都有拓展阅读，不会让那你一脸懵逼！github webpack4配置源码希望本文能帮你点亮webpack配置技能点，欢迎评论提问题和star。 创建package.json12npm init复制代码 一路回车就ok了： 12345678package name: (test) testversion: (1.0.0)description:entry point: (index.js)test command:git repository:...复制代码 安装webpack12cnpm i --save-dev webpack复制代码 配置 webpack.config.js新建文件，webpack.config.js会最终暴露出一个配置对象。 123const config = &#123;&#125;;module.exports = config;复制代码 modewebpcak4新增了mode,用于根据环境选用对应配置，不设置会warning: The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value... 1234const config = &#123; mode: &quot;production&quot; // none/development/production 有三个值&#125;复制代码 entry &amp; output定义webpack入口和输出。entry/output 是一个对象，可以定义多个入口。配置output，使其根据入口加上hash动态生成打包后的名称： 123456789101112131415161718192021const path = require(&quot;path&quot;);// __dirname为当前绝对路径console.log(&quot;__dirname ===&gt;&quot;, __dirname);// __dirname ===&gt; D:\\github\\Personal-siteconst config = &#123; entry: &#123; index: &quot;./src/index.js&quot; // 可以添加多个入口 // app: &quot;./src/app.js&quot; &#125;, output: &#123; filename: &quot;[name].[hash].js&quot;, // 生成绝对路径 // D:\\github\\Personal-site\\dist path: path.resolve(__dirname, &quot;dist&quot;), publicPath: &quot;./&quot; &#125;&#125;复制代码 以上用了path做了路径处理，path是node.js内置的package，用来处理路径。path.resolve(__dirname, &quot;dist&quot;)会生成返回一个绝对路径，以储存生成的文件。publicPath 并不会对生成文件的路径造成影响，主要是对页面里面引入的资源的路径做对应的补全。如publicPath: &quot;/&quot;后，生成的页面引入js的路径为src=&quot;/[name].[hash].js&quot;,本地预览会报错，设置成publicPath: &quot;./&quot; ===&gt; src=&quot;./[name].[hash].js&quot;则可以解决问题。 devtool指定sourceMap模式。sourceMap模式有很多种，具体可看：webpack——devtool里的7种SourceMap模式vue-cli的webpack.dev.conf.js使用了cheap-module-eval-source-map。生产环境这里使用hidden-source-map。 12345const config = &#123; // cheap-module-eval-source-map is faster for development devtool: &quot;cheap-module-eval-source-map&quot;&#125;复制代码 devServer 在开发模式下，DevServer 提供虚拟服务器，让我们进行开发和调试。 提供实时重新加载,减少开发时间。 它不是 webpack 内置插件，要安装 12cnpm i --save-dev webpack-dev-server复制代码 12345678const config = &#123; devSever: &#123; contentBase: &apos;./dist&apos;, hot: true, host: &apos;localhost&apos; &#125;&#125;复制代码 可参考：官方文档 、 segmentfault。 这里我们将开发的devServer单独分为一个js文件，并通过node运行文件从而跑起服务器。安装依赖： 12cnpm i --save-dev opn webpack-dev-server复制代码 新建： /build/dev-server.js 12345678910111213141516171819202122232425const webpackDevServer = require(&apos;webpack-dev-server&apos;);const webpack = require(&apos;webpack&apos;);// 使用opn打开浏览器（解决devServer.open无效）const opn = require(&quot;opn&quot;);// 引入配置const config = require(&apos;../webpack.config.js&apos;);// devServer配置const options = &#123; contentBase: &apos;./dist&apos;, hot: true, host: &apos;localhost&apos;&#125;;// 将devServer加入webpack配置webpackDevServer.addDevServerEntrypoints(config, options);const compiler = webpack(config);// 新建devServerconst server = new webpackDevServer(compiler, options);// 监听、打开端口server.listen(5000, &apos;localhost&apos;, () =&gt; &#123; console.log(&apos;dev server listening on port 5000&apos;); opn(`http://127.0.0.1:5000`);&#125;);复制代码 在package.json中添加脚本命令： 123456&#123; scripts: &#123; &quot;dev&quot;: &quot;node ./build/dev-server.js&quot; &#125;&#125;复制代码 注释掉webpack.config.js中配置的devServer: 12345678const config = &#123; // devSever: &#123; // contentBase: &apos;./dist&apos;, // hot: true, // host: &apos;localhost&apos; // &#125;&#125;复制代码 执行npm run dev即可开启服务。(别急着运行，继续配置) pluginsplugins 选项用于以各种方式自定义 webpack 构建过程。webpack附带了各种内置插件，可以通过webpack.[plugin-name]或者直接引入require([plugin-name]) 访问这些插件。 自带插件 html-webpack-plugin自动生成html，插入script。更多： 官方配置、html-minifier配置、html-minifier中文文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const config = &#123; entry: &#123; index: &quot;./src/index.js&quot; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // html模板文件(在文件中写好title、meta等) template: &quot;src/index.html&quot;, // 输出的路径(包含文件名) filename: &quot;./index.html&quot;, //自动插入js脚本 // true body head false 默认为true:script标签位于html文件的 body 底部 inject: true, // chunks主要用于多入口文件，当你有多个入口文件，那就回编译后生成多个打包后的文件，那么chunks 就能选择你要使用那些js文件 chunks: [&quot;index&quot;], // 压缩html minify: &#123; // 移除注释 removeComments: true, // 不要留下任何空格 collapseWhitespace: true, // 当值匹配默认值时删除属性 removeRedundantAttributes: true, // 使用短的doctype替代doctype useShortDoctype: true, // 移除空属性 removeEmptyAttributes: true, // 从style和link标签中删除type=&quot;text/css&quot; removeStyleLinkTypeAttributes: true, // 保留单例元素的末尾斜杠。 keepClosingSlash: true, // 在脚本元素和事件属性中缩小JavaScript(使用UglifyJS) minifyJS: true, // 缩小CSS样式元素和样式属性 minifyCSS: true, // 在各种属性中缩小url minifyURLs: true &#125; &#125;) ]&#125;复制代码 mini-css-extract-plugin自带插件，为每个引入 css 的 JS 文件创建一个 css 文件，css抽离，并写入html。 12345678910const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const config = &#123; plugins: [ new MiniCssExtractPlugin(&#123; filename: &quot;[name].[hash].css&quot;, &#125;) ]&#125;;复制代码 clean-webpack-plugin删除文件夹，避免因为生成的文件带hash,而一直存在。 12cnpm i --save-dev clean-webpack-plugin复制代码 12345678const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);const config = &#123; plugins: [ new CleanWebpackPlugin([&quot;dist&quot;]) ]&#125;;复制代码 HotModuleReplacementPlugin启用热替换模式。 NamedModulesPlugin在控制台中输出可读的模块名。 HashedModuleIdsPlugin文件未变动时，保持build出来的文件hash不变。 123456789101112// 三种插件webpack自带const config = &#123; plugins: [ // 启用 HMR new webpack.HotModuleReplacementPlugin(), // 在控制台中输出可读的模块名 new webpack.NamedModulesPlugin(), // 不做改动hash保持不变 new webpack.HashedModuleIdsPlugin() ]&#125;;复制代码 performance配置如何展示性能提示。 默认不配置下开启devServer时，会提示： 1234567891011121314151617WARNING in asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).This can impact web performance.Assets: vendor.256a0afe197a0724d634.js (1.67 MiB)WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.Entrypoints: index (1.8 MiB) vendor.256a0afe197a0724d634.js index.256a0afe197a0724d634.css index.256a0afe197a0724d634.jsWARNING in webpack performance recommendations:You can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.For more info visit https://webpack.js.org/guides/code-splitting/复制代码 因为限制了文件大小为250kb，如果超过就会提示避免提示设置如下： 123456789101112const config = &#123; performance: &#123; // false | &quot;error&quot; | &quot;warning&quot; // 不显示性能提示 | 以错误形式提示 | 以警告... hints: &quot;warning&quot;, // 开发环境设置较大防止警告 // 根据入口起点的最大体积，控制webpack何时生成性能提示,整数类型,以字节为单位 maxEntrypointSize: 5000000, // 最大单个资源体积，默认250000 (bytes) maxAssetSize: 3000000 &#125;&#125;复制代码 loaderloader 用于对模块的源代码进行转换。我们可以使用loader将less/sass/scss/stylus转为css并压缩、兼容处理等，可以将js es6/7语法转为es5等等。 处理less安装： 12cnpm i --save-dev less css-loader postcss-loader less-loader autoprefixer mini-css-extract-plugin复制代码 1234567891011121314151617181920212223242526272829303132333435363738394041// css抽离const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);// 使用mini-css-extract-plugin则不能用style-loader// 前者是抽离css,后者将所有css插入html，故冲突const config = &#123; module: &#123; rules: [ &#123; test: /\\.less$/, // 只解析改目录的文件 include: path.resolve(__dirname, &quot;src&quot;), use: [ MiniCssExtractPlugin.loader, // &quot;style-loader&quot;, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; plugins: [ require(&quot;autoprefixer&quot;)(&#123; browsers: [ &quot;ie &gt;= 11&quot;, &quot;ff &gt;= 30&quot;, &quot;chrome &gt;= 34&quot;, &quot;safari &gt;= 7&quot;, &quot;opera &gt;= 23&quot;, &quot;ios &gt;= 7&quot;, &quot;android &gt;= 4.4&quot;, &quot;bb &gt;= 10&quot; ] &#125;) ] &#125; &#125;, &quot;less-loader&quot; ] &#125; ] &#125;&#125;复制代码 使用mini-css-extract-plugin会将js中的css抽离出来，打包成单独的文件，从而避免默认情况下，打包后，由于css通过js动态插入到html中，导致页面闪动。使用css-loder能够解析js中引入的css:import &quot;main.less&quot;。使用style-loader把加载的css作为style标签内容插入到html中。使用postcss-loader autoprefixer能够将css代码自动加兼容性前缀，配置如上代码。使用less-loader将less代码转为css。 babel-loaderBabel是编写下一代JavaScript的编译器，可以将当前运行平台(浏览器、node服务器)尚不支持的下一代或几代js语法编译为当前支持的js语法版本。使用babel-loader将es6/7语法转为es5浏览器可执行代码。这里安装了babel-loader@7.1.5,不注意会有大坑，原因见注释： 123// babel-loader已经升级到了8，需要装@babel/core，但是还是有问题，所以这里安装@7.1.5cnpm i --save-dev babel-loader@7.1.5 babel-core babel-preset-env babel-polyfill复制代码 12345678910111213141516171819202122232425262728293031const config = &#123; module: &#123; rules: [&#123; test: /\\.js$/, // 只解析include文件夹内的 include: path.resolve(__dirname, &quot;src&quot;), // 排除node_modules文件夹 exclude: /node_modules/, use: [&#123; // cacheDirectory = true 使用缓存，提高性能，将 babel-loader 提速至少两倍 loader: &quot;babel-loader?cacheDirectory&quot;, options: &#123; presets: [ [ &quot;env&quot;, &#123; &quot;modules&quot;: false &#125; ], // 包含stage-1, stage-2以及stage-3的所有功能,个人开发就直接上最新的了，爽 &quot;stage-0&quot; ], plugins: [ &quot;transform-es2015-modules-commonjs&quot; ] &#125; &#125;] &#125;] &#125;&#125;;复制代码 babel-preset-env 是一个新的 preset，（presets是一系列plugin的集合）可以根据配置的目标运行环境,自动启用需要的 babel 插件，由于Preset 的执行顺序时从最后一个逆序执行，所以env写在最前，就当是保底… 但是使用preset依然不会解析Set/Map这样的，这时候就要用babel-polyfill了。babel-polyfill简单描述就是只要引入了babel-polyfill你可以大胆的用ES6，可参考ES6和Babel你不知道的事儿,但是使用后会使代码体积增大，视需求而定。在文件入口引入babel-polyfill即可使用： import &quot;babel-polyfill&quot;.stage-0是对ES7一些提案的支持，Babel通过插件的方式引入，让Babel可以编译ES7代码。当然由于ES7没有定下来，所以这些功能随时肯能被废弃掉的。参考：如何区分Babel中的stage-0,stage-1,stage-2以及stage-3，其通过插件方式引入，所以需要安装： 12cnpm i --save-dev babel-preset-stage-0复制代码 url-loader使用url-loader而非file-loader，因为前者包含了后者，提供了更为强大的功能。他可以解决css样式中引入的图片文件等打包后路径指向不正确和将图片转为DataURL模式（base64编码的字符串形式，More：DATA URL简介及DATA URL的利弊）从而提高网站的加载速度。更多参考：file-loader 和 url-loader 12cnpm i --save-dev url-loader file-loader复制代码 12345678910111213const config = &#123; module: &#123; rules: [&#123; // 处理引入的图片视频字体等文件的loader // 将小于10k的图片文件转为DataURL,并且设置默认的dist中存放方式 test: /\\.(eot|woff|woff2|ttf|svg|png|jpe?g|gif|mp4|webm)(\\?\\S*)?$/, loader: &quot;url-loader?limit=10240&amp;name=assets/img/[name]_[hash].[ext]&quot;, // 一样的作用 // loader: &quot;url-loader?limit=102400&amp;name=[name]_[hash].[ext]&amp;outputPath=assets/img/&quot; &#125;] &#125;&#125;;复制代码 optimization优化。 123456789101112131415161718192021222324252627282930313233343536// css优化压缩const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);const config = &#123; optimization: &#123; // 公共代码抽取 // CommonsChunkPlugin 已弃用，使用optimization.splitChunks代替 // 提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件 splitChunks: &#123; cacheGroups: &#123; commons: &#123; // 选择全部chunk chunks: &quot;all&quot;, // 生成的公共代码文件名，惯用vendor name: &quot;vendor&quot;, // 作用于 test: /[\\\\/]node_modules[\\\\/]/ &#125; &#125; &#125;, // 压缩代码，默认开启 // minimize: true, // 压缩配置 minimizer: [ // 优化压缩css new OptimizeCSSAssetsPlugin(&#123;&#125;), // 压缩js配置 new UglifyJsPlugin(&#123; cache: true, parallel: true, sourceMap: true &#125;) ] &#125;&#125;复制代码 build使用webpack命令即可开始构建，也可以自定义命令npm run build： package.json: 123456&#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot; &#125;&#125;复制代码 github源码github webpack4配置源码希望本文能帮你点亮webpack配置技能点，欢迎评论提问题和star。 原文原文发表于本人blog : 柴犬工作室 CQ STUDIO","tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://onethree.cn/tags/webpack4/"}]},{"title":"TCP/IP协议详解内容总结","date":"2019-08-21T07:12:22.000Z","path":"2019/08/21/arctile_27/","text":"TCP/IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。 这里有几个需要注意的知识点： 互联网地址：也就是IP地址，一般为网络号+子网号+主机号域名系统：通俗的来说，就是一个数据库，可以将主机名转换成IP地址RFC：TCP/IP协议的标准文档端口号：一个逻辑号码，IP包所带有的标记Socket：应用编程接口数据链路层的工作特性： 为IP模块发送和接收IP数据报为ARP模块发送ARP请求和接收ARP应答（ARP：地址解析协议，将IP地址转换成MAC地址）为RARP发送RARP请求和接收RARP应答接下来我们了解一下TCP/IP的工作流程： 数据链路层从ARP得到数据的传递信息，再从IP得到具体的数据信息 IP协议 IP协议头当中，最重要的就是TTL（IP允许通过的最大网段数量）字段（八位），规定该数据包能穿过几个路由之后才会被抛弃。 IP路由选择 ARP协议工作原理 ICMP协议（网络控制文协议） 将IP数据包不能传送的错误信息传送给主机 查询报文 ping查询：主机是否可达，通过计算间隔时间和传送多少个包的数量子网掩码时间戳：获得当前时间差错报文 不产生的情况： ICMP差错报文不产生差错报文源地址为零地址、环目地址、广播地址、多播地址IP路由器选择协议 静态路由选择 静态路由选择 配置接口以默认方式生成路由表项，或者使用route add手动添加表项ICMP报文（ICMP重定向报文）更新表项动态路由选择（只使用在路由之间）RIP（路由信息协议） 分布式的基于距离向量（路由器到每一个目的网络的距离记录）的路由选择协议 router承担的工作： 给每一个已知路由器发送RIP请求报文，要求给出完整的路由表如果接受请求，就将自己的路由表交给请求者；如果没有，就处理IP请求表项（自己部分+跳数/没有的部分+16）接受回应，更新路由表定期更新路由表（一般为30s，只能说太频繁~）OSPF（开放最短路径优先协议） 分布式链路状态（和这两个路由器都有接口的网络）协议 当链路状态发生变化时，采用可靠的洪泛法，向所有的路由器发送信息（相邻的所有路由器的链路状态）最终会建立一个全网的拓扑结构图TCP/IP的三次握手，四次分手 首先我们先来了解TCP报文段 重要的标志我在图中也有标记，重点了解标志位 ACK：确认序号有效 RST：重置连接 SYN：发起了一个新连接 FIN：释放一个连接 三次握手的过程（客户端我们用A表示，服务器端用B表示） 前提：A主动打开，B被动打开 在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。简单来说，就是 建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手在此穿插一个知识点就是SYN攻击，那么什么是SYN攻击？发生的条件是什么？怎么避免？ 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址 是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网 络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： #netstat -nap | grep SYN_RECV 四次分手的过程（客户端我们用A表示，服务器端用B表示）由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。 前提：A主动关闭，B被动关闭 有人可能会问，为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序号+1，B进入CLOSED状态，完成四次挥手。简单来说就是 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？ 为了保证A发送的最后一个ACK报文段能够到达B防止“已失效的连接请求报文段”出现在本连接中OK~是不是很难懂的感觉？那我们来说的“人性化点的”吧 三次握手流程 客户端发个请求“开门呐，我要进来”给服务器服务器发个“进来吧，我去给你开门”给客户端客户端有很客气的发个“谢谢，我要进来了”给服务器四次挥手流程 客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）客户端发个“我知道了，我走了”，之后自己就走了OK，先到这吧","tags":[{"name":"Tcp/Ip","slug":"Tcp-Ip","permalink":"http://onethree.cn/tags/Tcp-Ip/"}]},{"title":"前端组件库(Element UI)的实现原理：教你如何实现自定义组件库，并打包发布至npm","date":"2019-08-21T03:32:21.000Z","path":"2019/08/21/arctile_30/","text":"前言对Vue组件开发有一定了解，对UI组件库的实现比较感兴趣，想要理解其开发原理，这篇文章可以帮助你实现并发布自己的第一个自定义插件。 一. 组件库开发流程1）新建vue项目：文件目录如下图 123456789101112131415.├── dist # 压缩后文件目录├── site # 项目结构目录│ ├── App.vue # 单页应用父组件 │ └── main.js # 单页应用启动入口文件├── src # 开发目录│ ├── assets # 静态文件：scss/image│ ├── components # 存放公共组件库│ ├── index.js # 全局注册组件插件│ └── style.js # 导入scss├── index.html├── package.json # 依赖管理├── webpack.dev.js #项目启动配置文件：npm run dev├── webpack.config.js #项目打包配置文件：npm run build└── README.md #README 2）编写自定义组件，封装成插件：业务组件和功能组件的主要区别 slot插槽占位符，可以实现父子组件传参，父组件templet模版可将子组件slot内容替换。当slot未命名时将父组件全部替换，当定义name时，可以实现父组件对子组件的指定位置显示内容或传参； 123456&lt;div :class=&quot;preCls+&apos;-title&apos;&quot; v-show=&quot;showTitle&quot;&gt; &lt;slot name=&quot;modal-title&quot;&gt;自定义标题&lt;/slot&gt;&lt;/div&gt;&lt;div :class=&quot;preCls+&apos;-body&apos;&quot; v-show=&quot;showBody&quot;&gt; &lt;slot name=&quot;modal-body&quot;&gt;自定义内容&lt;/slot&gt;&lt;/div&gt; 定义多个className时，可以将其class作为属性放入对象中，根据是否传入props参数进行判断； 123456789101112classBtn() &#123; let &#123;preCls, type, size, shape&#125; = this let className = [ `$&#123;preCls&#125;`, &#123; [`$&#123;preCls&#125;-$&#123;type&#125;`]: !!type, [`$&#123;preCls&#125;-$&#123;size&#125;`]: !!size, [`$&#123;preCls&#125;-$&#123;shape&#125;`]: !!shape, &#125;, ] return className&#125; props自定义验证，当没有遵循传入规则时需要对其进行一个预先检查，validator可以通过自定义函数对传入的参数进行校验； 12345678type: &#123; type: String, default: &apos;default&apos;,//[&apos;default&apos;,success&apos;, &apos;warning&apos;, &apos;error&apos;, &apos;info&apos;] validator(value) &#123; let types = [&apos;default&apos;,&apos;success&apos;, &apos;warning&apos;, &apos;error&apos;, &apos;info&apos;] return types.includes(value) || !value &#125;&#125;, 在src/index.js来封装组件，该文件即是webpack配置的入口文件，install是挂载组件的方法，有了它就可以在外部引用并Vue.use一个插件了； 12345678import * as components from &apos;./components&apos;var VuePlugin = &#123;&#125;VuePlugin.install = function(Vue, options) &#123; for(let component in components) &#123; Vue.component(&apos;yw&apos;+component, components[component]); &#125;&#125;export default VuePlugin 此时，你已经在本地成功创建好了一个组件库插件，在本地main.js中引入插件和css文件import &#39;@/assets/index.scss&#39;， import YwVue from &#39;@&#39;并注册使用Vue.use(YwVue)即可在项目中查看自定义的组件效果。以下步骤将你的插件打包并发布到npm： 3）修改配置项webpack.config.js： 将src中的index作为入口文件，出口文件(yw.js)必须与pakage.json中的main相同； 1234567891011entry: &#123; style: &apos;./src/style.js&apos;, yw: &apos;./src/index.js&apos;,&#125;,output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: &apos;/dist/&apos;, filename: &apos;[name].js&apos;, library: &apos;Yw&apos;, libraryTarget: &apos;umd&apos;&#125;, 通过extract-text-webpack-plugin插件将scss单独打包(yw.css)，便于外部引用； 1234567891011&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;vue-style-loader&apos;, use: [&apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;)&#125;,module.exports.plugins = (module.exports.plugins || []).concat([ new ExtractTextPlugin(&quot;yw.css&quot;,&#123;allChunks: true&#125;), ......]) pakage.json： main结点是打包后的快捷路径(yw-ui)，可以直接引用，无需指定相对的路径(yw-ui/dist/yw.js)； 开源协议license为”MIT”； 将private设为false组件即可公用； 123456789&#123; &quot;name&quot;: &quot;ywbj-ui&quot;, //包名，npm install **** &quot;description&quot;: &quot;A components of pc base on vue2.X&quot;, &quot;version&quot;: &quot;1.0.1&quot;, //每次打包上传，必须更新版本号 &quot;author&quot;: &quot;yourName &lt;****@**.com&gt;&quot;, //输入你的信息和邮箱 &quot;main&quot;: &quot;dist/yw.js&quot;, //必须和webpack打包的出口文件名一致 &quot;license&quot;: &quot;MIT&quot;, //开源协议 &quot;private&quot;: false, //true为私有，false为公共&#125; 配置完成后执行npm run build，生成打包文件夹dist； ​ ​ dist目录 4）发布到npm 首先在npm官网(https://www.npmjs.com/)注册用户； 将本地npm源设置为https://registry.npmjs.org/ (若为淘宝源则登陆不成功); 进入项目文件夹，执行npm login会要求你输入用户名、密码和邮箱; npm publish将打包后的文件发布到npm，成功后可在官网搜到包名(注意：每次publish之前需要更新pakage.json中的版本号，否则上传不成功)； ​ ​ 包已经上传至npm 二. 安装使用自己的插件12345678910#安装插件npm install ywbj-ui --save #引入项目中import YwUI from &apos;ywbj-ui&apos;import &apos;ywbj-ui/dist/yw.css&apos;Vue.use(YwUI) #组件中直接使用&lt;yw-button type=&quot;success&quot; isDisabled&gt;success&lt;/yw-button&gt; 三. 自定义组件API文档Button按钮组件 参数 说明 类型 可选值 默认值 shape 按钮的形状 string 圆角：circle’, 直角：’rectangle’ ‘ ’ isDisabled 是否禁用按钮 boolean true/false false type 按钮的类型 string ‘default’,success’, ‘warning’, ‘error’, ‘info’ default size 按钮的大小 string ‘large’, ‘medium’, ‘small’ ‘ ’ Modal对话框组件 参数 说明 类型 可选值 默认值 isShow 是否显示 boolean true/false false width 宽度 number showTitle 是否显示标题 boolean true/false true showBody 是否显示主体 boolean true/false true showFooter 是否显示按钮 boolean true/false true size 对话框大小 string ‘large’, ‘medium’, ‘small’ ‘medium’ 四. 引用效果展示","tags":[{"name":"vue","slug":"vue","permalink":"http://onethree.cn/tags/vue/"},{"name":"npm","slug":"npm","permalink":"http://onethree.cn/tags/npm/"},{"name":"Element UI","slug":"Element-UI","permalink":"http://onethree.cn/tags/Element-UI/"}]},{"title":"深入浅出 TCP/IP 协议栈","date":"2019-06-25T13:12:40.000Z","path":"2019/06/25/arctile_26/","text":"TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是应用层、传输层、网络层和链路层，每一层都呼叫它的下一层所提供的协议来完成自己的需求。由于我们大部分时间都工作在应用层，下层的事情不用我们操心；其次网络协议体系本身就很复杂庞大，入门门槛高，因此很难搞清楚TCP/IP的工作原理，通俗一点讲就是，一个主机的数据要经过哪些过程才能发送到对方的主机上。 接下来，我们就来探索一下这个过程。 0、物理介质物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号(0和1)的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。 TCP/IP协议栈分为四层，每一层都由特定的协议与对方进行通信，而协议之间的通信最终都要转化为 0 和 1 的电信号，通过物理介质进行传输才能到达对方的电脑，因此物理介质是网络通信的基石。 下面我们通过一张图先来大概了解一下TCP/IP协议的基本框架： 当通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。 网络通信就好比送快递，商品外面的一层层包裹就是各种协议，协议包含了商品信息、收货地址、收件人、联系方式等，然后还需要配送车、配送站、快递员，商品才能最终到达用户手中。 一般情况下，快递是不能直达的，需要先转发到对应的配送站，然后由配送站再进行派件。 配送车就是物理介质，配送站就是网关， 快递员就是路由器，收货地址就是IP地址，联系方式就是MAC地址。 快递员负责把包裹转发到各个配送站，配送站根据收获地址里的省市区，确认是否需要继续转发到其他配送站，当包裹到达了目标配送站以后，配送站再根据联系方式找到收件人进行派件。 有了整体概念以后，下面我们详细了解一下各层的分工。 1、链路层网络通信就是把有特定意义的数据通过物理介质传送给对方，单纯的发送 0 和 1 是没有意义的，要传输有意义的数据，就需要以字节为单位对 0 和 1 进行分组，并且要标识好每一组电信号的信息特征，然后按照分组的顺序依次发送。以太网规定一组电信号就是一个数据包，一个数据包被称为一帧， 制定这个规则的协议就是以太网协议。一个完整的以太网数据包如下图所示： 整个数据帧由首部、数据和尾部三部分组成，首部固定为14个字节，包含了目标MAC地址、源MAC地址和类型；数据最短为46个字节，最长为1500个字节，如果需要传输的数据很长，就必须分割成多个帧进行发送；尾部固定为4个字节，表示数据帧校验序列，用于确定数据包在传输过程中是否损坏。因此，以太网协议通过对电信号进行分组并形成数据帧，然后通过物理介质把数据帧发送给接收方。那么以太网如何来识接收方的身份呢？ 以太网规协议定，接入网络的设备都必须安装网络适配器，即网卡， 数据包必须是从一块网卡传送到另一块网卡。而网卡地址就是数据包的发送地址和接收地址，也就是帧首部所包含的MAC地址，MAC地址是每块网卡的身份标识，就如同我们身份证上的身份证号码，具有全球唯一性。MAC地址采用十六进制标识，共6个字节， 前三个字节是厂商编号，后三个字节是网卡流水号，例如 4C-0F-6E-12-D2-19 有了MAC地址以后，以太网采用广播形式，把数据包发给该子网内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。 所以链路层的主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。 2、网络层对于上面的过程，有几个细节问题值得我们思考： 发送者如何知道接收者的MAC地址？ 发送者如何知道接收者和自己同属一个子网？ 如果接收者和自己不在同一个子网，数据包如何发给对方？ 为了解决这些问题，网络层引入了三个协议，分别是IP协议、ARP协议、路由协议。 【1】IP协议通过前面的介绍我们知道，MAC地址只与厂商有关，与所处的网络无关，所以无法通过MAC地址来判断两台主机是否属于同一个子网。 因此，网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。 IP地址目前有两个版本，分别是IPv4和IPv6，IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。由于各类地址的分法不尽相同，以C类地址192.168.24.1为例，其中前24位就是网络地址，后8位就是主机地址。因此， 如果两个IP地址在同一个子网内，则网络地址一定相同。为了判断IP地址中的网络地址，IP协议还引入了子网掩码， IP地址和子网掩码通过按位与运算后就可以得到网络地址。 由于发送者和接收者的IP地址是已知的(应用层的协议会传入)， 因此我们只要通过子网掩码对两个IP地址进行AND运算后就能够判断双方是否在同一个子网了。 【2】ARP协议即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下： ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。cmd输入 arp -a 就可以查询本机缓存的ARP数据。 【3】路由协议通过ARP协议的工作原理可以发现，ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议，首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。 而完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 【4】IP数据包在网络层被包装的数据包就叫IP数据包，IPv4数据包的结构如下图所示： IP数据包由首部和数据两部分组成，首部长度为20个字节，主要包含了目标IP地址和源IP地址，目标IP地址是网关路由的线索和依据；数据部分的最大长度为65515字节，理论上一个IP数据包的总长度可以达到65535个字节，而以太网数据包的最大长度是1500个字符，如果超过这个大小，就需要对IP数据包进行分割，分成多帧发送。 所以，网络层的主要工作是定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由。 3、传输层链路层定义了主机的身份，即MAC地址， 而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。 因此传输层引入了UDP协议来解决这个问题，为了给每个应用程序标识身份，UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。 这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP定义的数据包就叫做UDP数据包，结构如下所示： UDP数据包由首部和数据两部分组成，首部长度为8个字节，主要包括源端口和目标端口；数据最大为65527个字节，整个数据包的长度最大可达到65535个字节。 UDP协议比较简单，实现容易，但它没有确认机制， 数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了，TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。 为了保证传输的可靠性，TCP 协议在 UDP 基础之上建立了三次对话的确认机制，也就是说，在正式收发数据前，必须和对方建立可靠的连接。由于建立过程较为复杂，我们在这里做一个形象的描述： 主机A：我想发数据给你，可以么？ 主机B：可以，你什么时候发？ 主机A：我马上发，你接着！ 经过三次对话之后，主机A才会向主机B发送正式数据，而UDP是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发过去了。所以 TCP 能够保证数据包在传输过程中不被丢失，但美好的事物必然是要付出代价的，相比 UDP，TCP 实现过程复杂，消耗连接资源多，传输速度慢。 TCP 数据包和 UDP 一样，都是由首部和数据两部分组成，唯一不同的是，TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过IP数据包的长度，以确保单个 TCP 数据包不必再分割。 总结一下，传输层的主要工作是定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。 4、应用层理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差。因此，应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等，HTTP 是一种比较常用的应用层协议，主要用于B/S架构之间的数据通信，其报文格式如下： 在 Resquest Headers 中，Accept 表示客户端期望接收的数据格式，而 ContentType 则表示客户端发送的数据格式；在 Response Headers 中，ContentType 表示服务端响应的数据格式，这里定义的格式，一般是和 Resquest Headers 中 Accept 定义的格式是一致的。 有了这个规范以后，服务端收到请求以后，就能正确的解析客户端发来的数据，当请求处理完以后，再按照客户端要求的格式返回，客户端收到结果后，按照服务端返回的格式进行解析。 所以应用层的主要工作就是定义数据格式并按照对应的格式解读数据。 5、全流程首先我们梳理一下每层模型的职责： 链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据； 网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发； 传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序； 应用层：定义数据格式，并按照对应的格式解读数据。 然后再把每层模型的职责串联起来，用一句通俗易懂的话讲就是： 当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。 6、总结以上内容是对TCP/IP四层模型做了简单的介绍，而实际上每一层模型都有很多协议，每个协议要做的事情也很多，但我们首先得有一个清晰的脉络结构，掌握每一层模型最基本的作用，然后再去丰富细枝末节的东西，也许会更容易理解。","tags":[{"name":"Tcp/Ip","slug":"Tcp-Ip","permalink":"http://onethree.cn/tags/Tcp-Ip/"}]},{"title":"在开始 React 之前，JavaScript 这些知识点你学好了吗？","date":"2019-05-21T04:22:41.000Z","path":"2019/05/21/arctile_21/","text":"React 完全是关于 JavaScript 的。而且，有很多材料是关于 JavaScript 而不是 React。其中大部分是 JavaScript ES6 及其特性和语法，还包括三元运算符、简化的语法、this 对象、JavaScript 内置函数（map、reduce、filter）或更一般的概念，如可组合性、可重用性、不变性或高阶函数。在刚开始接触 React 之前，你可能不需要掌握这些基础知识，但在学习或实践过程中肯定需要用到它们。 在开始 React 之前先学习 JavaScript 当你开始进入 React 的世界，create-react-app 通常会是你的第一个 React 项目。在搭建好项目后，你将看到下面的这个 React 类组件： 12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;import logo from &apos;./logo.svg&apos;;import &apos;./App.css&apos;;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt; &lt;/header&gt; &lt;p className=&quot;App-intro&quot;&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; React 类组件可能不是最好的入手点。新手有许多东西需要消化，不一定与 React 有关：类语句、类方法和继承。导入语句也会在学习 React 时增加额外的复杂性。尽管主要焦点应该放在 JSX（React 的语法）上，但其他的东西也需要解释一番。这篇文章主要针对 JavaScript，所以请不用太担心 React 相关的内容。 React 和 JavaScript 类 关于 React 类组件，需要用到有关 JavaScript 类的先验知识。JavaScript 类的概念相对较新。之前，只有 JavaScript 的原型链可用于实现继承。JavaScript 类以原型继承为基础，让继承体系变得更简单。 定义 React 组件的一种方法是使用 JavaScript 类。 1234567891011121314class Developer &#123; constructor(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; &#125; getName() &#123; return this.firstname + &apos; &apos; + this.lastname; &#125;&#125;var me = new Developer(&apos;Robin&apos;, &apos;Wieruch&apos;);console.log(me.getName()); 一个类描述了一个实体，用于创建实体的实例。在使用 new 语句创建类的实例时，会调用这个类的构造函数。类的属性通常位于构造函数中。此外，类方法（例如 getName()）用于读取（或写入）实例的数据。类的实例在类中使用 this 对象来表示，但在外部，仅指定给 JavaScript 变量。 在面向对象编程中，类通常用来实现继承。在 JavaScript 中也一样，extends 语句可用于让一个类继承另一个类。一个子类通过 extends 语句继承了一个父类的所有功能，还可以添加自己的功能。 123456789101112131415161718192021class Developer &#123; constructor(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; &#125; getName() &#123; return this.firstname + &apos; &apos; + this.lastname; &#125;&#125;class ReactDeveloper extends Developer &#123; getJob() &#123; return &apos;React Developer&apos;; &#125;&#125;var me = new ReactDeveloper(&apos;Robin&apos;, &apos;Wieruch&apos;);console.log(me.getName());console.log(me.getJob()); 基本上，要理解 React 的类组件，知道这些就够了。JavaScript 类用于定义 React 组件，React 组件继承了从 React 包导入的 React Component 类的所有功能。 1234567891011import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Welcome to React&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 这就是为什么 render() 方法在 React 类组件中是必需的：从 React 包导入的 React Component 用它在浏览器中显示某些内容。此外，如果不从 React Component 继承，将无法使用其他生命周期方法（包括 render() 方法）。例如，如果不继承，那么 componentDidMount() 生命周期方法就不存在，因为现在这个类只是一个普通 JavaScript 类的实例。除了生命周期方法不可用，React 的 API 方法（例如用于本地状态管理的 this.setState()）也不可用。 我们可以通过 JavaScript 类来扩展通用类的行为。因此，我们可以引入自己的类方法或属性。 123456789101112131415import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; getGreeting() &#123; return &apos;Welcome to React&apos;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.getGreeting()&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 现在你应该知道为什么 React 使用 JavaScript 类来定义 React 类组件。当你需要访问 React 的 API（生命周期方法、this.state 和 this.setState()）时，可以使用它们。接下来，你将看到如何以不同的方式定义 React 组件，比如不使用 JavaScript 类，因为有时候你可能不需要使用类方法、生命周期方法或状态。 尽管我们可以在 React 中使用 JavaScript 类继承，但这对于 React 来说不是一个理想的结果，因为 React 更倾向于使用组合而不是继承。因此，你的 React 组件需要扩展的唯一类应该是 React Component。 React 中的箭头函数 在给别人培训 React 时，我在一开始就向他们解释 JavaScript 的箭头函数。箭头函数是 ES6 新增的语言特性之一，让 JavaScript 向函数式编程更近了一步。 12345678910111213// JavaScript ES5 functionfunction getGreeting() &#123; return &apos;Welcome to JavaScript&apos;;&#125;// JavaScript ES6 arrow function with bodyconst getGreeting = () =&gt; &#123; return &apos;Welcome to JavaScript&apos;;&#125;// JavaScript ES6 arrow function without body and implicit returnconst getGreeting = () =&gt; &apos;Welcome to JavaScript&apos;; 在 React 应用程序中使用 JavaScript 箭头函数通常是为了让代码保持简洁和可读。我很喜欢箭头函数，总是尝试将我的函数从 JavaScript ES5 重构成 ES6。在某些时候，当 JavaScript ES5 函数和 JavaScript ES6 函数之间的差异很明显时，我会使用 JavaScript ES6 的箭头函数。不过，对 React 新手来说，太多不同的语法可能会让人不知所措。因此，在 React 中使用它们之前，我会尝试解释 JavaScript 函数的不同特点。在以下部分，你将了解到如何在 React 中使用 JavaScript 箭头函数。 在 React 中将函数视为组件 React 使用了不同的编程范式，这要归功于 JavaScript 是一门“多面手”编程语言。在面向对象编程方面，React 的类组件可以很好地利用 JavaScript 类（React 组件 API 的继承、类方法和类属性，如 this.state）。另一方面，React（及其生态系统）也使用了很多函数式编程的概念。例如，React 的函数无状态组件是另一种定义 React 组件的方式。那么，如果可以像函数那样使用组件，将会怎样？ 123function (props) &#123; return view;&#125; 这是一个接收输入（例如 props）并返回 HTML 元素（视图）的函数。它不需要管理任何状态（无状态），也不需要了解任何方法（类方法、生命周期方法）。这个函数只需要使用 React 组件的 render() 方法来进行渲染。 123function Greeting(props) &#123; return &lt;h1&gt;&#123;props.greeting&#125;&lt;/h1&gt;;&#125; 功能无状态组件是在 React 中定义组件的首选方法。它们的样板代码较少，复杂性较低，并且比 React 类组件更易于维护。不过，这两者都有自己存在的理由。 之前提到了 JavaScript 箭头函数以及它们可以提升代码的可读性，现在让我们将这些函数应用无状态组件中。之前的 Greeting 组件在 JavaScript ES5 和 ES6 中的写法有点不一样： 12345678910111213// JavaScript ES5 functionfunction Greeting(props) &#123; return &lt;h1&gt;&#123;props.greeting&#125;&lt;/h1&gt;;&#125;// JavaScript ES6 arrow functionconst Greeting = (props) =&gt; &#123; return &lt;h1&gt;&#123;props.greeting&#125;&lt;/h1&gt;;&#125;// JavaScript ES6 arrow function without body and implicit returnconst Greeting = (props) =&gt; &lt;h1&gt;&#123;props.greeting&#125;&lt;/h1&gt; JavaScript 箭头函数是让 React 无状态组件保持简洁的一个不错的方法。 React 类组件语法 React 定义组件的方式一直在演化。在早期阶段，React.createClass() 方法是创建 React 类组件的默认方式。现在不再使用这个方法，因为随着 JavaScript ES6 的兴起，之前的 React 类组件语法成为默认语法。 不过，JavaScript 也在不断发展，因此 JavaScript 爱好者一直在寻找新的方式。这就是为什么你会发现 React 类组件使用了不同的语法。使用状态和类方法来定义 React 类组件的一种方法如下： 12345678910111213141516171819202122232425262728293031class Counter extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; counter: 0, &#125;; this.onIncrement = this.onIncrement.bind(this); this.onDecrement = this.onDecrement.bind(this); &#125; onIncrement() &#123; this.setState(state =&gt; (&#123; counter: state.counter + 1 &#125;)); &#125; onDecrement() &#123; this.setState(state =&gt; (&#123; counter: state.counter - 1 &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.counter&#125;&lt;/p&gt; &lt;button onClick=&#123;this.onIncrement&#125; type=&quot;button&quot;&gt;Increment&lt;/button&gt; &lt;button onClick=&#123;this.onDecrement&#125; type=&quot;button&quot;&gt;Decrement&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 不过，在实现大量的 React 类组件时，构造函数中的类方法绑定和构造函数本身就变成了繁琐的实现细节。所运的是，有一个简短的语法可用来摆脱这两个烦恼： 123456789101112131415161718192021222324class Counter extends Component &#123; state = &#123; counter: 0, &#125;; onIncrement = () =&gt; &#123; this.setState(state =&gt; (&#123; counter: state.counter + 1 &#125;)); &#125; onDecrement = () =&gt; &#123; this.setState(state =&gt; (&#123; counter: state.counter - 1 &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.counter&#125;&lt;/p&gt; &lt;button onClick=&#123;this.onIncrement&#125; type=&quot;button&quot;&gt;Increment&lt;/button&gt; &lt;button onClick=&#123;this.onDecrement&#125; type=&quot;button&quot;&gt;Decrement&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 通过使用 JavaScript 箭头函数，可以自动绑定类方法，不需要在构造函数中绑定它们。通过将状态直接定义为类属性，在不使用 props 时就可以省略构造函数。（注意：请注意，JavaScript 还不支持类属性。）因此，你可以说这种定义 React 类组件的方式比其他版本更简洁。 React 中的模板字面量 模板字面量是 JavaScript ES6 附带的另一种 JavaScript 语言特性。之所以提到这个特性，是因为当 JavaScript 和 React 新手看到它们时，可能会感到困惑。以下面的连接字符串的语法为例： 1234567function getGreeting(what) &#123; return &apos;Welcome to &apos; + what;&#125;const greeting = getGreeting(&apos;JavaScript&apos;);console.log(greeting);// Welcome to JavaScript 模板字面量可以用于达到相同的目的，被称为字符串插值： 123function getGreeting(what) &#123; return `Welcome to $&#123;what&#125;`;&#125; 你只需使用反引号和 ${}来插入 JavaScript 原语。字符串字面量不仅可用于字符串插值，还可用于多行字符串： 1234567function getGreeting(what) &#123; return ` Welcome to $&#123;what&#125; `;&#125; 这样就可以格式化多行文本块。 React 中 Map、Reduce 和 Filter 在向 React 新手教授 JSX 语法时，我通常会先在 render() 方法中定义一个变量，然后将其用在返回代码块中。 1234567891011121314import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; var greeting = &apos;Welcome to React&apos;; return ( &lt;div&gt; &lt;h1&gt;&#123;greeting&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default App; 你只需使用花括号来操作 HTML 中的 JavaScript。不管是渲染字符串还是渲染一个复杂的对象，并没有太大不同。 123456789101112import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; var user = &#123; name: &apos;Robin&apos; &#125;; return ( &lt;div&gt; &lt;h1&gt;&#123;user.name&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 接下来的问题是：如何渲染项目列表？React 没有提供特定的 API（例如 HTML 标记的自定义属性）用于渲染项目列表。我们可以使用纯 JavaScript 代码来迭代项目列表，并返回每个项目的 HTML。 123456789101112131415161718import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; var users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; return ( &lt;ul&gt; &#123;users.map(function (user) &#123; return &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;; &#125;)&#125; &lt;/ul&gt; ); &#125;&#125; 通过使用 JavaScript 箭头函数，你可以摆脱箭头函数体和 return 语句，让渲染输出更加简洁。 12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; var users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; return ( &lt;ul&gt; &#123;users.map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; ); &#125;&#125; 很快，每个 React 开发人员都习惯了 JavaScript 内置的 map() 方法。对数组进行 map 并返回每个项的渲染输出，这样做非常有用。在某系情况下，结合使用 filter() 或 reduce() 会更有用，而不只是为每个被 map 的项渲染输出。 12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; var users = [ &#123; name: &apos;Robin&apos;, isDeveloper: true &#125;, &#123; name: &apos;Markus&apos;, isDeveloper: false &#125;, ]; return ( &lt;ul&gt; &#123;users .filter(user =&gt; user.isDeveloper) .map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; ); &#125;&#125; 通常，React 开发人员习惯于使用 JavaScript 的这些内置函数，而不必使用 React 特定的 API。它只是 HTML 中的 JavaScript。 React 中的 var、let 和 const 对于 React 的新手来说，使用 var、let 和 const 来声明变量可能也会给他们造成混淆，虽然它们不是 React 相关的。我会尝试在教学中尽早介绍 let 和 const，并从在 React 组件中交替使用 const 和 var 开始： 12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; const users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; return ( &lt;ul&gt; &#123;users.map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; ); &#125;&#125; 然后我给出了一些使用这些变量声明的经验法则： （1）不要使用 var，因为 let 和 const 更具体 （2）默认使用 const，因为它不能被重新分配或重新声明 （3）如果要重新赋值变量则使用 let let 通常用于 for 循环中，const 通常用于保持 JavaScript 变量不变。尽管在使用 const 时可以修改对象和数组的内部属性，但变量声明表达了保持变量不变的意图。 React 中的三元运算符 如果要通过 if-else 语句进行条件渲染该怎么办？我们不能直接在 JSX 中使用 if-else 语句，但可以从渲染函数中提前返回。如果不需要显示内容，返回 null 在 React 中是合法的。 12345678910111213141516171819202122import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; const users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; const showUsers = false; if (!showUsers) &#123; return null; &#125; return ( &lt;ul&gt; &#123;users.map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; ); &#125;&#125; 不过，如果要在返回的 JSX 中使用 if-else 语句，可以使用 JavaScript 的三元运算符： 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; const users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; const showUsers = false; return ( &lt;div&gt; &#123; showUsers ? ( &lt;ul&gt; &#123;users.map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; ) : ( null ) &#125; &lt;/div&gt; ); &#125;&#125; 如果你只返回条件渲染的一个方面，可以使用 &amp;&amp; 运算符： 123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; const users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; const showUsers = false; return ( &lt;div&gt; &#123; showUsers &amp;&amp; ( &lt;ul&gt; &#123;users.map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; ) &#125; &lt;/div&gt; ); &#125;&#125; React 中的导入和导出语句 在 JavaScript 中，我们可以通过 import 和 export 语句来导入和导出在 JavaScript ES6 文件中定义的功能。 在开始你的第一个 React 应用程序之前，这些 import 和 export 语句是另一个需要了解的话题。create-react-app 项目已经在使用 import 语句： 12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;import logo from &apos;./logo.svg&apos;;import &apos;./App.css&apos;;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt; &lt;/header&gt; &lt;p className=&quot;App-intro&quot;&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 这对初始项目来说非常棒，因为它为你提供了一个全面的体验，可以导入和导出其他文件。不过，在刚开始接触 React 时，我会试着避免这些导入。相反，我会专注于 JSX 和 React 组件。在需要将 React 组件或 JavaScript 函数分离到单独的文件中时，才需要引入导入和导出语句。 那么这样使用这些导入和导出语句呢？假设你想要导出一个文件的如下变量： 1234567891011const firstname = &apos;Robin&apos;;const lastname = &apos;Wieruch&apos;;export &#123; firstname, lastname &#125;;然后，你可以通过第一个文件的相对路径将它们导入到另一个文件中：import &#123; firstname, lastname &#125; from &apos;./file1.js&apos;;console.log(firstname);// output: Robin 因此，它不一定只是与导入或导出组件或函数有关，它可以是共享可分配给变量的所有东西（我们只谈 JS）。你还可以将另一个文件导出的所有变量作为一个对象导入： 1234567891011import * as person from &apos;./file1.js&apos;;console.log(person.firstname);// output: Robin导入可以有别名。当从多个文件导入具有相同导出名称的功能时，就需要用到别名。import &#123; firstname as username &#125; from &apos;./file1.js&apos;;console.log(username);// output: Robin 之前所有的例子都是命名的导入和导出。除此之外，还有默认的导入和导出。它可以用于以下一些场景： 导出和导入单个功能； 强调一个模块导出 API 的主要功能； 作为导入功能的后备。 12345678910111213const robin = &#123; firstname: &apos;Robin&apos;, lastname: &apos;Wieruch&apos;,&#125;;export default robin;在使用默认导入时可以省略大括号：import developer from &apos;./file1.js&apos;;console.log(developer);// output: &#123; firstname: &apos;Robin&apos;, lastname: &apos;Wieruch&apos; &#125; 此外，导入名称可以与导出的默认名称不同。你还可以将它与命名的 export 和 import 语句一起使用： 1234567891011121314const firstname = &apos;Robin&apos;;const lastname = &apos;Wieruch&apos;;const person = &#123; firstname, lastname,&#125;;export &#123; firstname, lastname,&#125;;export default person; 在另一个文件中导入： 123456import developer, &#123; firstname, lastname &#125; from &apos;./file1.js&apos;;console.log(developer);// output: &#123; firstname: &apos;Robin&apos;, lastname: &apos;Wieruch&apos; &#125;console.log(firstname, lastname);// output: Robin Wieruch 你还可以节省一些行，直接导出命名的变量： 12export const firstname = &apos;Robin&apos;;export const lastname = &apos;Wieruch&apos;; 这些是 ES6 模块的主要功能。它们可以帮助你更好地组织代码，并设计出可重用的模块 API。 React 中的库 React 只是应用程序的视图层。React 提供了一些内部状态管理，但除此之外，它只是一个为浏览器渲染 HTML 的组件库。API（例如浏览器 API、DOM API）、JavaScript 或外部库可以为 React 添加额外的东西。为 React 应用程序选择合适的库并不是件容易的事，但一旦你对不同的库有了很好的了解，就可以选择最适合你的技术栈的库。 例如，我们可以使用 React 原生的获取数据的 API 来获取数据： 1234567891011121314151617import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; state = &#123; data: null, &#125;; componentDidMount() &#123; fetch(&apos;https://api.mydomain.com&apos;) .then(response =&gt; response.json()) .then(data =&gt; this.setState(&#123; data &#125;)); &#125; render() &#123; ... &#125;&#125; 但你也可以使用另一个库来获取数据，Axios 就是这样的一个流行库： 1234567891011121314151617import React, &#123; Component &#125; from &apos;react&apos;;import axios from &apos;axios&apos;;class App extends Component &#123; state = &#123; data: null, &#125;; componentDidMount() &#123; axios.get(&apos;https://api.mydomain.com&apos;) .then(data =&gt; this.setState(&#123; data &#125;)); &#125; render() &#123; ... &#125;&#125; 因此，一旦你知道了需要解决什么问题，React 的生态系统就可以为你提供大量的解决方案。这可能与 React 本身无关，而是有关了解如何选择可用于弥补 React 应用程序的各种 JavaScript 库。 React 中的高阶函数 高阶函数是函数式编程中的一个非常棒的概念。在 React 中，了解这些函数是非常有意义的，因为在某些时候你需要处理高阶组件，如果已经了解了高阶函数，那么就可以更好地了解这些高阶组件。 我们假设可以根据一个输入字段的值对用户列表进行过滤。 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; state = &#123; query: &apos;&apos;, &#125;; onChange = event =&gt; &#123; this.setState(&#123; query: event.target.value &#125;); &#125; render() &#123; const users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; return ( &lt;div&gt; &lt;ul&gt; &#123;users .filter(user =&gt; this.state.query === user.name) .map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.onChange&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 我们并不总是希望通过提取函数的方式来实现，因为这样会增加不必要的复杂性。但是，通过提取函数，我们可以对其进行单独的测试。因此，让我们使用内置的 filter 函数来实现这个例子。 1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from &apos;react&apos;;function doFilter(user) &#123; return query === user.name;&#125;class App extends Component &#123; ... render() &#123; const users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; return ( &lt;div&gt; &lt;ul&gt; &#123;users .filter(doFilter) .map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.onChange&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 这个实现还起不到作用，因为 doFilter() 函数需要知道 state 的 query 属性。我们可以通过另一个包装函数来传递它，也就是高阶函数。 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from &apos;react&apos;;function doFilter(query) &#123; return function (user) &#123; return query === user.name; &#125;&#125;class App extends Component &#123; ... render() &#123; const users = [ &#123; name: &apos;Robin&apos; &#125;, &#123; name: &apos;Markus&apos; &#125;, ]; return ( &lt;div&gt; &lt;ul&gt; &#123;users .filter(doFilter(this.state.query)) .map(user =&gt; &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.onChange&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 基本上，高阶函数是可以返回函数的函数。通过使用 JavaScript ES6 的箭头函数，你可以让高阶函数变得更简洁。此外，这种简化的方式让将函数组合成函数变得更吸引人。 12const doFilter = query =&gt; user =&gt; query === user.name; 现在可以将 doFilter() 函数从文件中导出，并将其作为纯（高阶）函数进行单独的测试。在了解了高阶函数之后，就为学习 React 的高阶组件奠定了基础。 将这些函数提取到 React 组件之外的（高阶）函数中也助于单独测试 React 的本地状态管理。 123456789101112131415161718192021222324252627282930export const doIncrement = state =&gt; (&#123; counter: state.counter + 1 &#125;);export const doDecrement = state =&gt; (&#123; counter: state.counter - 1 &#125;);class Counter extends Component &#123; state = &#123; counter: 0, &#125;; onIncrement = () =&gt; &#123; this.setState(doIncrement); &#125; onDecrement = () =&gt; &#123; this.setState(doDecrement); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.counter&#125;&lt;/p&gt; &lt;button onClick=&#123;this.onIncrement&#125; type=&quot;button&quot;&gt;Increment&lt;/button&gt; &lt;button onClick=&#123;this.onDecrement&#125; type=&quot;button&quot;&gt;Decrement&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 函数式编程非常强大，转向函数式编程有助于了解 JavaScript 将函数作为一等公民所带来的好处。 React 中的解构和展开运算符 JavaScript 中引入的另一种语言特性称为解构。通常情况下，你需要在组件的 state 或 props 中访问大量的属性。你可以在 JavaScript 中使用解构赋值，而不是逐个将它们分配给变量。 123456// no destructuringconst users = this.state.users;const counter = this.state.counter;// destructuringconst &#123; users, counter &#125; = this.state; 这对函数式无状态组件来说特别有用，因为它们可以在函数签名中收到 props 对象。通常，你用到的不是 props，而是 props 里的内容，因此你可以对函数签名中已有的内容进行解构。 123456789// no destructuringfunction Greeting(props) &#123; return &lt;h1&gt;&#123;props.greeting&#125;&lt;/h1&gt;;&#125;// destructuringfunction Greeting(&#123; greeting &#125;) &#123; return &lt;h1&gt;&#123;greeting&#125;&lt;/h1&gt;;&#125; 解构也适用于 JavaScript 数组。另一个很棒的特性是剩余解构。它通常用于拆分对象的一部分属性，并将剩余属性保留在另一个对象中。 12// rest destructuringconst &#123; users, ...rest &#125; = this.state; uesrs 可以在 React 组件中渲染，而剩余状态可以用在其他地方。这就是 JavaScript 展开（spread）运算发挥作用的地方，它可以将对象的剩余部分转到下一个组件。 JavaScript 多过 React React 只提供了一个细小的 API 表面区域，因此开发人员必须习惯于 JavaScript 提供的所有功能。这句话并非没有任何理由：“成为 React 开发者也会让你成为更好的 JavaScript 开发者”。让我们通过重构一个高阶组件来回顾一下学到的 JavaScript 的一些方面。 1234567891011121314function withLoading(Component) &#123; return class WithLoading extends &#123; render() &#123; const &#123; isLoading, ...props &#125; = this.props; if (isLoading) &#123; return &lt;p&gt;Loading&lt;/p&gt;; &#125; return &lt;Component &#123; ...props &#125; /&gt;; &#125; &#125; &#125;;&#125; 这个高阶组件用于显示条件加载进度条，当 isLoading 被设为 true 时，就可以显示加载进度条，否则就渲染输入组件。在这里可以看到（剩余）解构和展开运算符的实际应用。后者可以在渲染的 Component 中看到，因为 props 对象的剩余属性被传给了那个 Component。 让高阶组件变得更简洁的第一步是将返回的 React 类组件重构为函数式无状态组件： 123456789function withLoading(Component) &#123; return function (&#123; isLoading, ...props &#125;) &#123; if (isLoading) &#123; return &lt;p&gt;Loading&lt;/p&gt;; &#125; return &lt;Component &#123; ...props &#125; /&gt;; &#125;;&#125; 可以看到，剩余解构也可以被用在函数的签名中。接下来，使用 JavaScript ES6 箭头函数让高阶组件变得更加简洁： 1234567const withLoading = Component =&gt; (&#123; isLoading, ...props &#125;) =&gt; &#123; if (isLoading) &#123; return &lt;p&gt;Loading&lt;/p&gt;; &#125; return &lt;Component &#123; ...props &#125; /&gt;;&#125; 通过使用三元运算符可以将函数体缩短为一行代码。因此可以省略函数体和 return 语句。 1234const withLoading = Component =&gt; (&#123; isLoading, ...props &#125;) =&gt; isLoading ? &lt;p&gt;Loading&lt;/p&gt; : &lt;Component &#123; ...props &#125; /&gt; 如你所见，高阶组件使用的是各种 JavaScript 而不是 React 相关技术：箭头函数、高阶函数、三元运算符、解构和展开运算符。","tags":[{"name":"React","slug":"React","permalink":"http://onethree.cn/tags/React/"},{"name":"Js","slug":"Js","permalink":"http://onethree.cn/tags/Js/"}]},{"title":"webpack 配置 webpack-dev-server","date":"2019-05-21T01:12:40.000Z","path":"2019/05/21/arctile_28/","text":"1.安装webpack-dev-server 1npm i webpack-dev-server 2.安装cross-env 1npm i cross-env 3.安装HTML支持文件 1npm i html-webpack-plugin 4.配置pack.json文件 123456789&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;, &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot; &#125;, 4.配置config文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133const path = require(&apos;path&apos;)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);+ const HTMLPlugin = require(&apos;html-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const isDev = process.env.NODE_ENV ==&apos;development&apos;const config= &#123; target:&apos;web&apos;, entry: path.join(__dirname, &quot;src/index.js&quot;), //输入文件 output: &#123; filename: &quot;build.js&quot;, //输出文件 path: path.join(__dirname, &apos;dist&apos;) //输出路径 &#125;, module:&#123; rules:[ &#123; test:/\\.vue$/, loader:&apos;vue-loader&apos; &#125;, &#123; test:/\\.css$/, use:[&apos;style-loader&apos;,&apos;css-loader&apos;] &#125;, &#123; test:/\\.(gif|png|jpg|jpeg|svg)$/, use:[&#123; loader:&apos;url-loader&apos;, options:&#123; limit:1024, name:&apos;[name]-[hash].[ext]&apos; &#125; &#125;] &#125;, &#123; test:/\\.styl$/, use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;stylus-loader&apos;] &#125; ] &#125;, plugins: [ // make sure to include the plugin for the magic new VueLoaderPlugin(), new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; NODE_ENV:isDev?&apos;&quot;development&quot;&apos;:&apos;&quot;production&quot;&apos;, &#125; &#125;), new HTMLPlugin(), ],&#125;if(isDev)&#123; config.devtool=&apos;#cheap-module-eval-source-map&apos;, config.devServer=&#123; port:8000, host:&apos;0.0.0.0&apos;, overlay:&#123; errors:true &#125;, // open:true //每次都打开一个网页 hot:true //只渲染一个组件 &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin(), )&#125;module.exports=config","tags":[{"name":"webpack","slug":"webpack","permalink":"http://onethree.cn/tags/webpack/"},{"name":"webpack-dev-server","slug":"webpack-dev-server","permalink":"http://onethree.cn/tags/webpack-dev-server/"}]},{"title":"web前端学习方法推荐，如何成为web前端工程师","date":"2019-04-11T06:12:40.000Z","path":"2019/04/11/arctile_23/","text":"科技公司互联网公司有很多岗位职位可以选择，有人选择成为UI设计是，有人选择成为软件开发工程师，还有人选择成为web前端工程师，无论你的选择是哪一种无疑都是很好的选择，待遇高前景好，这两点就足够吸引其他人的眼球了。 今天分享的这个案例已经上传到群文件，大家都是软件开发党，不定期分享干货（只有前端软件开发相关的），包括我自己整理的一份2018最新的前端进阶资料和高级开发教程，欢迎进阶中和进想深入前端的小伙伴。 新人想要学WEB前端技术，最为关心的是成为WEB前端工程师要多久，学习web前端路线是怎样的。如果你真想知道学web前端技术的时间是多长，那么就得了解它究竟要学什么东西。 web前端开发技术的入门门槛其实并不算高，服务器端语言的学习特点是先慢后快，而前端开发的学习曲线则是反过来的，前期学习速度很快非常容易上手。前端工程师，也叫Web前端开发工程师。他是随着web发展，细分出来的行业。 Web前端开发技术主要学习的内容有三方面：HTML、CSS和JavaScript！如果你有更高的追求，那么就需要你精通DIV+CSS布局，最好能独立完成HTML页面制作，随着经验的增长良好的前端设计感也有助于你的发展。 1.HTML甚至不是一门语言，他仅仅是简单的标记语言！它的作用是表示一个HTML标签在页面里是个什么角色。 2.CSS只是无类型的样式修饰语言。当然可以勉强算作弱类型语言。它的作用是表示一块内容以什么样的样式（字体、大小、颜色、宽高等）显示。 3.Javascript这一基础部分对于新手来讲并不难，入手还算快。它的作用是当用户触发某些行为时，会给内容和样式带来什么样的改变。 WEB前端工程师需要掌握的技术还是很多的。web前端开发是近几年新兴的职业，对一些操作规范和实践的研究目前尚都处于探索阶段。例如CSS sprite、负边距布局、栅格布局等；各种JavaScript框架层出不穷，总有那么一些新的灵感和技术不时闪现出来，为整个前端开发领域注入了巨大的活力。它要求前端开发工程师不仅要掌握基本的Web前端开发技术，网站性能优化、SEO和服务器端的基础知识，而且要学会运用各种工具进行辅助开发以及理论层面的知识，包括代码的可维护性、组件的易用性、分层语义模板和浏览器分级支持等。 首先，不管是web前端技术还是其他IT技术也好，其实都是从零基础开始的，你可以直接学习或者是通过相近经历转行。所以新人不需要因零基础而担心自己学不会。想要成为合格的WEB前端工程师，其实也不是很难的事情，主要是要选择科学的学习方式。 优秀的Web前端开发工程师应该具备快速学习能力。如果没有快速学习能力，就跟不上Web发展的步伐。不断提升自己，不断学习新技术、新模式。对于新手来说，新技术就是新技术：对于一个高手来说，新技术不过是就技术的延伸。","tags":[{"name":"web","slug":"web","permalink":"http://onethree.cn/tags/web/"},{"name":"前端","slug":"前端","permalink":"http://onethree.cn/tags/前端/"}]},{"title":"sshpass远程免密码登陆linux","date":"2019-03-21T07:12:40.000Z","path":"2019/03/21/arctile_20/","text":"背景在Linux后台中，经常会用到ssh、scp等命令。需要进行认证，手动输入密码，是交互式的过程。当将ssh、scp等命令做成自动化脚本时，可能需要非交互式的登录过程，此时可以用sshpass。 使用举例 使用-p参数指定登录密码 免密码登录 $ sshpass -p password ssh username@host 远程执行命令 $ sshpass -p password ssh username@host &lt;cmd&gt; 通过scp上传文件 $ sshpass -p password scp local_file root@host:remote_file 通过scp下载文件 $ sshpass -p password scp root@host:remote_file local_file 忽略RSA Key检查信息第一次认证时，一般会有RSA key检查的提示： The authenticity of host ’10.x.x.x (10.x.x.x)&#39; can&#39;t be established. RSA key fingerprint is a4:eb:8c:7d:2a:ef:d6:1c:a3:0c:e8:e5:00:d2:eb:60. Are you sure you want to continue connecting (yes/no)?可以使用-o StrictHostKeychecking=no选项来忽略key检查信息。如：sshpass -p &quot;$SSH_PASSWD&quot; ssh root@&quot;$host&quot; -o StrictHostKeyChecking=no &quot;$@&quot; 2&gt;/dev/null 其他方式输入密码sshpass支持从文件中导入密码或者从环境变量中导入密码，使用举例： 从文件读取密码 $&gt; echo &quot;password&quot; &gt; userpasswd $&gt; sshpass -f userpasswd ssh username@x.x.x.x 从环境变量获取密码 $&gt; export SSHPASS=&quot;password&quot; $&gt; sshpass -e ssh username@x.x.x.x","tags":[{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"},{"name":"ssh","slug":"ssh","permalink":"http://onethree.cn/tags/ssh/"}]},{"title":"一步一步教你webpack打包","date":"2019-03-04T01:42:40.000Z","path":"2019/03/04/arctile_24/","text":"webpack是一个现代Javascript应用程序的模块打包器（modulebundler）它会分析目录结构，找到js模块（包括浏览器不能直接识别的代码，typescriptsass等），打包成合适的格式供浏览器访问。下面将从核心、安装、使用等方面来讲述。 一、核心 一切皆模块： 正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。 按需加载： 传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。 二.安装 1.安装node.js（在node官网下载即可）。 2.安装webpack: npm run webpack -g（tips:可以用webpack -h来验证是否安装成功）。 三.使用 1.创建工作目录； 2.npm init（创建package.json文件）tips:npm init了之后默认会创建一个项目依赖的package.json文件 3.npm install webpack –save-devtips:npm install了之后会安装一些项目依赖的包在node_modules文件夹内。 4.创建一个静态页（index.html）及入口文件（app.js） 5.执行命令：webpack app.js bundle.js【tips】可以看到执行该命令之后，生成了一个bundle.js文件。之后再跟大家解释文件内部关联 三.添加模块 1.被引用的文件： module.exports=’’; 2.引用文件： var module = require(“./module.js”)import module from (“./module.js”) 3.新建hello.js world.js； 4.在app.js中引用这两个js； 5.浏览器预览效果： 四.扩展 每次，我们都需要指定两个文件来打包很不方便，并且每次文件有修改需要手动在重新打包也比较崩溃将webpack写入package.json来扩展命令直接用npm webpack即可运行命令 12345--watch 自动更新--progress 显示打包进度--display-modules 列出打包模块--display-reasons 列出打包原因--p 压缩混淆脚本 添加完上面的配置之后，文件一有修改便可以自动更新，并且展示进度等。 当然，这里需要指定打包的入口和输出，具体的指定规则往下看～ 五.核心概念 12341.入口(entry) :使用哪个模块来构建内部依赖图的开始2.输出(output) :在哪里输出它所创建的bundles及命名规则3.loader :可以促使webpack额外地处理非javascript文件4.插件(plugins) :执行范围更广的任务，如：打包优化和压缩等 我们可以新建webpack.config.js来制定以上概念。接下来一项一项来解释。 1entry（如下图所示，分为单入口、多入口、混合入口） 2输出 ​ ​ 【tips】这里需要注意的用__dirname需要引用node自带的path ​ ​ 【tips】filename中的[name]会对应入口中的path参数，没有默认是main。文件会被打包到pach+filename下。 ​ 因为在配置文件里面已经指定了入口文件及输出，因此，我们不需要再在命令中指定入口和出口了，可以利用四中的npm run。 webpack来实验下： ​ ​ 运行后可以看到生成了main.package.js文件，一共打包了三个文件。 ​ 【tips】特别值得注意的是，在被打包文件最开始的位置有[0],[1],[2]的标示，这是文件的id分配，这是webpack打包的核心。我们接下来看下main.package.js文件，这里打包完的文件可以通过id值来引用对应的js文件。 ​ ​ 【添加css】接下来我们给页面添加一点样式 ​ npm run webpack之后可以发现以下报错： 【tips】这个是因为webpack只能处理js文件，如果需要处理css 图片等文件需要安装对应的loader 3 loader（将程序资源文件进行转换，是nodejs的函数 ）第一步：安装loader: 1npm install style-loader css-loader —save-dev npm install less-loader —save-dev 第二步：使用loader: 1231.引用模块时添加 `require(&quot;!style-loader!css-loader!./style.css&quot;)` 2.命令行 `webpack entry.js bundle.js --module-bind ‘css=style-loader!css-loader’`3.配置文件 `module:&#123; loaders:[ &#123; test:/\\.css$/, loaders:[&apos;style-loader&apos;,&apos;css-loader&apos;] //loader: &apos;style-loader!css-loader&apos; &#125; ] &#125;` 这里推荐在配置文件修改配置，就不用在文件或者命令行中指定比较方便 常用loader 1234npm install babel-loader bable-core —save-dev npm install babel-preset —save-dev npm install html-loader —save-dev npm install file-loader —save-dev 步骤总结： 12a.安装对应loader (npm install xxx —save-dev) b.修改配置文件（module） 常见loader配置： 4常用插件 123456 webpack.BannerPlugin - banner注释 htmlWebpackPlugin - 关联文件 CommonsChunkPlugin - 按需加载 ExtractTextWebpackPlugin - 分离css这里需要特别提到的是关联文件的插件，在日常项目中我们一般会有模板。 在模板文件中，我们不需要关注css，不需要关注js，只需要写好对应的html模板。 4.1我们在配置文件中写好plugins，4.2执行打包之后，就可以在输出文件中看到对应的js等等4.3这里需要特别注意的是这个js的文件可以通过配置文件publicPath来配置。大家可以翻到最前面查看该属性。 当然了，也可以利用banner注释插件来添加注释： 六.按需加载 利用require.ensure来实现按需加载。 在打包的时候可以看到打包了两个文件 页面载入是是不会加载0.package.js的，只有按钮点击时才会实时去加载该js","tags":[{"name":"web","slug":"web","permalink":"http://onethree.cn/tags/web/"},{"name":"webpack","slug":"webpack","permalink":"http://onethree.cn/tags/webpack/"},{"name":"node.js","slug":"node-js","permalink":"http://onethree.cn/tags/node-js/"}]},{"title":"Web前端，初学Web前端应了解的一些知识","date":"2019-01-23T21:24:00.000Z","path":"2019/01/24/arctile_22/","text":"随着互联网的快速发展，技术型人才更是受到了企业的欢迎，更多的人倾向于学习软件开发技术，达到更有市场前景的职位。Web前端是一个入行门槛较低的开发技术，更是近几年热门的职业，Web前端不仅薪资高发展前景好，是很多年轻人向往的一个职业。看到这里很多小伙伴想问：现在Web前端的就业前景如何？学Web前端需要注意哪些问题？Web前端学习路线是怎样的？别急，下面Web前端小编一一为大家答疑解惑。一、2019年Web前端的前景 1、市场： 在中国Web前端的市场永远都是巨大的，但是随着信息的普及，人人都知道Web前端开发做的时间久了，工资高，所以必然会增加竞争程度。但这是好事，有竞争才有更多人才出现。Web前端的生态系统几乎涵盖了目前市面上所有的软硬件，Web前端在中国的地位20年都是霸主，几乎是万能的，你能想到的，Web前端基本都能实现。 2、需求： 目前智联，boss，拉勾网的招聘来看，Web前端的需求量还是排名第一，但是这个需求是有前提条件的，就是需要有工作经验，因为你没有工作经验，公司就会认为你没有开发项目的能力，自然不会要你，所以你在学习中，一定要培养自己的经验，什么是经验？就是多多遇到问题，然后解决问题，这就是解决，也可以成为解决问题的能力。有人说Web前端饱和了，这是绝对不可能的，只能说你现在竞争大，学习的人，质量差了而已。所以很多人说找不到工作。其实他自己啥都不会。 这只是针对一线城市而言，相对于二三线城市来说对于实际开发经验是稍微的放松的。 3、稳定： 其实想学Web前端的人完全不用担心，因为在中国Web前端一直都是第一的，需求量非常大，这么多年Web前端从未被超越，第一个问题已经说过了，Web前端是有一个庞大的生态系统，它的覆盖范围非常广，而且已经连续10几年位居开发语言的榜首，所以Web前端是相对于其他语言来说，非常稳定的，不用担心失业的问题了。 二、学Web前端需要注意哪些问题？ 学Web前端需要克服以下几点，如果能按照自己的规划的去学习成功的几率会更大。 1、惰： 其实很多人都是因为看别人工资高才有想法去学的，但是事情往往都是这样，眼红别人工资高，但是自己的实际行动是真的不强，能坚持下去的没有几个，或者自己学的本来就不好，就着急找工作。 2、 急于求成： 很多初学Web前端的小伙伴都喜欢无脑的刷视频，但是视频看过了之后自己又什么都不会，这样学了无疑就是浪费时间，没有任何作用，所以不要急于求成，学了哪些知识点就掌握哪些。多动手写代码。 3、没有时间或者压力大： 没有时间可能你还在上班或者你在干别的事情给自己找的一个借口，时间不是没有而是你有没有利用起来，现在是互联网时间，想要学习真的很容易的，可以利用自己碎片化的时间去学习，比如坐公交或者坐地铁，这样你有一大把的时间去学习，就看你能不能利用起来。压力大可能是因为你目前收入已经不满足你的消费了，所以觉得压力大，想找个薪资高的来弥补，但是想法是好的，你得去做，一步一步的去做。 4、自控力差： 自控力在学习上真的很重要，如果你觉得自己的自控力差，建议还是不要自学为好，因为你有可能付出大量的时间，也不一定会有成效，不是说自控力差的人就不能学好Web前端，是不能通过自学来进入前端行业了，可以考虑网上或者是培训班学习，这种会有人监督你，可以系统学习，能避免浪费不必要的时间。 三、Web前端学习路线有哪些？ 基础：HTML+CSS网站页面搭建，CS核心和PC端页面开发，HTML5移动端页面开发 。 核心：Web前端核心技术JavaScript，ecmasript，dom，ajax，json，正则，作用域，运动框架，核心算法，高级函数，插件封装，jQuery等。 高级：html5+高级JavaScript开发，大数据可视化，Webapp交互接口，lbs定位，微信sdk，es6标准，高级算法，数据结构，插件封装。 框架：vue、react、angular企业开发应用。 企业要求：bootstrap，swiper，iscroll，sass，ps切图，网站上线等。 以上就是Web前端小编分享的学习Web前端应了解的一些知识。希望本篇文章能够对正准备学习Web技术，从事Web前端相关工作的小伙伴们有所帮助。目前，Web前端仍处于高速发展的阶段，希望那些有意于学习Web前端开发的人员，抓住机遇不要再犹豫不决，赶快来学Web前端开发吧。","tags":[{"name":"前端","slug":"前端","permalink":"http://onethree.cn/tags/前端/"},{"name":"Web","slug":"Web","permalink":"http://onethree.cn/tags/Web/"}]},{"title":"Vim-plug：极简 Vim 插件管理器","date":"2019-01-22T04:12:24.000Z","path":"2019/01/22/arctile_19/","text":"当没有插件管理器时，Vim 用户必须手动下载 tarball 包形式的插件，并将它们解压到 ~/.vim 目录中。在少量插件的时候可以。但当他们安装更多的插件时，就会变得一团糟。所有插件文件分散在单个目录中，用户无法找到哪个文件属于哪个插件。此外，他们无法找到他们应该删除哪个文件来卸载插件。这时 Vim 插件管理器就可以派上用场。插件管理器将安装插件的文件保存在单独的目录中，因此管理所有插件变得非常容易。我们几个月前已经写了关于 Vundle 的文章。今天，我们将看到又一个名为 “Vim-plug” 的 Vim 插件管理器。Vim-plug 是一个自由、开源、速度非常快的、极简的 vim 插件管理器。它可以并行地安装或更新插件。你还可以回滚更新。它创建浅层克隆shallow clone最小化磁盘空间使用和下载时间。它支持按需加载插件以加快启动时间。其他值得注意的特性是支持分支/标签/提交、post-update 钩子、支持外部管理的插件等。 安装安装和使用起来非常容易。你只需打开终端并运行以下命令：curl -fLo ~/.vim/autoload/plug.vim --create-dirslink12345Neovim 用户可以使用以下命令安装 Vim-plug：```$ curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 用法安装插件要安装插件，你必须如下所示首先在 Vim 配置文件中声明它们。一般 Vim 的配置文件是 ~/.vimrc，Neovim 的配置文件是 ~/.config/nvim/init.vim。请记住，当你在配置文件中声明插件时，列表应该以 call plug#begin(PLUGIN_DIRECTORY) 开始，并以 plug#end() 结束。 例如，我们安装 “lightline.vim” 插件。为此，请在 ~/.vimrc 的顶部添加以下行。plug#begin('~/.vim/plugged')```1```Plug &apos;itchyny/lightline.vim&apos; plug#end()```123在 vim 配置文件中添加上面的行后，通过输入以下命令重新加载：```:source ~/.vimrc 或者，只需重新加载 Vim 编辑器。现在，打开 vim 编辑器：vim```12使用以下命令检查状态：```:PlugStatus 然后输入下面的命令，然后按回车键安装之前在配置文件中声明的插件。12345#### 更新插件要更新插件，请运行：```:PlugUpdate 更新插件后，按下 d 查看更改。或者，你可以之后输入 :PlugDiff。 审查插件有时，更新的插件可能有新的 bug 或无法正常工作。要解决这个问题，你可以简单地回滚有问题的插件。输入 :PlugDiff 命令，然后按回车键查看上次 :PlugUpdate的更改，并在每个段落上按 X 将每个插件回滚到更新前的前一个状态。 删除插件删除一个插件删除或注释掉你以前在你的 vim 配置文件中添加的 plug 命令。然后，运行 :source ~/.vimrc 或重启 Vim 编辑器。最后，运行以下命令卸载插件：1234567该命令将删除 vim 配置文件中所有未声明的插件。#### 升级 Vim-plug要升级vim-plug本身，请输入：```:PlugUpgrade 如你所见，使用 Vim-plug 管理插件并不难。它简化了插件管理。现在去找出你最喜欢的插件并使用 Vim-plug 来安装它们。","tags":[{"name":"Vim","slug":"Vim","permalink":"http://onethree.cn/tags/Vim/"},{"name":"插件","slug":"插件","permalink":"http://onethree.cn/tags/插件/"}]},{"title":"深入浅出redux知识","date":"2018-12-11T08:32:40.000Z","path":"2018/12/11/arctile_25/","text":"redux状态管理的容器。 开始使用1234567891011121314151617// 定义常量const INCREMENT = &apos;INCREMENT&apos;const DECREMENT = &apos;DECREMENT&apos;// 编写处理器函数const initState = &#123; num: 0 &#125;function reducer(state = initState, action) &#123; switch (action.type) &#123; case INCREMENT: return &#123; num: state.num + 1 &#125; case DECREMENT: return &#123; num: state.num - 1 &#125; default: return state &#125;&#125;// 创建容器const store = createStore(reducer) reducer函数需要判断动作的类型去修改状态，需要注意的是函数必须要有返回值。此函数第一个参数是 state 状态，第二个参数是 action 动作，action 参数是个对象，对象里面有一个不为 undefined 的 type 属性，就是根据这个属性去区分各种动作类型。 在组件中这样使用 123456789101112131415161718192021222324252627282930313233343536373839404142const actions = &#123; increment() &#123; return &#123; type: INCREMENT &#125; &#125;, decrement() &#123; return &#123; type: DECREMENT &#125; &#125;&#125;class Counter extends Component &#123; constructor(props) &#123; super(props); // 初始化状态 this.state = &#123; num: store.getState().num &#125; &#125; componentDidMount() &#123; // 添加订阅 this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(&#123; num: store.getState().num &#125;) &#125;) &#125; componentWillUnmount() &#123; // 取消订阅 this.unsubscribe() &#125; increment = () =&gt; &#123; store.dispatch(actions.increment()) &#125; decrement = () =&gt; &#123; store.dispatch(actions.decrement()) &#125; render() &#123; return ( &lt;div&gt; &lt;span&gt;&#123;this.state.num&#125;&lt;/span&gt; &lt;button onClick=&#123;this.increment&#125;&gt;加1&lt;/button&gt; &lt;button onClick=&#123;this.decrement&#125;&gt;减1&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 我们都知道组件中的 state 和 props 改变都会导致视图更新，每当容器里面的状态改变需要修改 state，此时就需要用到 store 中的 subscribe 订阅这个修改状态的方法，该方法的返回值是取消订阅，要修改容器中的状态要用store 中的 dispatch 表示派发动作类型，store 中的 getState 表示获取容器中的状态。 bindActionCreators为了防止自己手动调用 store.dispatch ，一般会使用redux的这个 bindActionCreators 方法来自动绑定 dispatch 方法，用法如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let actions = &#123; increment() &#123; return &#123; type: INCREMENT &#125; &#125;, decrement() &#123; return &#123; type: DECREMENT &#125; &#125;&#125;actions = bindActionCreators(actions, store.dispatch)class Counter extends Component &#123; constructor(props) &#123; super(props); // 初始化状态 this.state = &#123; num: store.getState().num &#125; &#125; componentDidMount() &#123; // 添加订阅 this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(&#123; num: store.getState().num &#125;) &#125;) &#125; componentWillUnmount() &#123; // 取消订阅 this.unsubscribe() &#125; increment = () =&gt; &#123; actions.increment() &#125; decrement = () =&gt; &#123; actions.decrement() &#125; render() &#123; return ( &lt;div&gt; &lt;span&gt;&#123;this.state.num&#125;&lt;/span&gt; &lt;button onClick=&#123;this.increment&#125;&gt;加1&lt;/button&gt; &lt;button onClick=&#123;this.decrement&#125;&gt;减1&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default Counter; react-redux这个库是连接库，用来和react和redux进行关联的，上面使用redux的时候发现一个痛点就是要订阅设置状态的方法还要取消订阅，而react-redux却可以通过props自动完成这个功能。 123456789101112131415161718192021222324import &#123;Provider&#125; from &apos;react-redux&apos;import &#123;createStore&#125; from &apos;redux&apos;const INCREMENT = &apos;INCREMENT&apos;const DECREMENT = &apos;DECREMENT&apos;const initState = &#123; num: 0 &#125;function reducer(state = initState, action) &#123; switch (action.type) &#123; case INCREMENT: return &#123; num: state.num + 1 &#125; case DECREMENT: return &#123; num: state.num - 1 &#125; default: return state &#125;&#125;const store = createStore(reducer)ReactDOM.render(( &lt;Provider store=&#123;store&#125;&gt; &lt;Counter /&gt; &lt;/Provider&gt;), document.getElementById(&apos;root&apos;)) Provider 是个高阶组件，需要传入store参数作为store属性，高阶组件包裹使用状态的组件。这样就完成了跨组件属性传递。 1234567891011121314151617181920212223242526272829import &#123;connect&#125; from &apos;react-redux&apos;const INCREMENT = &apos;INCREMENT&apos;const DECREMENT = &apos;DECREMENT&apos;let actions = &#123; increment() &#123; return &#123; type: INCREMENT &#125; &#125;, decrement() &#123; return &#123; type: DECREMENT &#125; &#125;&#125;class Counter extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;&#123;this.props.num&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; this.props.increment()&#125;&gt;加1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.props.decrement()&#125;&gt;减1&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = state =&gt; &#123; return state&#125;const mapDispatchToProps = actionsexport default connect(mapStateToProps, mapDispatchToProps)(Counter); 组件中使用connect方法关联组件和容器，这个高阶函数，需要执行两次，第一次需要传入两个参数，第一个参数是将状态映射为属性，第二个是将action映射为属性，第二次需要传入组件作为参数。 mapStateToProps该参数是个函数返回对象的形式，参数是store中的 state，可以用来筛选我们需要的属性，防止组件属性太多，难以维护 比如我们状态是这样的{ a: 1, b: 2 } 想改成这样的{ a: 1 }，使用如下 123const mapStateToProps = state =&gt; &#123; return &#123; a: state.a &#125;&#125; mapDispatchToProps这个方法将action中的方法映射为属性，参数是个函数返回对象的形式，参数是store中的 dispatch，可以用来筛选action 12345678let actions = &#123; increment() &#123; return &#123; type: INCREMENT &#125; &#125;, decrement() &#123; return &#123; type: DECREMENT &#125; &#125;&#125; 现在action中有两个方法，我们只需要一个的话就可以这么做了。 12345const mapDispatchToProps = dispatch =&gt; &#123; return &#123; increment: (...args) =&gt; dispatch(actions.increment(...args)) &#125;&#125; redux原理createStore原理现在你已经掌握了react和react-redux两个库的使用，并且知道他们的作用分别是干什么的，那么我们就看看原理，先学习redux原理，先写一个createStore方法。 12345import createStore from &apos;./createStore&apos;export &#123; createStore&#125; 回顾一下createStore是怎么使用的，使用的时候需要传入一个处理器reducer函数，根据动作类型修改状态然后返回状态，只有在调用dispatch方法修改状态的时候才会执行reducer 才能得到新状态。 1234567891011121314151617181920212223242526272829import isPlainObject from &apos;./utils/isPlainObject&apos;import ActionTypes from &apos;./utils/actionTypes&apos;function createStore(reducer, preloadedState) &#123; let currentState = preloadedState function getState() &#123; return currentState &#125; function dispatch(action) &#123; // 判断是否是纯对象 if (!isPlainObject(action)) &#123; throw new Error(&apos;类型错误&apos;) &#125; // 计算新状态 currentState = currentReducer(currentState, action) &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, getState &#125;&#125;export default createStore 在调用 dispatch 方法的时候，需要传入一个对象，并且有个 type 属性，为了保证传入的参数的正确性，调用了isPlainObject 方法，判断是否是一个对象。 1234567891011function isPlainObject (obj) &#123; if (typeof obj !== &apos;object&apos; || obj === null) &#123; return false &#125; let proto = obj while (Object.getPrototypeOf(proto) !== null) &#123; proto = Object.getPrototypeOf(proto) &#125; return Object.getPrototypeOf(obj) === proto&#125;export default isPlainObject 该方法的原理就是判断这个对象的原型和 Object.prototype 是否相等。 redux中还有订阅和取消订阅的方法，每当状态改变执行订阅的函数。发布订阅是我们再熟悉不过的原理了，我就不多说了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function createStore(reducer, preloadedState) &#123; let currentState = preloadedState let currentReducer = reducer let currentListeners = [] let nextListeners = currentListeners // 拷贝 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; function getState() &#123; return currentState &#125; function subscribe(listener) &#123; if (typeof listener !== &apos;function&apos;) &#123; throw new Error(&apos;类型错误&apos;) &#125; // 订阅 ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; function dispatch(action) &#123; // 判断是否是纯对象 if (!isPlainObject(action)) &#123; throw new Error(&apos;类型错误&apos;) &#125; // 计算新状态 currentState = currentReducer(currentState, action) // 发布 const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, getState, subscribe &#125;&#125; ensureCanMutateNextListeners 的作用是，如果是在 listeners 被调用期间发生订阅(subscribe)或者解除订阅(unsubscribe),在本次通知中并不会立即生效，而是在下次中生效。 代码里面有个值得注意的是调用了一次dispatch 方法，派发一次动作，目的是为了得到默认值，而且为了这个动作类型与众不同，防止定义的类型冲突，所以redux这么来写。 1234567const randomString = () =&gt; Math.random().toString(36).substring(7).split(&apos;&apos;).join(&apos;.&apos;)const ActionTypes = &#123; INIT: `@@redux/INIT$&#123;randomString()&#125;`&#125;export default ActionTypes bindActionCreators原理bindActionCreators 在上面已经介绍了他的作用，就是为每个方法自动绑定dispatch方法。 123456789101112131415export default function bindActionCreators(actionCreators, dispatch) &#123; function bindActionCreator(actionCreators, dispatch) &#123; return function () &#123; return dispatch(actionCreators.apply(this, arguments)) &#125; &#125; if (typeof actionCreators === &apos;function&apos;) &#123; bindActionCreator(actionCreators, dispatch) &#125; const boundActionCreator = &#123;&#125; for (const key in actionCreators) &#123; boundActionCreator[key] = bindActionCreator(actionCreators[key], dispatch) &#125; return boundActionCreator&#125;","tags":[{"name":"web","slug":"web","permalink":"http://onethree.cn/tags/web/"},{"name":"前端","slug":"前端","permalink":"http://onethree.cn/tags/前端/"},{"name":"redux","slug":"redux","permalink":"http://onethree.cn/tags/redux/"}]},{"title":"你在抖音刷段子，我在网易云看情话","date":"2018-04-18T14:12:24.000Z","path":"2018/04/18/arctile_18/","text":"网易云的评论区，从来就是个不缺故事的地方，收集了一些情话，不知道说给谁听，发出来共享一下吧。 1.@你背后有光ya： “在吗” “在啊咋了” “我发现了一个外国人和中国的区别” “什么区别？” “外国人喜欢一个人很直接说I love you” “那中国人呢？” “中国人很委婉会小心翼翼的问他在吗” 来自单曲如常-房东的猫 2.@那你有小鱼干吗： 周恩来给妻子写的信上说：“你的信太过官方，都不说想我。” 她回信说：“纸短情长，吻你万千。” 来自单曲纸短情长-烟把儿 3.@七亿仙男的梦： 不想撞南墙了 想撞先生的胸膛 来自单曲起风了-买辣椒也用券 4.@团子汐回复： 曾经我自半个诗人，见山是深情伟岸，见海是热情澎湃，见花见草信他们皆有故事，云海江潮，虫鸣鸟啼都暗藏情愫。唯独见了 你，山川沉默，海面静谧，云海不再翻涌，江潮不再澎湃，花鸟鱼虫被光与尘凝固，世界万籁俱寂，只剩下你。 @我是绘梨衣啊： 我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。 来自单曲起风了-买辣椒也用券 5.@苏弥生：这里荒芜寸草不生， 后来你来这走了一遭， 奇迹般万物生长， 这里是我的心。 ——《沙漠》 喜欢倒着读这首小诗 来自单曲「喜欢你，但害怕]-戴尔基 6.@韩先森爱鱼小妹： 现在想想，最美妙的时刻不是热恋，而是有人忽然闯进你心里的那一瞬间。仿佛拥有了新的世界，叫人相信所有的剧本都是为你我而写。 来自单曲小永远-何洁 7.@帐号已注销： 江湖太远了我不去了 我爱上了给你做饭陪你睡觉. 来自单曲123我爱你（男声版） 8.@猫姐姐-： 我北上看到的冰川是你， 我南下追寻的极光是你， 我西去流浪的经幡是你， 我东去皈依的梵经也是你。 来自单曲浮生-刘莱斯 9.@妖么嬷： “我有一个办法让你快速瘦三斤哦~” ？” “把你的心给我” 来自单曲123我爱你（男声版） 10.@Sun_小瑶： “一腔情意喂了狗，谁再回头谁是狗。 “汪.… 来自单曲一腔诗意喂了狗-花粥 11.@八月间下雨很正常：“你听什么歌呢？”“歌名太长太难说了”“那就说前几个字吧~””我喜欢你。。。” 来自单曲我喜欢你胜过削好的水果周末的零食延后的死线冰镇西瓜正中间那一口肆无忌惮的赖床和空调房里盖棉被的感觉但我就是不敢告诉你 12.@亿万少女的怀春梦： 我看过春风十里，见过夏至未至，试过秋光潋滟，爱过冬日暖阳，全都抵不过你一句我想见你。 来自单曲好想你-沈以诚 13.@愿风带走伤和痛： 老师让用两个字来形容爱情。有个同学写下“瓶邪”老师不知，问该如何解释。同学淡定回答道：“瓶字，可以拆分为并瓦，意为并肩屋檐下。邪字，牙耳，可以理解为鬓边私语。两个字合起来，意思就是，我与你，在屋檐下并肩而坐，悄悄地在耳边说着些别人不懂的秘密。“然后，整个课堂都沸腾了。 来自单曲好想你-沈以诚 14.@大概上辈子是个狐狸： 我喜欢吃草莓，草莓汁不行，草莓蛋糕不行，不是草莓不行。 我喜欢你，长得像你不行，性格像你不行，不是你不行。 来自单曲我多喜欢你，你会知道 15.@我要变成长颈鹿了： “其实有很多事情不用那么拐弯抹角。与其说我喜欢夏天，不如说我喜欢西瓜冰淇淋小短裙；与其说我喜欢大海，不如说我喜欢海水漫过脚踝；与其说我喜欢笑起来很阳光的人，不如说我喜欢你。” 来自单曲Say Hello-Rosie Thomas 16.@HalfBrokeHorse: “何为归途？” “夜鸟荒路漫漫无期。” “可否具体？” “碎言华灯喧嚣无际。” “可否再具体？” “一诗一酌不觉千里。” “仍是不解。” “与你，四处为安。” 来自单曲浮生-刘莱斯 17.@蔡小卿Yoki: 你看到了我眼里的沙丘河流，也看到了我眼里的星辰黄昏，你可曾看到我心里，嘘在那里，你一直都那里。 来自单曲嘘（Acoustic)-愚青","tags":[{"name":"情话","slug":"情话","permalink":"http://onethree.cn/tags/情话/"},{"name":"网易云","slug":"网易云","permalink":"http://onethree.cn/tags/网易云/"}]},{"title":"Linux 目录结构：/lib 分析","date":"2017-04-25T03:23:12.000Z","path":"2017/04/25/arctile_16/","text":"原文出处： Surendra Anne 我们在之前的文章中已经分析了其他重要系统目录，比如 /bin、/boot、/dev、 /etc 等。可以根据自己的兴趣进入下列链接了解更多信息。本文中，让我们来看看 /lib 目录都有些什么。 目录结构分析：/bin 文件夹 目录结构分析：/boot 文件夹 目录结构分析：/dev 文件夹 目录结构分析：/etc 文件夹 目录结构分析：/lost+found 文件夹 目录结构分析：/home 文件夹 Linux 中，/lib 文件夹是什么？/lib 文件夹是 库文件目录 ，包含了所有对系统有用的库文件。简单来说，它是应用程序、命令或进程正确执行所需要的文件。在 /bin 或 /sbin 目录中的命令的动态库文件正是在此目录中。内核模块同样也在这里。 以 pwd 命令执行为例。执行它需要调用一些库文件。让我们来探索一下 pwd 命令执行时都发生了什么。我们需要使用 strace 命令 找出调用的库文件。 示例： root@linuxnix:~# strace -e open pwdopen(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3open(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_CLOEXEC) = 3/root+++ exited with 0 +++root@linuxnix:~# 如果你注意到的话，会发现我们使用的 pwd 命令的执行需要调用两个库文件。 Linux 中 /lib 文件夹内部信息正如之前所说，这个文件夹包含了目标文件和一些库文件，如果能了解这个文件夹的一些重要子文件，想必是极好的。下面列举的内容是基于我自己的系统，对于你的来说，可能会有所不同。 root@linuxnix:/lib# find . -maxdepth 1 -type d./firmware./modprobe.d./xtables./apparmor./terminfo./plymouth./init./lsb./recovery-mode./resolvconf./crda./modules./hdparm./udev./ufw./ifupdown./systemd./modules-load.d /lib/firmware – 这个文件夹包含了一些硬件、固件Firmware代码。 硬件和固件之间有什么不同？ 为了使硬件正常运行，很多设备软件由两部分软件组成。加载到实际硬件的代码部分就是固件，用于在固件和内核之间通讯的软件被称为驱动程序。这样一来，内核就可以直接与硬件通讯，并确保硬件完成内核指派的工作。 /lib/modprobe.d – modprobe 命令的配置目录。 /lib/modules – 所有的可加载内核模块都存储在这个目录下。如果你有多个内核，你会在这个目录下看到代表美国内核的目录。 /lib/hdparm – 包含 SATA/IDE 硬盘正确运行的参数。 /lib/udev – 用户空间 /dev 是 Linux 内核设备管理器。这个文件夹包含了所有的 udev 相关的文件和文件夹，例如 rules.d 包含了 udev 规范文件。 /lib 的姊妹文件夹：/lib32 和 /lib64这两个文件夹包含了特殊结构的库文件。它们几乎和 /lib 文件夹一样，除了架构级别的差异。 Linux 其他的库文件/usr/lib – 所有软件的库都安装在这里。但是不包含系统默认库文件和内核库文件。 /usr/local/lib – 放置额外的系统文件。这些库能够用于各种应用。 /var/lib – 存储动态数据的库和文件，例如 rpm/dpkg 数据和游戏记录。","tags":[{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"}]},{"title":"如何识别人的技术能力和水平？","date":"2017-04-12T13:23:17.000Z","path":"2017/04/12/arctile_17/","text":"原文出处： ACE开发者 这个题目是比较复杂的，它包含的东西比较多，认真讨论估计能写几万字。如果是专业研究，我看能写一本书了。这里打算根据自己的学习过程和工作经验，谈一下要点问题，均属个人看法，欢迎讨论。 写这篇文章的初衷，跟前段时间跟朋友们聊招聘有关。因为技术招聘除了考察人的协作精神和工作态度，一大目标便是判断人的技术能力和实际水平。在这件事情上多做观察、思考是很有意义的。 对于考察人的技术等级，学界是有认真的研究的。参见：*德雷福斯模型解说*。 德雷福斯模型把人的技能水平，分成5级：新手、高级新手、胜任者、精通者、专家。 对不同技能等级的认定是这样的： 新手：依靠指令清单，必须按部就班。就是必须给出详细而具体的操作规则，才能工作。比如你做一道从未做过的菜，需要看菜谱的说明，第一步做什么，第二步做什么等等，直到最后烹饪结束。 高级新手：有限的情景洞察力，同等对待工作的各个方面。对全局性、体系性的东西没兴趣。这是小工的水平。比如他能跟着师傅干点活，打打下手。可以靠着反复检索搜索引擎、StackOverflow解决具体的小问题。 胜任者：能够独立解决各种各样的领域内问题。这是一般的企业招聘，比较希望招到的等级，招进来稍作适应就能干活了，省心省力。 精通者：经验丰富，可以自我纠正、自我改进。这类等级的人，思考可以指向内在，通过反省、反馈改善技能。这种在企业可以算上高手、大拿了，培养不易。 专家：依靠直觉工作，不需要解释和理由。实际你让他解释，他可能也说不出个所以然，就是直觉给出答案，然后还是对的。专家人数稀少，需要很长时间训练、实践。通常的说法是10年出专家，10000小时定律。 这个是理论上的研究，实践中比较缺乏操作性，难以迅速的判定应聘者的实际情况。不信你打开收进来的大把简历，刚毕业的学生，每个技能名词上面都是一堆堆的“精通” – 你相信么？但它可以当成一个职业技能等级判定的参照标准。 于是乎，各家企业开启了各种“笔试”、“机试”，多轮面试，并且严格要求学历以及出身院校，试图以此过滤掉不合意的应征者，留下合格的人选。它当然是可行的，但是效果一般，而且容易出错，错失有思想有水平的人。不然也不会催生出各类“推荐式”的招聘。看重学历、学校当然也有其优点：它是快速过滤的手段，毕竟能考上好学校的人智商不会太差吧。但在大数字公司的一朋友说，公司里面还有初中毕业，一直精研安全领域的人，技术能力也是十分出色。如果严苛对待背景，这些人就会错过了。因为人的生活多种多样，有各种历史的背景因素影响经历。而部分人的经历，就是跟一些人不同的，可是不妨碍他们同样可以变得优秀。招聘，实际上是建立信任关系。如果有充足的信息证明，应聘者足够优秀，这就够了。条条框框只是辅助手段，并不是目的。 任正非的洞察力一流 推荐式的招聘实际要靠谱的多，因为人很容易了解熟悉的人的水平。这是靠推荐者的信用背书。人平时沟通时说什么话，日常看什么书，关注哪些领域，琢磨过啥问题，哪些东西很熟，这个经常聊的熟人往往都知道。可是，这类招聘局限性也很大：面窄、靠机缘。靠推荐能招几个好手啊？好手往往是各家争抢的对象，窗口期有限，基本不会缺工作的。 说了一圈，还是要在技能水准判定上有更高效率的办法，招进合适的人来。 回到开头的德雷福斯模型，既然人的技能是分级的，那么对待不同的职位要求，也应该侧重不同的考察角度。如果千篇一律的走招聘流程，就容易出问题了。比如你明明要找的是“精通者”，可上来就让人一堆笔试、机试，这是不合适的。对方会十分的厌烦。体现高水平技术能力的并不在默写什么“字符串算法”那里。这反倒是刚毕业的人占便宜，因为才学过不久，印象深。不信你让工作10年的人跟计算机专业应届生比比写排序算法，真未必能赢。但是这并不重要 – 你干活不看手册不查文档吗？聪明人从不死记硬背。重要的地方在于对问题域的准确、深刻的理解，对各类技术优劣点、各种条件平衡的评判和把握。 对待初阶新人，应着重考察的是基本功是否扎实，专业成绩是否优秀。更重要的，是他对职业的热情，学习能力和研究精神。某类人要说起技术来，滔滔不绝，两眼放光，充满热情，对未知的、新生的各类概念、技术非常好奇，这种人想差都难。因为他会自我驱动，不用督促，自己就钻研前进。反之，觉得这个职业待遇高，只是想混饭吃的人，很少走得长远。这类初阶新人以毕业生、工作年限少者为多。测试考核，可以笔试查看其对基础概念的理解是否准确，知识领域的大致范围。甚至，布置一个有点挑战性的小任务，让他尝试解决，说明思路。 考察胜任、精通者的策略不一样。笔试做题没啥用，原因前面说了。这类招聘是重头戏，企业都喜欢找这样的，能干活。所以考核评估的地方也较多。我觉得可以分成几个方面去看。意识是否先进，是否会反省思考；是否善于解决问题，富有创造性；是否有比较深的积累和广阔的知识面。 业界的开发思想也是在不断变化，工具链一直在革新。聪明的人不用蛮力，而爱用工具提升效率，喜欢自动化操作解放人力。要查看人用什么开发工具链，用什么开发环境，解释下为什么？好的开发者会及时注意新出现的工具，挖掘它能解决什么问题，并尝试吸收，解决自己的需求。如果没有这个思想意识，工作效率就会打折扣了。因为你会落后行业发展水平。人善于自我反省，则会催动自我纠正，这正是精通者的特征。参考：*优秀的开发者为什么要学习研究新的编程语言？* 解决问题的能力是重头戏，也是企业招聘人的主因。人要善于解决实际问题，而且，要学会聪明的解决问题。解决问题要看思路，看手段，看是否有创造性，这是真正考验人能力的地方。好的开发者，会考虑很多可能选项，预估各种优劣，给出一个较优的方案。 遇到难题，会用各种方法尝试。经验丰富的人，常常会使用技术的组合手段来处理难题，而不是一个语言一个工具到处用。所以，要查看下过往的项目经历遇到的问题、困难，是如何解决的，思路如何。一些公司据说不招聘不会用谷歌的工程师。谷歌打不开？嘿嘿，这就是你要克服的困难啊。这你都解决不了，还做什么研发。谷歌是人类最全、最新知识的总索引，充分利用事半功倍。 考察知识的深度、广度，对重要领域的概念是否有深刻的理解和掌握，以及从各类工作经验中得到的认知。问问他看过什么书，研究过什么东西。说白了，知道的东西是否多。一些公司很喜欢用CheckList模式来考核，列一堆领域的知识点、概念，问人懂不懂，知道就是水平好，不懂就是水平差。实际情况并非如此。人的工作过程是独立的，一些事情如果没有工作机会去接触并解决，那么一些冷僻的问题就永远都碰不上。当然也就不知道。但你能说没做过就一定做不好么？ 另外，人的技能树，其实也是“犬牙交错、参差不齐”的。什么意思？技术领域非常的广阔，你真的没办法每个领域都很精通，实际上是这个做的多，懂的多，那个用的少，知道的少。这个时候，应看具体知识领域，是哪一类。它是否需要复杂的、难度较高的背景。门槛高的技术，需要的配套技能多得多，比如AI、机器学习。而一般产品应用领域则不然，了解核心概念、设计意图，看着手册、最佳实践，也就能上手了。这个暂时不会，实际无关紧要的，工作一段学的认真点就会了。但是门槛高的领域，就需要很长时间的学习了。这是本质的差别。 我曾看见某公司放出的职员技能树，包罗万象，几乎一切IT领域的知识技能都在里面了，还声称要求“全部精通”。我不知道它如何定义的“精通”，如果按德雷福斯模型的定义，能做到的那是神，不是人类。这个纯属吹牛皮，我压根就不信。如果真有这样的人，出来让我膜拜下。因为每个稍大点的领域，都足够让你钻研一辈子，因为它们也在迅速发展呀。业内流传“全栈工程师”的说法，鼓吹自己是全栈的人经常是前端工程师。而研究后端工作领域的技术高手经常鄙视这类人：真以为会点Node.js就能解决一堆后端的事务了么？我也懂一些前端，也能号称“全栈”，但在不同领域的专业性是什么水准，自己明白的很。前端要解决的事情也有很多复杂性。全栈实际是反专业化的，是人力资源稀缺时候的低成本选择。 更高一层，则是考察人本身了。人的视野够广阔么？其它领域的知识有了解吗？一些问题的解答并不在问题域本身，而是在外面的领域。所谓“功夫在诗外”。公司讲求团队协作，总要面临不同的分工合作问题。比如产品、运营的人提需求，可以换位思考吗？合作意识强么？谁也不想招个刺头进来吧？把团队的气氛和人际关系搞的一团糟，大家做事都不痛快、不顺心，又如何安心做好工作？最终只能让团队工作效率下降，甚至瓦解。 要说专家，实际上有研究者认为是需要刻意练习+充分实践才能功成。并不是每个人经过足够的工作年限，都自动成为专家。有的人工作10年，可能后面9年都在重复第一年的工作任务，毫无改进。而职业上的训练机会，又跟大环境乃至运气息息相关，并不是每个人都有机缘的。但是把个人的职业技能做到胜任乃至精通，则是完全可行的，这只需要认真和勤奋，工作态度问题。","tags":[{"name":"杂记","slug":"杂记","permalink":"http://onethree.cn/tags/杂记/"},{"name":"职场","slug":"职场","permalink":"http://onethree.cn/tags/职场/"},{"name":"技术","slug":"技术","permalink":"http://onethree.cn/tags/技术/"},{"name":"能力","slug":"能力","permalink":"http://onethree.cn/tags/能力/"}]},{"title":"使用 Git上传代码到coding.net代码仓库详解","date":"2017-03-28T06:58:22.000Z","path":"2017/03/28/arctile_15/","text":"看到网上许许多多关于Git使用的文档，要么文章过于详细，不便于新手快速上手，要么过于简洁，甚至好多是错误的······怀疑未经实践便一个个转载而来，故通过一篇博客每步的记录下使用Git上传代码到代码库（支持Git代码托管的平台比较多，而且都是免费的，此处以coding.NET为例子，速度快，功能与开源中国相似，同样一个账号最多可以创建1000个项目，也支持任务的创建等。 1.生成ssh在电脑桌面上右键，选择Git Bash Here，进入操作界面，输入ssh-keygen -t rsa -C “username@example.com”(注：此处填写的是注册coding时绑定的邮箱，第一个易错点，引号要使用汉语的引号，非英文”“)，接下来点击enter键即可(注意：Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址,如果使用非默认地址可能需要配置 .ssh/config)，之后继续输入$cat id_rsa.pub（打开id_rsa.pub文件）2.配置ssh复制其中全部内容，添加到账户“SSH 公钥”页面 中，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。 如果提示ssh格式错误，请检查自己粘贴是否符合要求，如符合要求，仍然提示ssh格式错误，打开c:/user/bigface(你自己的用户名)/.ssh文件夹（下图以程新松为例） 找到拓展名为pub的文件，以记事本方式打开它，将内容粘贴到网页中的SSH-RSA公钥内容对话框中，去掉后面的邮箱（即新松@saucxs）后点击添加按钮。 ssh应该配置成功。 3.创建本地代码库 在本地创建一个文件夹，作为你上传代码的本地仓库，接下来就要把这个仓库与coding服务器端进行配置 在这个文件夹内点击右键，选择Git Bash Here，首先要初始化本地仓库，输入”git init”命令 接下来进行远程代码库克隆（前提：自行在coding中建立一个项目，空项目即可），输入”git clone https：//xxxxxx”命令，命令中的url获取方式如图： 左下角HHTPS处即为要输入的url 将这个url粘贴到命令中，进行远程仓库的克隆，克隆时会出现输入账号密码的环节（coding注册时的账号和密码） 输入账号密码之后便可以完成克隆。 4.代码推送 克隆之后在原来的文件夹中会多出一个文件夹（即从代码库中下载的文件夹），例如 这时候，本地仓库的配置就完成了，将要上传的代码文件放入这个文件夹中，接下来要查看一下本地仓库的状态，一检查配置是否成功，进而进行代码的推送，输入命令”git status” 例如放入了一个“stringKMP.c”文件之后输入命令”git status” 输入git status命令后，会发现以红色字体打印出来的“stringKMP.c”，说明该文件存在于本地仓库，但并未推送到云端， 接下来，输入”git add 文件名”命令，可以再输入命令”git status”进行状态检查，如下 会发现出现了“new file”。 接下来， 输入”git commit -m “代码备注随便写” “命令提交 然后输入”git push origin master”命令推送到云端，origin是服务器，master是分枝。 一切结束后，输入”git status”查看本地代码状态，会用绿字显示，表示上传成功，进入coding.Net的项目主页，你会发现自己在本地推送的代码已经出现在项目中。 以上就是使用Git上传代码到coding的流程，希望对大家有所帮助。","tags":[{"name":"git","slug":"git","permalink":"http://onethree.cn/tags/git/"},{"name":"coding","slug":"coding","permalink":"http://onethree.cn/tags/coding/"}]},{"title":"纯CSS实现一个微信logo，需要几个标签？","date":"2017-03-25T05:58:22.000Z","path":"2017/03/25/arctile_14/","text":"纯CSS实现一个微信logo并不难，难的是怎样用最少的html标签实现。我一直在想怎样用一个标签就能实现，最后还是没想出来，就只好用两个标签了。 首先需要两个标签元素： 123&lt;div class=&quot;bg&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 先画个背景： 1234567.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative;&#125; 再画个大的椭圆： 123456789.inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 35px;&#125; 小的椭圆利用.inner的::before伪元素实现： 1234567891011&amp;::before &#123; content: &quot;&quot;; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 90px; border: 2px solid #08c406;&#125; 下图时现在的结果： 里面的四个圆怎么画呢？可以利用CSS3的box-shadow属性实现，一般重复性的东西都会用这个属性，因为它可以制造出无数个一模一样的东西出来。 利用.bg的::before伪元素实现这些圆： 123456789101112&amp;::before &#123; content: &quot;&quot;; position: absolute; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; top: 150px; left: 155px; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406;&#125; ::before本身会实现一个圆(一个小圆),然后利用box-shadow属性实现其它的三个圆。 来看看现在的效果： 现在就剩下两个角了，想想还有哪些东西没用上？还有两个伪元素，分别是.bg的::after和.inner的::after，刚好可以实现两个角。 这两个角其实就是平常的小三角，然后再旋转个45度，CSS实现小三角太常见了： 123456789101112131415161718192021.bg::after &#123; content: &quot;&quot;; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 182px; left: 50px; transform: rotate(45deg);&#125;.inner::after &#123; content: &quot;&quot;; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 155px; left: 200px; transform: rotate(-45deg);&#125; 最终效果： 全部css代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@mixin pos($left, $top) &#123; position: absolute; left: $left; top: $top;&#125;.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative; &amp;::before &#123; @include pos(155px, 150px); content: &quot;&quot;; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406; &#125; &amp;::after &#123; @include pos(50px, 182px); content: &quot;&quot;; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(45deg); &#125; .inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; @include pos(35px, 60px); &amp;::before &#123; @include pos(90px, 60px); content: &quot;&quot;; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; border: 2px solid #08c406; &#125; &amp;::after &#123; @include pos(200px, 155px); content: &quot;&quot;; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(-45deg); &#125; &#125;&#125; 画这个logo最难的地方应该就是实现四个小圆的时候，因为CSS3不太熟的人可能不会想到利用box-shadow去实现。","tags":[{"name":"css","slug":"css","permalink":"http://onethree.cn/tags/css/"},{"name":"logo","slug":"logo","permalink":"http://onethree.cn/tags/logo/"}]},{"title":"线条之美，玩转SVG线条动画","date":"2017-03-20T05:58:22.000Z","path":"2017/03/20/arctile_12/","text":"通常来说web前端实现动画效果主要通过下面几种方案： css动画；利用css3的样式效果可以将dom元素做出动画的效果来。 canvas动画；利用canvas提供的API，然后利用清除-渲染这样一帧一帧的做出动画效果。 svg动画；同样svg也提供了不少的API来实现动画效果，并且兼容性也不差，本文主要讲解一下如何制作svg线条动画。 来看几个效果： demodemo demo 以上这些效果都是利用SVG线条动画实现的，只用了css3和svg，没有使用一行javascript代码，这一点和canvas比起来要容易一些，下面就说明一下实现这些效果的原理。 关于SVG的基础知识，我这里就不再叙述了，大家可以直接在文档中查看相关的API，这里只说一下实现线条动画主要用到的：path （路径） 标签命令 M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Belzier curve T = smooth quadratic Belzier curveto A = elliptical Arc Z = closepath 利用path的这些命令我们可以实现我们想要的任何线条组合，以一段简单的线条为例： 效果： 呵呵，看起来很简单，但是，如何让这个线条动起来呢？这里就要明白到SVG里的path的一些主要属性： stroke：标识路径的颜色； d：标识路径命令的集合，这个属性主要决定了线条的形状。 stroke-width：标识路径的宽度，单位是px； stroke-dasharray：它是一个和数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2； stroke-dashoffset：标识的是整个路径的偏移值； 以一张图来解释stroke-dasharray和stroke-dashoffset更容易理解一些： 因此，我们之前的路径就会变成这个样子： 效果： 理解了stroke-dasharray的作用之后，下面我们就可以使用css3的animation来让这个路径动起来。 效果： 511这个值是整个路径的长度，可以用js的document.getElementById(‘path’).getTotalLength()得到 stroke-dasharray: 0, 511; 表示实线和空隙的长度分别为 0 和 511，所以一开始整个路径都是空隙，所以是空的。然后过渡到 stroke-dasharray: 511, 511; 因为整个线条的长度就是 511，而实线的长度也慢慢变成511，所以整个线条就出现了。 同样利用stroke-dashoffset也可以实现这个效果，原理就是最初线条分为511实线，和511空隙，但是由于设置了offset使线条偏移不可见了，当不断修改offset后，线条慢慢出现。 效果： 当我们掌握了上述的方法后，整个利用SVG实现线条动画的原理就已经清楚了，我们需要的就是一个SVG路径了，但是总画一些简单的线条还是不美啊，那我们如何才能得到复杂的svg路径呢？ 找UI设计师要一个。 自己利用PS和AI做一个，只需要简单的2步。 以部落LOGO为例： 1，得到部落LOGO的png图片。 2，右键图层，然后点击从选区生成工作路径，我们就可以得到： 3，文件–导出–路径到AI，将路径导出在AI里面打开。 4，在AI里面选择保存成svg格式的文件，然后用sublime打开svg文件，将path的d拷贝出来即可。 5，利用上文介绍的实现动画的方法，我们就可以轻松的得到了下面这个效果。 线条动画进阶： 可以看到上面的动画效果和文章最初显示的动画效果还是有区别的，要想实现文章最初的动画效果，需要用到SVG的 和 来实现，读者可以在网上查一下这两个标签的用法。 思路就是： 1，将原来只有一条path的路径替换成两条，并且这两条的路径是完全重合的。 2，分别设置两条路径的stroke-dasharray和stroke-dashoffset的css3的animation动画，注意两条路径的动画不能完全一样要有差值。 3，设置成功之后就可以利用animation动画触发的时机和改变程度来实现多条动画效果。 效果： 那么如何实现alloyteam的文字动画呢，其实原理也是利用了stroke-dasharray和stroke-dashoffset，这两个属性不仅可以作用在上，同样可以作用在上。 这里用了5条完全重合的路径，并且每个路径的颜色和动画效果都不一样。 效果： 开启愉快的svg线条之旅吧！","tags":[{"name":"CSS","slug":"CSS","permalink":"http://onethree.cn/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://onethree.cn/tags/JS/"}]},{"title":"编程能力与编程年龄","date":"2017-03-18T10:08:32.000Z","path":"2017/03/18/arctile_11/","text":"程序员这个职业究竟可以干多少年，在中国这片神奇的土地上，很多人都说只能干到30岁，然后就需要转型，就像《程序员技术练级攻略》这篇文章很多人回复到这种玩法会玩死人的一样。我在很多面试中，问到应聘者未来的规划都能听到好些应聘都说程序员是个青春饭。因为，大多数程序员都认为，编程这个事只能干到30岁，最多35岁吧。每每我听到这样的言论，都让我感到相当的无语，大家都希望能像《21天速成C++》那样速成，好多时候超级有想和他们争论的冲动，但后来想想算了，因为你无法帮助那些只想呆在井底思维封闭而且想走捷径速成的人。 今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。 论文首先，我们先来看一篇论文《Is Programming Knowledge Related to Age?》（PDF链接），这篇论文是两个北卡罗莱纳州立大学计算机科学系的两个人Patrick Morrison 和 Emerson Murphy-Hill 对StackOverflow.com上的用户做了相关的数据挖掘得出来的一些数据。（我们知道StackOverflow.com上的数据是公开的，任何人都可以用来分析和统计，所以这篇论文的真实性是有的） 数据采样和清洗条件如下：（数据全量是1694981用户，平均年龄30.3岁） 15-70岁之间的用户（这年龄段的用户被称做“Working age”），当然，有很多用户没有输入年龄，这些用户都被过滤了。 用户在2012年内都回答过问题。因为StackOverflow在2012年对问题和答案的质量要求得比以前高了一倍，所以更能反映程序员的真实水平。 Reputation声望在2-100K之间。（注：StackOverflow的用户Reputation是得到社会认可的，在面试和招聘中是硬通货币。比大学的学分更有价值） 上述的条件一共过滤出84,248名程序员，平均年龄：29.02岁，平均Reputaion在1073.9分。 年龄分布图下面我们来看一下他们的年龄分布图：我们可以看到程序员年纪的正态分布（高点在25岁左右，但是中点在29岁左右） 能力和年龄分布图然后，计算每个人每个月的Reputation，这样可以找到这个用户的真正的活跃时间，这样便于计算这个程序员的真实能力。（总声望 / 活跃时间），可以得到他平均每个月得来的Reputation。 我们来看看程序员的能力和年龄段的分布图：（你可能会大吃一惊） 上图中我们可以看到，程序员的能力在从25岁左右开始上升，一直到50岁后才会开始下降。所以说，程序员吃的不是青春饭。只有码农，靠蛮力，用体力而不是用脑力的程序员才是吃青春饭的人。 年纪大的人是否跟不上新技术论文的作者分析了Tag，用了最近5年内比较流行的技术Tag，然后用了一套比较严谨的算法来查看那些所谓的“老程序员”是否在新技术上跟上不了，所谓跟不上，也就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是37岁以上的程序员（就是我现在的年纪）。 得到了下表：可以看到，老程序员和年轻的程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。 结论论文的结论是： 1）程序员技术能力上升是可以到50岁或60岁的。 2）老程序员在获取新技术上的能力并不比年轻的程序员差。 我的一些感受最后，我说一说我的一些感受： 这些年来的对于外企和国内感受—— 国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。 对年轻程序员的感受——国内新一代的程序员们太浮燥了。老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员。所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。","tags":[{"name":"随记","slug":"随记","permalink":"http://onethree.cn/tags/随记/"}]},{"title":"3 个在 Linux 中永久并安全删除文件和目录的方法","date":"2017-03-12T11:02:12.000Z","path":"2017/03/12/arctile_9/","text":"在大多数情况下，我们习惯于使用 Delete 键、垃圾箱或 rm 命令从我们的计算机中删除文件，但这不是永久安全地从硬盘中（或任何存储介质）删除文件的方法。 该文件只是对用户隐藏，它驻留在硬盘上的某个地方。它有可能被数据窃贼、执法取证或其它方式来恢复。 假设文件包含密级或机密内容，例如安全系统的用户名和密码，具有必要知识和技能的攻击者可以轻松地恢复删除文件的副本并访问这些用户凭证（你可以猜测到这种情况的后果）。 在本文中，我们将解释一些命令行工具，用于永久并安全地删除 Linux 中的文件。 1、 shred – 覆盖文件来隐藏内容shred 会覆盖文件来隐藏它的内容，并且也可以选择删除它。 ‘shred -zvu -n 5 passwords.list’ 在下面的命令中，选项有： ‘-z - 用零覆盖以隐藏碎片-v - 显示操作进度-u - 在覆盖后截断并删除文件-n - 指定覆盖文件内容的次数（默认值为3）’ shred – 覆盖文件来隐藏它的内容 你可以在 shred 的帮助页中找到更多的用法选项和信息： ‘Shell’ 2、 wipe – 在 Linux 中安全删除文件wipe 命令可以安全地擦除磁盘中的文件，从而不可能恢复删除的文件或目录内容。 首先，你需要安装 wipe 工具，运行以下适当的命令： ‘$ sudo apt-get install wipe [Debian 及其衍生版]$ sudo yum install wipe [基于 RedHat 的系统]’ 下面的命令会销毁 private 目录下的所有文件。 ‘wipe -rfi private/*’ 当使用下面的标志时： ‘-r - 告诉 wipe 递归地擦除子目录-f - 启用强制删除并禁用确认查询-i - 显示擦除进度’ wipe – 在 Linux 中安全擦除文件 注意：wipe 仅可以在磁性存储上可以可靠地工作，因此对固态磁盘（内存）请使用其他方法。 阅读 wipe 手册以获取其他使用选项和说明： Shell 1 $ man wipe 3、 Linux 中的安全删除工具集secure-delete 是一个安全文件删除工具的集合，它包含用于安全删除文件的 srm（secure_deletion）工具。 首先，你需要使用以下相关命令安装它： Shell 12 $ sudo apt-get install secure-delete [Debian 及其衍生版]$ sudo yum install secure-delete [基于 RedHat 的系统] 安装完成后，你可以使用 srm 工具在 Linux 中安全地删除文件和目录。 Shell 1 $ srm -vz private/* 下面是使用的选项： Shell 12 -v – 启用 verbose 模式-z – 用0而不是随机数据来擦除最后的写入 srm – 在 Linux 中安全删除文件 阅读 srm 手册来获取更多的使用选项和信息： Shell 1 $ man srm 4、 sfill -安全免费的磁盘 / inode 空间擦除器sfill 是 secure-deletetion 工具包的一部分，是一个安全免费的磁盘和 inode 空间擦除器，它以安全的方法删除可用磁盘空间中的文件。 sfill 会检查指定分区上的可用空间，并使用来自 /dev/urandom 的随机数据填充它。 以下命令将在我的根分区上执行 sfill，使用 `-v’ 选项启用 verbose 模式： Shell 1 $ sudo sfill -v /home/aaronkilik/tmp/ 假设你创建了一个单独的分区 /home 来存储正常的系统用户主目录，你可以在该分区上指定一个目录，以便在其上应用 sfill： Shell 1 $ sudo sfill -v /home/username 你可以在 sfill 的手册上看到一些限制，你也可以看到额外的使用标志和命令： Shell 1 $ man sfill 注意：secure-deletetion 工具包中的另外两个工具（sswap 和 sdmem）与本指南的范围不直接相关，但是，为了将来的使用和传播知识的目的，我们会在下面介绍它们。 5、 sswap – 安全 swap 擦除器它是一个安全的分区擦除器，sswap 以安全的方式删除 swap 分区上存在的数据。 警告：请记住在使用 sswap 之前卸载 swap 分区！ 否则你的系统可能会崩溃！ 要找到交换分区（并检查分页和交换设备/文件是否已经使用，请使用 swapon 命令），接下来，使用swapoff 命令禁用分页和交换设备/文件（使 swap 分区不可用）。 然后在（关闭的） swap 分区上运行 sswap 命令： Shell 1234 $ cat /proc/swaps$ swapon$ sudo swapoff /dev/sda6$ sudo sswap /dev/sda6 #这个命令要花费一些时间，默认要进行 38 遍擦除 sswap – 安全 swap 擦除器 阅读 sswap 的手册来获取更多的选项和信息： Shell 1 $ man sswap 6、 sdmem – 安全内存擦除器sdmem 是一个安全的内存擦除器，其设计目的是以安全的方式删除存储器（RAM）中的数据。 它最初命名为 smem，但是因为在 Debain 系统上存在另一个包 smem – 报告每个进程和每个用户的内存消耗，开发人员决定将它重命名为 sdmem。 Shell 1 $ sudo sdmem -f -v 关于更多的使用信息，阅读 sdmen 的手册： Shell 1 $ man sdmem","tags":[{"name":"Linux","slug":"Linux","permalink":"http://onethree.cn/tags/Linux/"}]},{"title":"Git 与 Repo 入门","date":"2017-02-27T12:18:33.000Z","path":"2017/02/27/arctile_8/","text":"版本控制版本控制是什么已不用在说了，就是记录我们对文件、目录或工程等的修改历史，方便查看更改历史，备份以便恢复以前的版本，多人协作。。。 一、原始版本控制最原始的版本控制是纯手工的版本控制：修改文件，保存文件副本。有时候偷懒省事，保存副本时命名比较随意，时间长了就不知道哪个是新的，哪个是老的了，即使知道新旧，可能也不知道每个版本是什么内容，相对上一版作了什么修改了，当几个版本过去后，很可能就是下面的样子了： 二、本地版本控制手工管理比较麻烦且混乱，所以出现了本地版本控制系统，记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件。比如RCS。 三、集中版本控制但是本地版本控制系统偏向于个人使用，或者多个使用的人必须要使用相同的设备，如果需要多人协作就不好办了，于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生，比如Subversion，Perforce。 在CVCS中，所有的版本数据都保存在服务器上，一起工作的人从服务器上同步更新或上传自己的修改。 但是，所有的版本数据都存在服务器上，用户的本地设备就只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。。 而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。 四、分布式版本控制针对CVCS的以上缺点，出现了分布式版本控制系统( Distributed Version Control System,简称 DVCS )，如GIT，Mercurial。 DVCS不是复制指定版本的快照，而是把所有的版本信息仓库全部同步到本地，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，所以，只要有一个用户的设备没有问题就可以恢复所有的数据。 当然，这增加了本地存储空间的占用。 GIT必须要了解GIT的原理，才能知道每个操作的意义是什么，才能更容易地理解在什么情况下用什么操作，而不是死记命令。当然，第一步是要获得一个GIT仓库。一、获得GIT仓库有两种获得GIT仓库的方法，一是在需要用GIT管理的项目的根目录执行： git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地，而不是取某一个特定版本，所以用clone而不是checkout： git clone 二、GIT中版本的保存记录版本信息的方式主要有两种： 记录文件每个版本的快照 记录文件每个版本之间的差异 GIT采用第一种方式。像Subversion和Perforce等版本控制系统都是记录文件每个版本之间的差异，这就需要对比文件两版本之间的具体差异，但是GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和。 GIT能正常工作完全信赖于这种SHA-1校验和，当一个文件的某一个版本被记录之后会生成这个版本的一个快照，但是一样要能引用到这个快照，GIT中对快照的引用，对每个版本的记录标识全是通过SHA-1校验和来实现的。 当一个文件被改变时，它的校验和一定会被改变（理论上存在两个文件校验和相同，但机率小到可以忽略不计），GIT就以此判断文件是否被修改，及以些记录不同版本。 在工作目录的文件可以处于不同的状态，比如说新添加了一个文件，GIT发觉了这个文件，但这个文件是否要纳入GIT的版本控制还是要由我们自己决定，比如编译生成的中间文件，我们肯定不想纳入版本控制。下面就来看下文件状态。 三、GIT文件操作版本控制就是对文件的版本控制，对于Linux来说，设备，目录等全是文件，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 文件状态GIT仓库所在的目录称为工作目录，这个很好理解，我们的工程就在这里，工作时也是在这里做修改。 在工作目录中的文件被分为两种状态，一种是已跟踪状态(tracked)，另一种是未跟踪状态(untracked)。只有处于已跟踪状态的文件才被纳入GIT的版本控制。如下图： 当我们往工作目录添加一个文件的时候，这个文件默认是未跟踪状态的，我们肯定不希望编译生成的一大堆临时文件默认被跟踪还要我们每次手动将这些文件清除出去。用以下命令可以跟踪文件： git add 上图中右边3个状态都是已跟踪状态，其中的灰色箭头只表示untrackedtracked的转换而不是untrackedunmodified的转换，新添加的文件肯定算是被修改过的。那么，staged状态又是什么呢？这就要搞清楚GIT的三个工作区域：本地数据（仓库）目录，工作目录，暂存区，如下图所示： git directory就是我们的本地仓库.git目录，里面保存了所有的版本信息等内容。 working driectory，工作目录，就是我们的工作目录，其中包括未跟踪文件及已跟踪文件，而已跟踪文件都是从git directory取出来的文件的某一个版本或新跟踪的文件。 staging area，暂存区，不对应一个具体目录，其时只是git directory中的一个特殊文件。 当我们修改了一些文件后，要将其放入暂存区然后才能提交，每次提交时其实都是提交暂存区的文件到git仓库，然后清除暂存区。而checkout某一版本时，这一版本的文件就从git仓库取出来放到了我们的工作目录。 文件状态的查看那么，我们怎么知道当前工作目录的状态呢？哪些文件已被暂存？有哪些未跟踪的文件？哪些文件被修改了？所有这些只需要一个命令，git status，如下图所示: GIT在这一点做得很好，在输出每个文件状态的同时还说明了怎么操作，像上图就有怎么暂存、怎么跟踪文件、怎么取消暂存的说明。 文件暂存在上图中我们可以很清楚地看到，filea未跟踪，fileb已被暂存（changes to be committed），但是怎么还有一个fileb是modified但unstaged呢？这是因为当我们暂存一从此文件时，暂存的是那一文件当时的版本，当暂存后再次修改了这个文件后就会提示这个文件暂存后的修改是未被暂存的。 接下来我们就看怎么暂存文件，其实也很简单，从上图中可以看到GIT已经提示我们了：use “git add …” to update what will be committed，通过 git add … 就可以暂存文件，跟踪文件同样是这一个命令。在这个命令中可以使用glob模式匹配，比如”file[ab]”，也可以使用”git add .”添加当前目录下的所有文件。 取消暂存文件是 git reset HEAD … 若修改了一个文件想还原修改可用 git checkout — … 查看文件修改后的差异当我们修改过一些文件之后，我们可能想查看我们都修改了什么东西，用”git status”只能查看对哪些文件做了改动，如果要看改动了什么，可以用： git diff 比如下图： —a表示修改之前的文件，+++b表示修改后的文件，上图表示在fileb的第一行后添加了一行”bb”，原来文件的第一行扩展为了修改后的1、2行。 但是，前面我们明明用”git status”看到filesb做了一些修改后暂存了，然后又修改了fileb，理应有两次修改的，怎么只有一个？ 因为”git diff”显示的是文件修改后还没有暂存起来的内容，那如果要比较暂存区的文件与之前已经提交过的文件呢，毕竟实际提交的是暂存区的内容，可以用以下命令： /dev/null表示之前没有提交过这一个文件，这是将是第一次提交，用： git diff –staged 是等效的，但GIT的版本要大于1.6.1。 再次执行”git add”将覆盖暂存区的内容。 忽略一些文件 如果有一些部件我们不想纳入版本控制，也不想在每次”git status”时看到这些文件的提示，或者很多时候我们为了方便会使用”git add .”添加所有修改的文件，这时就会添加上一些我们不想添加的文件，怎么忽略这些文件呢？ GIT当然提供了方法，只需在主目录下建立”.gitignore”文件，此文件有如下规则： 所有以#开头的行会被忽略 可以使用glob模式匹配 匹配模式后跟反斜杠（/）表示要忽略的是目录 如果不要忽略某模式的文件在模式前加”!” 比如： # 此为注释 – 将被 Git 忽略.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 移除文件当我们要删除一个文件时，我们可能就直接用GUI删除或者直接rm [file]了，但是看图： 我们需要将文件添加到暂存区才能提交，而移除文件后是无法添加到暂存区的，那么怎么移除一个文件让GIT不再将其纳入版本控制呢？上图中GIT已经给出了说明： git rm … 执行以上命令后提交就可以了，有时我们只是想将一些文件从版本控制中剔除出去，但仍保留这些文件在工作目录中，比如我们一不小心将编译生成的中间文件纳入了版本控制，想将其从版本控制中剔除出去但在工作目录中保留这些文件（不然再次编译可要花费更多时间了），这时只需要添加”–cached”参数。 如果我们之前不是通过”git rm”删除了很多文件呢？比如说通过patch或者通过GUI，如果这些文件命名没有规则，一个一个地执行”git rm”会搞死人的，这时可以用以下命令： 移动文件和移除文件一样，移动文件不可以通过GUI直接重命令或用”mv”命令，而是要用”git mv”，不然同移除文件一样你会得到如下结果： 如果要重命名文件可以使用 git mv old_name new_name 这个命令等效于 mv old_name new_name git rm old_name git add new_name 交互式暂存使用git add -i可以开启交互式暂存，如图所示，系统会列出一个功能菜单让选择将要执行的操作。 移除所有未跟踪文件 git clean [options] 一般会加上参数-df，-d表示包含目录，-f表示强制清除。 储藏-Stashing可能会遇到这样的情况，你正在一个分支上进行一个特性的开发，或者一个Bug的修正，但是这时突然有其他的事情急需处理，这时该怎么办？不可能就在这个工作进行到一半的分支上一起处理，先把修改的Copy出去？太麻烦了。这种情况下就要用到Stashing了。假如我们现在的工作目录是这样子的 此时如果想切换分支就可以执行以下命令 $ git stashSaved working directory and index state“WIP on master: 049d078 added the index file”HEAD is now at 049d078 added the index file(To restore them type “git stash apply”) 这时你会发现你的工作目录变得很干净了，就可以随意切分支进行其他事情的处理了。 我们可能不只一次进行”git stash”，通过以下命令可以查看所有stash列表 $ git stash liststash@{0}: WIP on master: 049d078 added the index filestash@{1}: WIP on master: c264051… Revert “added file_size” 当紧急事情处理完了，需要重新回来这里进行原来的工作时，只需把Stash区域的内容取出来应用到当前工作目录就行，命令就是 git stash apply 如果不基参数就应用最新的stash，或者可以指定stash的名字，如：stash@{1}，可能通过 git stash show 显示stash的内容具体是什么，同git stash apply一样，可以选择指定stash的名字。 git stash apply之后再git stash list会发现，apply后的stash还在stash列表中，如果要将其从stash列表中删除可以用 git stash drop 丢弃这个stash，stash的命令参数都可选择指定stash名字，否则就是最新的stash。 一般情况下apply stash后应该就可以把它从stash列表删除了，先apply再drop还是比较繁琐的，使用以下一条命令就可以同时完成这两个操作 git stash pop 如果我们执行git stash时工作目录的状态是部分文件已经加入了暂存区，部分文件没有，当我们执行git stash apply之后会发现所有文件都变成了未暂存的，如果想维持原来的样子操持原来暂存的文件仍然是暂存状态，可以加上–index参数 git stash apply –index 还有这么一种情况，我们把原来的修改stash了，然后修复了其他一些东西并进行了提交，但是，这些提交的文件有些在之前已经被stash了，那么git stash apply时就很可能会遇到冲突，这种情况下就可以在stash时所以提交的基础上新建一个分支，然后再apply stash，当然，这两个步骤有一人简单的完成方法 git stash branch 四、提交与历史了解了文件的状态，我们对文件进行了必要的修改后，就要把我们所做的修改放入版本库了，这样以后我们就可以在需要的时候恢复到现在的版本，而要恢复到某一版，一般需要查看版本的历史。 提交提交很简单，直接执行”git commit”。执行git commit后会调用默认的或我们设置的编译器要我们填写提示说明，但是提交说明最好按GIT要求填写：第一行填简单说明，隔一行填写详细说明。因为第一行在一些情况下会被提取使用，比如查看简短提交历史或向别人提交补丁，所以字符数不应太多，40为好。下面看一下查看提交历史。 查看提交历史查看提交历史使用如下图的命令 如图所示，显示了作者，作者邮箱，提交说明与提交时间，”git log”可以使用放多参数，比如： 仅显示最新的1个log，用”-n”表示。 显示简单的SHA-1值与简单提交说明，oneline仅显示提交说明的第一行，所以第一行说明最好简单点方便在一行显示。 “git log –graph”以图形化的方式显示提交历史的关系，这就可以方便地查看提交历史的分支信息，当然是控制台用字符画出来的图形。 “git log”的更多参数可以查看命令帮助。 不经过暂存的提交如果我们想跳过暂存区直接提交修改的文件，可以使用”-a”参数，但要慎重，别一不小心提交了不想提交的文件 git commit -a 如果需要快捷地填写提交说明可使用”-m”参数 git commit -m ‘commit message’ 修订提交如果我们提交过后发现有个文件改错了，或者只是想修改提交说明，这时可以对相应文件做出修改，将修改过的文件通过”git add”添加到暂存区，然后执行以下命令： git commit –amend 然后修改提交说明覆盖上次提交，但只能重写最后一次提交。 重排提交通过衍合(rebase)可以修改多个提交的说明，并可以重排提交历史，拆分、合并提交，关于rebase在讲到分支时再说，这里先看一下重排提交。 假设我们的提交历史是这样的： 如果我们想重排最后两个提交的提交历史，可以借助交互式rebase命令： git rebase -i HEAD~2 或 git rebase -i 3366e1123010e7d67620ff86040a061ae76de0c8 HEAD~2表示倒数第三个提交，这条命令要指定要重排的最旧的提交的父提交，此处要重排Second commit与Third commit，所以要指定Initial commit的Commit ID。如图所示： 注释部分详细说明了每个选项的作用，如果我们想交互这两个提交，只需把开头的这两行交换下位置就OK了，交换位置后保存，然后看下提交历史： 可以看到提交历史已经变了，而且最新的两个提交的Commit ID变了，如果这些提交已经push到了远程服务器，就不要用这个命令了。 删除提交与修改提交说明如果要删除某个提交，只需要删除相应的行就可以了，而要修改某个提交的提交说明的话，只需要把相应行的pick改为reward。 合并提交-squashing合并提交也很简单，从注释中的说明看，只需要把相应的行的pick改为squash就可以把这个提交全并到它上一行的提交中。 拆分提交至于拆分提交，由于Git不可能知道你要做哪里把某一提交拆分开，把以我们就需要让Git在需要拆分的提交处停下来，由我们手动修改提交，这时要把pick改为edit，这样Git在处理到这个提交时会停下来，此时我们就可以进行相应的修改并多次提交来拆分提交。 撤销提交前面说了删除提交的方法，但是如果是多人合作的话，如果某个提交已经Push到远程仓库，是不可以用那种方法删除提交的，这时就要撤销提交 git revert 这条命令会把指定的提交的所有修改回滚，并同时生成一个新的提交。 Resetgit reset会修改HEAD到指定的状态，用法为 git reset [options] 这条命令会使HEAD提向指定的Commit，一般会用到3个参数，这3个参数会影响到工作区与暂存区中的修改： –soft: 只改变HEAD的State，不更改工作区与暂存区的内容 –mixed(默认): 撤销暂存区的修改，暂存区的修改会转移到工作区 –hard: 撤销工作区与暂存区的修改 cherry-pick当与别人和作开发时，会向别人贡献代码或者接收别人贡献的代码，有时候可能不想完全Merge别人贡献的代码，只想要其中的某一个提交，这时就可以使用cherry-pick了。就一个命令 git cherry-pick filter-branch这条命令可以修改整个历史，如从所有历史中删除某个文件相关的信息，全局性地更换电子邮件地址。 五、GIT分支分支被称之为GIT最强大的特性，因为它非常地轻量级，如果用Perforce等工具应该知道，创建分支就是克隆原目录的一个完整副本，对于大型工程来说，太费时费力了，而对于GIT来说，可以在瞬间生成一个新的分支，无论工程的规模有多大，因为GIT的分支其实就是一指针而已。在了解GIT分支之前，应该先了解GIT是如何存储数据的。 前面说过，GIT存储的不是文件各个版本的差异，而是文件的每一个版本存储一个快照对象，然后通过SHA-1索引，不只是文件，包换每个提交都是一个对象并通过SHA-1索引。无论是文本文件，二进制文件还是提交，都是GIT对象。 GIT对象每个对象(object) 包括三个部分：类型，大小和内容。大小就是指内容的大小，内容取决于对象的类型，有四种类型的对象：”blob”、”tree”、 “commit” 和”tag”。 “blob”用来存储文件数据，通常是一个文件。 “tree”有点像一个目录，它管理一些“tree”或是 “blob”（就像文件和子目录） 一个“commit”指向一个”tree”，它用来标记项目某一个特定时间点的状态。它包括一些关于时间点的元数据，如提交时间、提交说明、作者、提交者、指向上次提交（commits）的指针等等。 一个“tag”是来标记某一个提交(commit) 的方法。 比如说我们执行了以下代码进行了一次提交： $ git add README test.rb LICENSE2$ git commit -m ‘initial commit of my project’ 现在,Git 仓库中有五个对象:三个表示文件快照内容的 blob 对象;一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象;以及一个包含指向 tree 对象(根目录)的索引和其他提交信息元数据的 commit 对象。概念上来说,仓库中的各个对象保存的数据和相互关系看起来如下图： 如果进行多次提交，仓库的历史会像这样： 分支引用所谓的GIT分支，其实就是一个指向某一个Commit对象的指针，像下面这样，有两个分支，master与testing： 而我们怎么知道当前在哪一个分支呢？其实就是很简单地使用了一个名叫HEAD的指针，如上图所示。HEAD指针的值可以为一个SHA-1值或是一个引用，看以下例子： git的所有版本信息都保存了Working Directory下的.git目录，而HEAD指针就保存在.git目录下，如上图所有，目前为止已经有3个提交，通过查看HEAD的值可以看到我们当前在master分支：refs/heads/master，当我们通过git checkout取出某一特定提交后，HEAD的值就是成了我们checkout的提交的SHA-1值。 记录我们当前的位置很简单，就是能过HEAD指针，HEAD指向某一提交的SHA-1值或是某一分支的引用。 新建分支 git branch 有时需要在新建分支后直接切换到新建的分支，可以直接用checkout的-b选项 git checkout -b 删除分支 git branch -d 如果在指定的分支有一些unmerged的提交，删除分支会失败，这里可以使用-D参数强制删除分支。 git branch -D 检出分支或提交检出某一分支或某一提交是同一个命令 git checkout | 分支合并(merge)当我们新建一个分支进行开发，并提交了几次更新后，感觉是时候将这个分支的内容合回主线了，这是就可以取出主线分支，然后把分支的更新merge回来： git checkout master git merge testing 如果master分支是testing分支的直接上游，即从master延着testing分支的提交历史往前走可以直接走到testing分支的最新提交，那么系统什么也不需要做，只需要改变master分支的指针即可，这被称之为”Fast Forward”。 但是，一般情况是这样的，你取出了最新的master分支，比如说master分支最新的提交是C2（假设共3次提交C0 merge后的提交是按时间排序的，比如下图，我们在rename提交处新建分支test，在test上提交Commit from branch test，然后回到master提交commit in master after committing in branch，再将test分支merge进master，这时看提交提交历史，Commit from branch test是在commit in master…之前的，尽管在master上我们是在rename的基础上提交的commit in master…而GIT会在最后添加一个新的提交（Merge branch ‘test’）表示我们在此处将一个分支merge进来了。 这种情况会有一个问题，比如说在rename提交处某人A从你这里Copy了一个GIT仓库，然后你release了一个patch（通过git format-patch）给A，这时候test分支还没有merge进来，所以patch中只包含提交：commit in master…然后你把test分支merge了进来又给了A一个patch，这个patch会包含提交：Commit from branch test，而这个patch是以rename为base的，如果commit in master…和Commit from branch test修改了相同的文件，则第二次的patch可能会打不上去，因为以rename为base的patch可能在新的Code上找不到在哪个位置应用修改。 分支衍合(rebase)有两种方法将一个分支的改动合并进另一个分支，一个就是前面所说的分支合并，另一个就是分支衍合，这两种方式有什么区别呢？ 分支合并（merge）是将两个分支的改动合并到一起，并生成一个新的提交，提交历史是按时间排序的，即我们实际提交的顺序，通过git log –graph或一些图形化工具，可能很明显地看到分支的合并历史，如果分支比较多就很混乱，而且如果以功能点新建分支，等功能点完成后合回主线，由于merge后提交是按提交时间排序的，提交历史就比较乱，各个功能点的提交混杂在一起，还可能遇到上面提到的patch问题。 而分支衍合（rebase）是找到两个分支的共同祖先提交，将要被rebase进来的分支的提交依次在要被rebase到的分支上重演一遍，即回到两个分支的共同祖先，将branch（假如叫experiment）的每次提交的差异保存到临时文件里，然后切换到要衍合入的分支（假如是master），依次应用补丁文件。experiment上有几次提交，在master就生成几次新的提交，而且是连在一起的，这样合进主线后每个功能点的提交就都在一起，而且提交历史是线性的 对比merge与rebase的提交历史会是下图这样的（图来自Pro-GIt）： rebase后C3提交就不存在了，取而代之的是C3’，而master也成为了experiment的直接上游，只需一次Fast Forward（git merge）后master就指向了最新的提交，就可以删除experiment分支了。 衍合–onto git rebase –onto master server client 这条命令的意思是：检出server分支与client分支共同祖先之后client上的变化，然后在master上重演一遍。 父提交HEAD表示当前所在的提交，如果要查看当前提交父提交呢？git log查看提交历史，显然太麻烦了，而且输入一长串的Commit-ID也不是一个令人愉悦的事。这时可借助两个特殊的符号：~与^。 ^ 表示指定提交的父提交，这个提交可能由多个交提交，^之后跟上数字表示第几个父提交，不跟数字等同于^1。 ~n相当于n个^，比如~3=^^^，表示第一个父提交的第一个父提交的第一个父提交。 远程分支远程分支以(远程仓库名)/(分支名)命令，远程分支在本地无法移动修改，当我们clone一个远程仓库时会自动在本地生成一个名叫original的远程仓库，下载远程仓库的所有数据，并新建一个指向它的分支original/master，但这个分支我们是无法修改的，所以需要在本地重新一个分支，比如叫master，并跟踪远程分支。 Clone了远程仓库后，我们还会在本地新建其他分支，并且可能也想跟踪远程分支，这时可以用以下命令： git checkout -b [branch_name] –track|-t / 和新建分支的方法一样，只是加了一个参数–track或其缩写形式-t，可以指定本地分支的名字，如果不指定就会被命名为remote-branch。 要拉取某个远程仓库的数据，可以用git fetch: git fetch 当拉取到了远程仓库的数据后只是把数据保存到了一个远程分支中，如original/master，而这个分支的数据是无法修改的，此时我们可以把这个远程分支的数据合并到我们当前分支 git merge / 如果当前分支已经跟踪了远程分支，那么上述两个部分就可以合并为一个 git pull 当在本地修改提交后，我们可能需要把这些本地的提交推送到远程仓库，这里就可以用git push命令，由于本地可以由多个远程仓库，所以需要指定远程仓库的名字，并同时指定需要推的本地分支及需要推送到远程仓库的哪一个分支 git push : 如果本地分支与远程分支同名，命令可以更简单 git push 等价于 git push refs/heads/:refs/for/ 如果本地分支的名字为空，可以删除远程分支。 前面说过可以有不止一个远程分支f，添加远程分支的方法为 git remote add 六、标签-tag作为一个版本控制工具，针对某一时间点的某一版本打tag的功能是必不可少的，要查看tag也非常简单，查看tag使用如下命令 git tag 参数”-l”可以对tag进行过滤 git tag -l “v1.1.*” Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。 轻量级标签只需在git tag后加上tag的名字，如果tag名字 git tag &lt;tag_name&gt; 含附注的标签需要加上参数-a（annotated），同时加上-m跟上标签的说明 git tag -a &lt;tag_name&gt; -m “&lt;tag_description&gt;” 如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s（signed） 查看标签的内容用 git show &lt;tag_name&gt; 验证已签署的标签用-v（verify） git tag -v &lt;tag_name&gt; 有时在某一个版本忘记打tag了，可以在后期再补上，只需在打tag时加上commit-id 要将tag推送到远程服务器上，可以用 git push &lt;tag_name&gt; 或者可以用下面的命令推送所有的tag git push –tags 七、Git配置使用”git config”可以配置Git的环境变量，这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global选项，读写的就是这个文件。 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖/etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:Documents and Settings$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 最基础的配置是配置git的用户，用来标识作者的身份 git config –global user.name git config –global user.email 文本编辑器也可以配置，比如在git commit的时候就会调用我们设置的文本编辑器 git config –global core.editor vim 另一个常用的是diff工具，比如我们想用可视化的对比工具 git config –global merge.tool meld 要查看所有的配置，可以用 git config –list 或者可以在git config后加上配置项的名字查看具体项的配置 git config user.name 作为一个懒人，虽然checkout、status等命令只是一个单词，但是还是嫌太长了，我们还可以给命令设置别名如 git config –global alias.co checkout 这样git co就等于git checkout 前面说地，git配置项都保存在那3个文件里，可以直接打开相应的配置文件查看配置，也可以直接修改这些配置文件来配置git，想删除某一个配置，直接删除相应的行就行了 八、其他关于GIT各命令的说明可以查看相关帮助文档，通过以下方法： git help 或git –help REPO repo start &lt;topic_name&gt; 开启一个新的主题，其实就是每个Project都新建一个分支。 repo init -u [OPTIONS] 在当前目录下初始化repo，会在当前目录生生成一个.repo目录，像Git Project下的.git一样，-u指定url，可以加参数-m指定manifest文件，默认是default.xml，.repo/manifests保存manifest文件。.repo/projects下有所有的project的数据信息，repo是一系列git project的集合，每个git project下的.git目录中的refs等目录都是链接到.repo/manifests下的。 repo manifest 可以根据当前各Project的版本信息生成一个manifest文件 repo sync [PROJECT1…PROJECTN] 同步Code。 repo status 查看本地所有Project的修改，在每个修改的文件前有两个字符，第一个字符表示暂存区的状态。 – no change same in HEAD and index A added not in HEAD, in index M modified in HEAD, modified in index D deleted in HEAD, not in index R renamed not in HEAD, path changed in index C copied not in HEAD, copied from another in index T mode changed same content in HEAD and index, mode changed U unmerged conflict between HEAD and index; resolution required 每二个字符表示工作区的状态 letter meaning description – new/unknown not in index, in work tree m modified in index, in work tree, modified d deleted in index, not in work tree repo prune 删除已经merge的分支 repo abandon 删除分支，无论是否merged repo branch或repo branches 查看所有分支 repo diff 查看修改 repo upload 上传本地提交至服务器 repo forall [PROJECT_LIST]-c COMMAND 对指定的Project列表或所有Project执行命令COMMAND，加上-p参数可打印出Project的路径。 repo forall -c ‘git reset –hard HEAD;git clean -df;git rebase –abort’ 这个命令可以撤销整个工程的本地修改。","tags":[{"name":"git","slug":"git","permalink":"http://onethree.cn/tags/git/"},{"name":"repo","slug":"repo","permalink":"http://onethree.cn/tags/repo/"}]},{"title":"SVG 线条动画入门","date":"2017-02-17T13:09:22.000Z","path":"2017/02/17/arctile_7/","text":"通常我们说的 Web 动画，包含了三大类。 CSS3 动画 javascript 动画（canvas） html 动画（SVG） 个人认为 3 种动画各有优劣，实际应用中根据掌握情况作出取舍，本文讨论的是我认为 SVG 中在实际项目中非常有应用价值 SVG 线条动画。 举个栗子SVG 线条动画，在一些特定的场合下可以解决使用 CSS 无法完成的动画。尤其是在进度条方面，看看最近项目里的一个小需求，一个这种形状的进度条： 把里面的进度条单独拿出来，也就是需要实现这样一个效果： 脑洞大开一下，使用 CSS3 如何实现这样一个进度条呢。 CSS3 是可以做到的，就是很麻烦。但是如果采用 SVG 的话，迎刃而解。 我们假定你在阅读本文的时候有了一定的 SVG 基础，上面代码看看就懂了，好了，本文到此结束。 好吧，还是一步一步解释，上面进度条的主要 SVG 代码如下： ‘ ‘ SVG 为何可缩放矢量图形，即SVG，是W3C XML的分枝语言之一，用于标记可缩放的矢量图形。（摘自MDN） 上面代码中，先谈谈 svg 标签： version： 表示 的版本，目前只有 1.0，1.1 两种 xmlns：http://www.w3.org/2000/svg 固定值 xmlns:xlink：http://www.w3.org/1999/xlink 固定值 xml:space：preserve 固定值，上述三个值固定，表示命名空间，当数据单独存在svg文件内时，这3个值不能省略 class：就是我们熟悉的 class width | height： 定义 svg 画布的大小 viewbox： 定义了画布上可以显示的区域，当 viewBox 的大小和 svg 不同时，viewBox 在屏幕上的显示会缩放至 svg 同等大小（暂时可以不用理解） 有了 svg 标签，我们就可以愉快的在内部添加 SVG 图形了，上面，我在 svg 中定义了两个 polyline 标签。 ## SVG 基本形状polyline：是SVG的一个基本形状，用来创建一系列直线连接多个点。 其实，polyline 是一个比较不常用的形状，比较常用的是path，rect，circle 等。这里我使用polyline 的原因是需要使用 stroke-linejoin 和 stroke-linecap 属性，在线段连接处创建圆滑过渡角。 SVG 中定义了一些基本形状，在继续下文之前，建议点进去先了解一些基本图形的标签及写法： ## SVG 线条动画好，终于到本文的重点了。 上面，我们给两个 polyline 都设置了 class，SVG 图形的一个好处就是部分属性样式可以使用 CSS 的方式书写，更重要的是可以配合 CSS 动画一起使用。 上面，主要的 CSS 代码： ‘.g-rect-path{ fill: none; stroke-width:10; stroke:#d3dce6; stroke-linejoin:round; stroke-linecap:round;} .g-rect-fill{ fill: none; stroke-width:10; stroke:#ff7700; stroke-linejoin:round; stroke-linecap:round; stroke-dasharray: 0, 1370; stroke-dashoffset: 0; animation: lineMove 2s ease-out infinite;} @keyframes lineMove { 0%{ stroke-dasharray: 0, 1350; } 100%{ stroke-dasharray: 1350, 1350; }}’ 这尼玛是什么 CSS？怎么除了 animation 全都不认识？ 莫慌，其实很多和 CSS 对比一下非常好理解，只是换了个名字： fill：类比 css 中的 background-color，给 svg 图形填充颜色； stroke-width：类比 css 中的 border-width，给 svg 图形设定边框宽度； stroke：类比 css 中的 border-color，给 svg 图形设定边框颜色； stroke-linejoin | stroke-linecap：上文稍微提到过，设定线段连接处的样式； stroke-dasharray：值是一组数组，没数量上限，每个数字交替表示划线与间隔的宽度； stroke-dashoffset：则是虚线的偏移量 重点讲讲能够实现线条动画的关键属性 stroke-dasharray 。 属性 stroke-dasharray 可控制用来描边的点划线的图案范式。 它是一个和数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2。 解释很苍白，直接看例子： See the Pen stroke-dasharray by Chokcoco (@Chokcoco) on CodePen. 上面，填充进度条，使用了下面这个动画 ： ‘@keyframes lineMove { 0%{ stroke-dasharray: 0, 1350; } 100%{ stroke-dasharray: 1350, 1350; }}’ stroke-dasharray: 0, 1350;，表示线框短划线和缺口的长度分别为 0 和 1350，所以一开始整个图形都是被缺口占据，所以在视觉效果上长度为 0。 然后过渡到 stroke-dasharray: 1350, 1350，表示线框短划线和缺口的长度分别为 1350 和 1350，因为整个图形的长度就是 1350，所以整个进度条会被慢慢填充满。 掌握了这个技巧后，就可以使用 stroke-dasharray 和 stroke-dashoffset 制作很多不错的交互场景： SVG 线条动画实现按钮交互 SVG 线条动画实现圆形进度条多 SVG 图形线条动画配合之前我司一个 h5 里面应用过的，多SVG 图形线条动画配合，可以制作一些比较酷炫的动画，很有科技感。 正文结束，我在我的 Github 上，使用 SVG 实现了一些图形 — SVG奇思妙想，Demo可以戳这里。 下篇文章将会详述非规则图形，如何使用 PS + AI 生成 path 路径，实现 SVG 动画，放个 Demo，敬请期待。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://onethree.cn/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://onethree.cn/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://onethree.cn/tags/HTML/"}]},{"title":"为什么程序员一定要会用Google和Stack Overflow？","date":"2017-01-10T05:58:22.000Z","path":"2017/01/10/arctile_13/","text":"内容简介 前言 为什么用Google不用百度 为什么用Stack Overflow 小结 前言 下文中，谷歌统一用Google表示。 作为程序员，用Google比用百度更节省时间，此话不假。 虽说我离编程大牛还相距甚远，但是： 这些年编程的一个很深的感触就是：95%的问题都可以在Google和Stack Overflow找到答案。 真的能达到95%吗？达不到怎么办呢？ 我觉得很多时候不是Google或Stack Overflow的问题，而是不少朋友不太懂得如何快速有效地搜索到有用的信息，可以参看下面这篇知乎的帖子： 如何用好谷歌等搜索引擎？ 相比于国内的小伙伴们用Google需要“番茄”， 在国外确实相对便利，因此我平时基本不用百度，只有很难得才会用百度来查一些资料。 Stack Overflow网站的jquery需要跨域调用Google Javascript API，网站顶部总会提示”Stack Overflow requires external JavaScript from another domain, which is blocked or failed to load” ，Google”躺枪”后Stack Overflow也被拉下水了。 下面两个值得一看： Stormzhang的文章：你为什么一定要使用 Google ？ 知乎上的讨论：如何优雅地使用 Stack Overflow？ 不过， 要能在Google和Stack Overflow“畅游”， 还需要比较良好的英语， 因为很多好的资料是英语的， 很多API只有英语解释， 等等。 为什么用Google不用百度 一言不合就用Google！ 首先，百度是一个以中文信息为主要对象的搜索引擎， 因此对于因为英语信息的收录量和收录精确性就差很多。 但是作为程序员，我们如果不会英语，是会错过很多好资源与好的学习机会的，可以参看一下我这篇文章：对于程序员, 为什么英语比数学更重要? 如何学习 不过百度也是有其用途的，比如查找一些中文资源的时候。 百度比之Google还有很多劣势： 用百度，第一屏的结果往往充斥着广告。而且不少都是用金钱买来的广告位。虽然Google也有广告位，但相比百度还是有良心很多的。相信经过不少的事件，例如魏泽西，大家对百度已经诟病不少了。 百度的界面比Google难看：是的，作为“视觉生物”，要我在Google的界面和百度的界面之间选择，我会毫不犹豫选择前者。 假如不是在国内，那么Google的速度是很快的，因为世界各地有很多Google的集成服务器。 对于“android学习”，Google的搜索结果 对于“android学习”，百度的搜索结果 可以感觉出来，Google的搜索结果很清爽，而且“直击要害”；百度的结果有不少并不是我们想要的，你还需要自己甄别，很麻烦。 更可怕的是，我都开了Chrome上屏蔽广告的插件，百度的搜索结果第一页第一个竟然还是广告！ 当然了，Google也不是没有缺陷的。不过，人生短暂，我用Google。 我当年刚开始接触编程的时候，也不怎么用Google，基本都是“百度之”。但是我渐渐发现，百度的标语“百度一下，你就知道”，其实应该更正为“百度一下，也许你就更不知道了”。 最后， 假如你不信我说的，可以试用一下Google。 不过，友情提示：到时候，你爱上Google，不能自拔的，每天不用一下Google搜索就“不爽不舒服斯基”的时候，不要来找我“算账”。 为什么用Stack Overflow 如果说Google对于非程序员也很有用，那Stack Overflow就基本是极客的选择了。 什么是Stack Overflow ？ Stack是英语“栈”的意思，Overflow是英语“溢出”的意思，因此Stack Overflow的直译就是“栈溢出”。 栈溢出是缓冲区溢出的一种。由于缓冲区溢出而使得有用的存储单元被改写,往往会引发不可预料的后果。程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区。如果向缓冲区中写入超过其本身长度的数据，以致于缓冲区无法容纳，就会造成缓冲区以外的存储单元被改写，这种现象就称为缓冲区溢出。缓冲区​长度一般与用户自己定义的缓冲变量的类型有关。 老外就是喜欢取别具一格的名字～ Stack Overflow简单来说是一个IT技术问答网站。其实网站本身技术实现并不是很难，国内也有模仿者，例如https://segmentfault.com/ Stack Overflow 由 Jeff Atwood 和 Joel Spolsky 这两个非常著名的 Blogger 在 2008 年创建，7月小范围的进行 Beta 测试，直到 9 月份才开始公开的 Beta 测试。Stack Overflow 面向编程人员群体。到2010年年末，Stack Overflow 单个站点在 Alexa 的Rank 是 160 ，月度独立访客超过 1600 万，每月Page View 超过 7200 万 (refer)。Stack Exchange Network 在 2010 年 5 月接受了来自 Union Square Ventures 的 600 万美元的投资，在 2010 年扩大并完善了整个团队，从三个全职工程师发展到了 20 多人的队伍，搬进了 7500 平方英尺的豪华装修的办公室（当然每个人都坐着1000美元一把的椅子）。之后，发展就算比较顺利。 但是，Stack Overflow之所以成功，因为： 整个圈子氛围不错 问答基数大 回复及时 大牛很多 基于英语 问题审核严格 基本你想得到的编程知识点在上面都有相关问题 可以看一下知乎的这篇帖子：国内为什么没有好的 Stack Overflow 的模仿者？ 这些年，很多编程难题，我都是先Google，然后Google会很优先地把结果导向到Stack Overflow，我在Stack Overflow可以很容易找到解决我的问题的答案。有些问题甚至很偏门，但是Stack Overflow还是有解决办法，简直神器！ 小结 至于Google和Stack Overflow的组合对于程序员的助力有多大，那你必须使用了才能体会到啊。如果需要“番茄”，那还是去买付费的VPN比较好，毕竟“便宜没好货”。 像我这么“耿直”的人，怎么会坑您呢？对吧～ – 转载至简书作者 谢恩铭","tags":[{"name":"google","slug":"google","permalink":"http://onethree.cn/tags/google/"},{"name":"stack overflow","slug":"stack-overflow","permalink":"http://onethree.cn/tags/stack-overflow/"}]},{"title":"Vim 起步的五个技巧","date":"2017-01-02T05:02:22.000Z","path":"2017/01/02/arctile_5/","text":"​ 多年来，我一直想学 Vim。如今 Vim 是我最喜欢的 Linux 文本编辑器，也是开发者和系统管理者最喜爱的开源工具。我说的学习，指的是真正意义上的学习。想要精通确实很难，所以我只想要达到熟练的水平。我使用了这么多年的 Linux ，我会的也仅仅只是打开一个文件，使用上下左右箭头按键来移动光标，切换到插入模式，更改一些文本，保存，然后退出。 但那只是 Vim 的最最基本的操作。我的技能水平只能让我在终端使用 Vim 修改文本，但是它并没有任何一个我想象中强大的文本处理功能。这样我完全无法用 Vim 发挥出胜出 Pico 和 Nano 的能力。 所以到底为什么要学习 Vim？因为我花费了相当多的时间用于编辑文本，而且我知道还有很大的效率提升空间。为什么不选择 Emacs，或者是更为现代化的编辑器例如 Atom？因为 Vim 适合我，至少我有一丁点的使用经验。而且，很重要的一点就是，在我需要处理的系统上很少碰见没有装 Vim 或者它的弱化版（Vi）。如果你有强烈的欲望想学习对你来说更给力的 Emacs，我希望这些对于 Emacs 同类编辑器的建议能对你有所帮助。 花了几周的时间专注提高我的 Vim 使用技巧之后，我想分享的第一个建议就是必须使用它。虽然这看起来就是明知故问的回答，但事实上它比我所预想的计划要困难一些。我的大多数工作是在网页浏览器上进行的，而且每次我需要在浏览器之外打开并编辑一段文本时，就需要避免下意识地打开 Gedit。Gedit 已经放在了我的快速启动栏中，所以第一步就是移除这个快捷方式，然后替换成 Vim 的。 为了更好的学习 Vim，我尝试了很多。如果你也正想学习，以下列举了一些作为推荐。 Vimtutor通常如何开始学习最好就是使用应用本身。我找到一个小的应用叫 Vimtutor，当你在学习编辑一个文本时它能辅导你一些基础知识，它向我展示了很多我这些年都忽视的基础命令。Vimtutor 一般在有 Vim 的地方都能找到它，如果你的系统上没有 Vimtutor，Vimtutor 可以很容易从你的包管理器上安装。 GVim我知道并不是每个人都认同这个，但就是它让我从使用终端中的 Vim 转战到使用 GVim 来满足我基本编辑需求。反对者表示 GVim 鼓励使用鼠标，而 Vim 主要是为键盘党设计的。但是我能通过 GVim 的下拉菜单快速找到想找的指令，并且 GVim 可以提醒我正确的指令然后通过敲键盘执行它。努力学习一个新的编辑器然后陷入无法解决的困境，这种感觉并不好受。每隔几分钟读一下 man 出来的文字或者使用搜索引擎来提醒你该用的按键序列也并不是最好的学习新事物的方法。 键盘表当我转战 GVim，我发现有一个键盘的“速查表”来提醒我最基础的按键很是便利。网上有很多这种可用的表，你可以下载、打印，然后贴在你身边的某一处地方。但是为了我的笔记本键盘，我选择买一沓便签纸。这些便签纸在美国不到 10 美元，当我使用键盘编辑文本，尝试新的命令的时候，可以随时提醒我。 Vimium上文提到，我工作都在浏览器上进行。其中一条我觉得很有帮助的建议就是，使用 Vimium 来用增强使用 Vim 的体验。Vimium 是 Chrome 浏览器上的一个开源插件，能用 Vim 的指令快捷操作 Chrome。我发现我只用了几次使用快捷键切换上下文，就好像比之前更熟悉这些快捷键了。同样的扩展 Firefox 上也有，例如 Vimerator。 其它人毫无疑问，最好的学习方法就是求助于在你之前探索过的人，让他给你建议、反馈和解决方法。 如果你住在一个大城市，那么附近可能会有一个 Vim meetup 小组，或者还有 Freenode IRC 上的 #vim 频道。#vim 频道是 Freenode 上最活跃的频道之一，那上面可以针对你个人的问题来提供帮助。听上面的人发发牢骚或者看看别人尝试解决自己没有遇到过的问题，仅仅是这样我都觉得很有趣。 那么，现在怎么样了？到现在为止还不错。为它所花的时间是否值得就在于之后它为你节省了多少时间。但是当我发现一个新的按键序列可以来跳过词，或者一些相似的小技巧，我经常会收获意外的惊喜与快乐。每天我至少可以看见，一点点的回报，正在逐渐配得上当初的付出。 学习 Vim 并不仅仅只有这些建议，还有很多。我很喜欢指引别人去 Vim Advantures，它是一种使用 Vim 按键方式进行移动的在线游戏。而在另外一天我在 Vimgifts.com 发现了一个非常神奇的虚拟学习工具，那可能就是你真正想要的：用一个小小的 gif 动图来描述 Vim 操作。 你有花时间学习 Vim 吗？或者是任何需要大量键盘操作的程序？那些经过你努力后掌握的工具，你认为这些努力值得吗？效率的提高有没有达到你的预期？分享你们的故事在下面的评论区吧。","tags":[{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"编辑器之战:Vim 的复仇","date":"2016-12-22T08:03:22.000Z","path":"2016/12/22/arctile_4/","text":"​ 我极少在这些网页上读到如此无聊的报道！Al Williams的一篇关于“Emacs 和Vim之战”的报道，并不合我们Hackaday的口味。本着“不偏不倚”的精神，他用七句话概率了Vim编辑器。仅仅七句！我顿时怒气冲天。 正如你们大多数人一样，Al认为他“懂得如果使用vi”。实话告诉你，其实他并不懂。除非你独自在只有食物、饮料、笔记本 和VimGolf在喜马拉雅山脉的一个高高的洞穴里生活几年，否则你不会懂如何使用vi。我并不自认为精通Vim，但我仍将用Vim撰文真情吐露我对它的溢美之词。 我写本文并不是为了延续“vi和Emacs之战”。那种想法很愚蠢。而且极有可能是Emacs用户们编造出来用来抢vi的风头的。你懂得，“vi和Emacs之战”话题的讨论是为了转移读者注意力。Vi和vim以及你用的其他编辑器有如此大的差异和不同，以至于拿Emacs来作无聊的对比：它仅仅是一个具备良好拓展性能的普通编辑器，可怕的组合键也都可能导致腕管综合征，代码膨胀可以比肩Microsoft Word。如果你能熟练使用Pico 、Nano 、 Joe、 Notepad++ 、 Gedit 、 Kate中的任一款或者任何其它的编辑器。你在一个月左右的时间就可以熟练使用Emacs，它无非是另外一款编辑器。 Vi却与此不同。它是一个伪装成编辑器的用来编辑文本的一种编程语言。如果你像普通文本编辑器那样用它，你会觉得很遭罪。但是如果你能将繁杂的文本编辑像封装代码到方法中时，你才真正开始理解Vi. 模式和移动 正如Al所指出的那样，vi和Vim都使用了模式的概念。键入文本时有一种“插入模式”，在普通编辑器里，这种模式是默认开启的。用我们使用Vim编辑时，大多数时间是在“普通模式”(按键像命令一样)，如移动鼠标、剪切、粘贴、查找、替换、编写宏命令、将一个html标签转换成另外一个以及普通编辑。 当你开始用Vim时，它会提醒你键入:help 以及给你展示教程，教你怎样通过鼠标进行操作。你应该按照按照它的提示进行操作，那就是它存在的意义。它不会让你精通它但是你将能够学到基本的使用方法。在这时，不要到处宣扬你“懂如何用Vim”。那会使你看起来很傻。你将学会如何通过鼠标进行操作、剪切、粘贴、输入和编辑文本。简而言之，你将像Emacs一样编辑： 一个猴子 。 文本编辑编程Vim的神秘之处在于它普通模式时使用一种介于自然语言和编程语言中间的语言。 它包含动词（方法）、形容词（修饰语）、和名词（对象）。输入c命令代表“编辑”某些文本。但是仅仅输入一个c不起作用，因为它还需要一个对象。但如果你输入caw（“修改一个单词”），光标所选中的单词将被删除，Vim进入插入模式，等待你键入单词的替换词，通过按Esc键（退出键）就可以返回普通模式。如果你想编辑整句，输入cas来删除它然后然后输入新句子即可。想改变C函数括号内的所有参数吗？ci)“改变括号内的内容”. (ca)删除整体，括号和所有。数字也同样适用。通过c**5w**命令可以修改后面的5个单词。就Vim的语法是模块化且可拓展的角度而言，它还是挺容易学的。 以上那些只是雕虫小技。.命令才是亮点。编辑动作的阶段性重复构成了一个单元。所以如果你仅仅想把一个单词改为“Hackaday”后返回到普通模式，就把光标移动到那个单词上键入cawHackaday后再按.键就可将其修改为“Hackaday”。将移动命令也加入其中，w命令将光标移动到下一个单词的开头。现在如果交换.和w那么文档中所有单词都会变成“Hackaday”。只需要按两个键。试想一下如果杰克·尼克尔逊在《闪灵》中用Vim和.命令写作，那该多高效啊。 虽然听起来好像不是特别实用，但是想想有多少次你需要把所有“foo()”方法替换为“getFooInstantanceMethod()”方法就不难理解了。 当然了在Vim中那只是很“普通”的搜索和替换方法，但是其实大多数情况下你没必要那样做。为啥呢？因为/foo搜索“foo”而且caw将修改光标选中的单词。 通过;可以实现搜索的可重复性。在搜索和替换部分（几乎）同时是任意编辑动作的情况下，交替使用; 和.与搜索和替换是等价的。 不需要输入“y”和“n”来对每个匹配的单词进行修改确认，你只需要找到需要的地方输入.即可。 关于vim的讨论非常热闹，以至于在 StackOverflow上，它已经成为一个经典的热门话题，在另一方面，文本编辑经常视为一贯重复性行为。Vim却将这些动作作为单一的单元，使得复现和将它们链接在一起非常容易。如果你是一个程序员，这很像编程里的活动 — 将整个任务拆分成多个方法并运行。如果你理解编程，你就更容易理解Vim。 可视模式和命令模式在你通往精通Vim的路上，你会接触到更多模式。可视模式下你可以先选择文本的区域然后再使用命令来操作它。偶尔用用挺好的，因为可视模式下选择区域很难转换成普通方法，所以不要像我学习的时候那样用的那么频繁。然而有很多针对可视模式有用的插件。 命令模式是Vim的主要模式。它本质上像ed这种原始的行编辑器。:17,25d在不移动鼠标情况下删除17到25行。:-3t.复制当行的前面三行。:v/foobar/s/thang/thing/g 将不含有“foobar”的文档里所有“thang”替换为 “foobar”。在这里你也可以使用所有存储的正则表达式。 另外，如全局搜索、替换、删除或者复制整行文字这样的简单的操作在命令行下非常容易。%s/one/two/gc把所有的“one”替换成 “two”，每个搜索和替换需要用户确认。(%代表整篇文章。这里你也可以使用行数范围。当然:e命令功能是打开一个文件编辑， :wq 的功能是保存当前文件并退出。你不需要记住太多的命令行模式的命令，但是有些命令超实用。 寄存器和宏接下来将介绍寄存器。像编程语言的变量那样，Vim 在寄存器中存储文本（或命令）。你可以从寄存器剪切或者粘贴数据，前十个主要是一个剪切缓冲区。寄存器是存储你剪切但不确定是否扔掉的文本的好地方。“zdi} 将删除所有方法括号内的所有代码，保存在“z”寄存器中。你可以在任何时候通过“zp将其粘贴回来。 你也可以像宏一样记录和回放寄存器中的Vim的命令序列。毕竟Vim命令大多数情况下都仅仅是文字。q用来开始和停止宏的录制，qw将一个宏录制到“w”寄存器中。 在此之后你可以用@w来重复运行。宏像其编写者那样强大。我只用一些宏，但是只要我用过的都会频繁使用。 例如，有一个宏我一天用无数次。我用Markdown写Hackaday文章然后将其编译成HTML语言发表。在Markdown中超链接的用法类似这样：link text。 S]f]a(“+pa)用“[]”将当前选中的文本括在里面。添加一个左圆括号，退出插入模式，粘贴粘贴板中的内容，添加一个右圆括号，返回到普通模式。但是现在，我复制浏览器中一个超链接，选择文本然后在Vim中键入@l 这样获得了链接到该网址的Markdown超链接。 插件想其他任何的编辑器一样，Vim也拥有难以置信的可拓展性。如果有任何不能制作成宏的特性，用户通常都可以为此编写插件。依我看来，Vimscript 没Lisp那样好编写，所以我就把拓展的编写留个其他用户吧。有人已经写了一个几乎你所需的所有模块。但是在刚开始的时候不要过度使用插件。即使你是刚学习Vim，它也会使你的工作量减轻很多。 如果你经不住诱惑安装了一些插件，我建议你一次只装一个，直到能给非常熟练的使用后再安装另外的插件。我建议依次安装和学习如下插件：vim-sensible, vim-airline, vim-abolish, ctrlp.vim, UltiSnips, vim-surround, vim-easy-align。 VIM最佳命令如果你在用Vim，但是没充分使用如下的命令，说明你还没用好它。 l I和 A 分别插入文本到行首或尾部。 l m设置标记然后通过“`就可以跳回到此标记位置。 这对轻松在长篇文章中跳转非常有效。 l g; 跳转到上次编辑位置。就是说“在去其他地方之前，先返回之前编辑的地方”。这非常有用。但这还不是全部–它追踪编辑历史以便可以复现前5此编辑。g,返回前一个编辑历史。 l CTRL-] 跳转到鼠标所在函数的定义位置，CTRL-t跳回。CTRL-t可以使你会一直返回，直到返回到开始位置。(为了使其生效你需要一个标签文件。) 这几乎达到像eclipse这种IDE价值的一半，却没他们那样造成屏幕凌乱。 l 一个IDE的另外一半是长变量或者方法名的tab完成功能。在Vim中用CTRL-n和 CTRL-p 来预选列表中上滚和下滚。如果你使用的是标签文件或者如果你在Vim中其他文件定义了标签，它将对变量名和方法名自动完成。 l gg=G跳转到文档顶部(gg) 自动缩进(=) 直到到达文档末尾 (G)。这使得你打开和关闭的大括号排成一行，很容易找到你忘记配对的大括号。 l U撤销最后一个命令。CTRL-r重做。:earlier 2m 恢复到两分钟前的状态。如果你不再进行撤销，继续编辑然后想重做之前的一些改动，就可以考虑用这个命令。g+ 和g- 则在恢复树种上下切换。它变得更加复杂。 l /和f 都是搜索命令，这两个命令在符合命令中起着至关重要的作用。d**f**,从当前光标位置上的字符一直删除到遇到逗号（包括逗号)。d/foo 一直删除直到第一次匹配“foo”的位置。如果你喜欢，你可以用这来代替其他动作。 l :r 读取一个文件。:!在shell中运行命令。:r! 粘贴命令的结果输出到文档中。:r!ls whatever*比输入文件名更快。在此我并不打算介绍UNIXy中怎样通过shell脚本运行文本。 无处不在的VI一旦你习惯于Vim的移动命令，你会乐在其中。当然了你也可以直接使用鼠标，但如果你能熟练使用Vim移动命令，你将很少用鼠标了。手一直在键盘上比时不时腾出手来操作鼠标操作要会更快很多。铁杆Vim用户会重新映射Escape 键（返回到普通模式）到其他更加方便的功能。我设置的是 Caps Lock键，在我左手小手指下面。 (我其实是通过xcapse插件映射它和Control键复合键使用。) 是的，这确实有点极端，但是比 现在已经不存在的避免Emacs导致腕管综合征的键盘设计 强多了。 如果你在Unix使用Bash shell，set -o vi 这种用法来读取行的方法几乎和vi一样。你的浏览器也可以Vim化，火狐浏览器、cVim或vimium中有Vimperator 和Pentadactyl 插件。谷歌浏览器中有ViChrome插件 。如果你想合二为一，qutebrowser是目前最好的原生Vim风格网页浏览器，而且还将会更加完善。 你若搜索 “vi keybindings”你会发现它不仅支持Visual Studio、Eclipse 还支持Emacs。 为什么Emacs里有Vi模拟模式，但Vim中却没Emacs的模拟模式呢？ 稍加思索你就会明白，编辑器之战已经有了结果。 想用惯Vim需要花费一些时日。程序员想要擅长Vim，需要要摆正心态勤加练习。从1994到20011年间我用Emacs写代码、写我的学位论文、我所代课的学生的论文和学术论文。从2011年起我就开始用Vim来编写更多代码、写书、写邮件和我在Hackaday上的文章。 我仍然在不断提高，五六年间每天使用Vim 6到8小时，每月将自己总结的技巧写在指令表中。虽然Vim像任何值其他值得深入探索的东西一样，用起来有点难，但是却非常值得。不要轻信任何人告诉你他们“懂”Vim。:wq. 资源There’s really too much to say about Vim. Here’s a short list of great resources: 关于Vim要说的实在是太多了，这里提供一些相关极有价值的参考资源： 如果你刚开始用输入 :help tutor Vim FAQ Vim Tips Wiki One of many good tutorials on the web Some cheat-sheets: (One, Two, Three, and Four) A video to push intermediate Vimmers over the edge Posted in Hackaday Columns, news, slider","tags":[{"name":"css","slug":"css","permalink":"http://onethree.cn/tags/css/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"如何将Vim打造成一个成熟的IDE","date":"2016-11-24T11:18:29.000Z","path":"2016/11/24/arctile_2/","text":"​ 如果你稍微写过一点代码，就能知道“集成开发环境”（IDE）是多么的便利。不管是Java、C还是Python，当IDE会帮你检查语法、后台编 译，或者自动导入你需要的库时，写代码就变得容易许多。另外，如果你工作在Linux上，你也会知道Vim在进行文本编辑的时候是多么的方便。所以，你可 能会想从Vim中也获取这些IDE特性。 事实上，很少有方法可以帮你做到。有些人可能会想到试着把Vim打造成C语言IDE的，比如c.vim；也有把Vim集成到Eclipse里的 Eclim 。但是我想要告诉你的是一个更加通用的，只用插件实现的方案。你肯定不想因为安装了太多的面板和特性而让你的编辑器变得臃肿不堪。只用插件实现的方案可以 让你只选择那些你想要集成到Vim的特性。这样做的额外的一个好处是，这个IDE不是专门针对某一种语言的，可以让你写任何类型的代码。下面就来看一下我 的 把IDE特性带进Vim的前10款插件 吧。 先来个福利： Pathogen首先，可能不是所有人都熟悉Vim的插件，并知道该怎么安装这些插件。所以，我推荐的第一个插件就是Pathogen，因为这个插件会让你更容易安装其他插件。如果你要安装另外的没有在这里列出来的插件，用Pathogen会变得非常简单。它的官方页面的文档写的非常好，去下载安装一个吧。接下来插件的安装也会变得容易很多。 1. SuperTab 我们习惯于IDE的第一个原因就是它的自动补全功能。所以，我喜欢这个非常方便的，给了Tab键“超能力”的 SuperTab 插件。 2. Syntastic 如果你需要使用一种以上的语言进行编程，有时候是非常容易混淆不同语言之间的语法的。幸运的是，syntastic 会帮你检查，然后告诉你是否应该加上圆括号或者方括号，或者告诉你在某个地方，你忘了一个分号。 3. Auto Pairs另外一件让程序员们抓狂的事是：我是不是少加了最后一个括号？！每个人都讨厌用手指去数那些隔的非常远的括号。为了处理这个问题，我用 Auto Pairs 插件，这个插件会自动插入和格式化方括号和圆括号。 4. NERD Commenter如果你在找一个可以支持多种程序语言的注释代码的快捷键，你可以试试 NERD Commenter。即使你不是程序员，我也非常非常推荐这款插件，因为它会让你在注释bash脚本或者其他任何东西的时候都会变得非常高效。 5. Snipmate任何一个程序员都知道，好的码农写代码，杰出的码神重用代码。snipmate可以容易的插入代码片段到你的文件里面，大大的减少了你敲键盘的次数。它默认的包含了很多各种语言的代码片段，你也可以非常容易的添加你自己的。 6. NERDTree 管理一个大的项目时，把代码分散到不同的文件里面是非常好的主意。也是一个基本的编码原则。NERDTree 是一个不错的可以直接在Vim里使用的文件浏览器，它可以让你随时想到所有的文件。 7. MiniBufferExplorer 为了打造一个文件浏览器，支持同时打开多个文件，没有什么比一个好的缓冲区管理器更重要了。MiniBufferExplorer 就可以非常漂亮和高效地完成这个工作。它甚至为你的缓冲区设置了不同的颜色和切换快捷键。 8. Tag List 当你同时有多个文件打开时，很容易忘了你都在这些文件里添加了什么。为了防止你忘记，Tag List 这个代码查看器将会用一种漂亮简洁的格式展示其中的的变量和函数。 9. undotree 对于我们之中那些喜欢undo，redo然后又undo某些更改，然后依据这些来查看整个编辑完成过程的人来说， undotree 是一个不错插件，可以以一棵树的形式看到你的undo和redo历史。这个功能跟代码完全没有关系，所以这是我非常喜欢的一个插件。 10. gdbmgr最后，但并非不重要，每个人都在某个时刻需要一个调试器。如果你喜欢gdb，那么gbdmgr就是为你准备的，因为它集成了那个著名的调试器到Vim中。 总结一下，不管你是不是一个疯狂的coder，能有一些额外的Vim功能在手总是非常方便的。像我在简介里说到的，如果你不需要，你不用安装这里所有的这些插件。或者你想要安装另外的也行，这些其实只是一个基础入门级的插件。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://onethree.cn/tags/IDE/"},{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"七个高效的文本编辑习惯（以Vim为例）","date":"2016-11-18T11:02:22.000Z","path":"2016/11/18/arctile_3/","text":"​ 如果你花很多时间输入纯文本、写程序或HTML，那么通过高效地使用一个好的编辑器，你可以节省大部分时间。本文将提供指导和提示，让你更迅速地做这些工作，并且少犯错误。 本文用开源文本编辑器Vim（Vi IMproved）来演示如何高效编辑，本文方法同样适用于其他的编辑器。选择合适的编辑器，实际上是进行高效编辑的第一步。我们避免去讨论哪个编辑器最适合你，因为这个话题将占用太多篇幅。如果你不知道选用那个编辑器，或者你对目前使用的编辑器不满意，那就试试Vim；你将不会失望。 第1部分：编辑一个文件1.**快速移动**大部分时间都花在阅读、检查错误和寻找正确的位置去工作，而不是插入新的文本或修改它。在文本内导航非常频繁，因此你应该学会如何迅速做到这一点。 很多时候，当你希望搜索一些已存在的文本，或在所有行里寻找某个用到的单词或短语时，你可以简单地使用搜索命令、模式去找到它。但是也有更智能的方法： 如果你看到一个特定的单词，并想搜索它出现的其他地方，就使用命令*。它会从光标下面定位找到这个单词，并且搜索下一个。 如果设置了“incsearch”选项，当你还在输入时，Vim将会显示第一个匹配模式的文本。这能迅速显示一个模式错误。 如果设置了“hlsearch”选项，Vim将用黄色背景高亮显示所有匹配的模式，让你对搜索命令的结果有个快速概览。它可以显示一个变量在程序代码哪个位置被使用。你甚至不需要移动光标去看匹配的文本。 在结构化的文本中还有更多可能性快速移动。Vim有针对C（以及类似语言，如C++和Java）程序的特定命令： 使用%从一个左括号跳转到与其配对的右括号，或从一个“#if”到配对的“#endif”。实际上%可以跳转到许多不同的匹配项目。它对检查if()和{}的结构完整性非常有用。 使用 [{ 跳回当前代码块起始的“{”。 使用 gd 从变量的调用跳转到它的局部声明。 当然还有更多的，重点是你需要知道这些命令。你也许认为不可能了解所有这些命令——有几百种不同的移动命令，有些简单，有些非常灵活——需要花费几个星期的训练去学会它们。然而，你不需要这样做。相反，你需要知道自己具体的编辑方式，并且只学习那些能让你的编辑更高效的命令。 三个基本步骤： 当你正在编辑时，留意那些重复的和（或者）花费相当多时间的动作。 寻找一个能更快完成这个动作的编辑器命令。你可以阅读文档，询问朋友，或者看看别人是怎么做的。 练习使用这个命令，直到无需思考你的手指就能输入。 让我们用例子来说明这是如何工作的： 你会发现，当编辑C程序文件时，你经常花时间寻找一个函数被定义的地方。目前你使用 * 命令去搜寻该函数名字出现的其他位置，但是最终会遍历许多函数被使用的匹配，而不是被定义的。你会想到必须得有一个更快的方法。 查阅快速参考，你会找到关于跳转到标签的注释。文档说明如何使用它去跳转到一个你在查找的函数定义。 你试验一下使用包含Vim的ctags程序去生成一个标签文件。学会使用 CTRL-] 命令后，你会发现节省了大量的时间。更容易的办法是在你的Makefile里添加几行，从而自动生成标签文件。 使用这三个步骤时需要注意的一些事： “我想把工作做好，我没有时间去翻阅文档寻找一些新命令。”如果你这样想，你将会停留在计算石器时代。有些人什么事都使用Notepad，然后惊讶于其他人使用一半的时间完成了工作。 过犹不及。如果你总是试图找到完美的命令去做每件小事情，你将没有时间去思考实际上要去做的工作。只要挑选出那些超出必要时间的动作，练习相关命令直到你在使用它们时不需要去想。然后你就可以集中精力在文本上了。 以下章节会建议一些大多数人需要去处理的动作。你可以从中受到启发，在你的工作中使用这三个基本步骤。 2.**不要输入两次** 我们输入的是一组有限的单词，甚至是有限的短语和句子，特别是在计算机程序中。显然，你不想把同样的东西输入两次。 很多时候，你想修改一个单词。如果是在整个文件中，你可以使用:s（substitute）命令。如果只是几个地方需要修改，一种快速的方法是使用 * 命令去找到下一个出现的单词，使用cw命令修改它。然后输入n去找到下一个单词，输入英文逗点 . 去重复cw命令。 . 命令重复上次的修改。修改在这里就是插入、删除或者替换文本。能够重复是一个非常强大的机制。如果你基于它来安排你的编辑，许多修改将变得只是敲.键。留意其间的其他修改，因为它会替代你原来要重复的修改。相反，你可以用m命令先标记这个位置，继续重复你的修改，稍后再返回到这个位置。 一些函数和变量名可以被笨拙的输入。你能快速输入“XpmCreatePixmapFromData”，不带一个错字，并且不用查询它么？Vim有一个完整的机制使它更容易。它在你正在编辑的文件里查询单词，这也包括#include文件。你可以输入“XpmCr”，然后按下CTRL-N，Vim会把它扩展为“XpmCreatePixmapFromData”。这不仅节省了输入时间，更能避免错字，并且避免稍后编译器报错时去修复它。 当你多次输入一个短语或句子时，这有一个更快捷的办法。Vim有一个录制宏的机制。你输入qa启动录制到寄存器“a”。然后像往常一样，你输入命令，最后再次按下q以终止录制。当你需要重复所录制的命令时，输入@a。一共有26个寄存器可用。 录制功能可以重复许多不同的动作，不只是插入文本。当你要重复一些东西时，记住这一点。 有一点需要注意，录制的命令将会完全按照你输入的回放。你必须知道移动的文本可能跟所重复的命令不同。左移四个字符也许适合你正在录制的文本，但是在你重复命令的地方可能需要五个字符。这往往需要使用命令移到文本对象（词，句子）或者移到一个特定的字符。 当你需要重复的命令越复杂，一次正确输入它们就越困难。不要去录制它们，相反，你应该写一个脚本或宏。这对制作你的部分代码的模板非常有用。例如，一个函数头。你可以把它做得如你所愿的灵活。 3. **错误要修正** 输入时候出错很正常，没有人能够避免。关键是要迅速发现并纠正它们。编辑器应该能帮助你，但你得告诉它什么是错误的、什么是正确的。 往往你会一遍又一遍地犯同样的错误。你的手指输入的并不是你打算要做的。这可以被缩写纠正。举几个例子： 123 :abbr Lunix Linux:abbr accross across:abbr hte the 在你输入这些单词后，它们会被自动纠正。 使用相同的机制，你可以只输入几个字符来得到一个长单词。这对于那些很难输入的单词很有用，避免了输入错误。示例： 12 :abbr pn penguin:abbr MS Mandrake Software 然而，当你不想扩展到完整的单词时，会觉得很困难在文本里插入“MS”。最好去使用没有字面意思的短的单词。 Vim有一个灵活的高亮显示机制在你的文本里发现错误。这实际上被用作程序的语法高亮显示，但他也可以捕获并高亮显示错误。 语法高亮用色彩显示注释。这听起来并不像一个重要的功能，然而一旦开始用它，你会发现它有很大帮助。你能够迅速发现本应该是注释却没有被高亮显示的文本（可能使你忘记了注释标记）。或者看到以行代码被高亮显示成注释（你忘记去插入一个“*/”）。这些错误很难在B&amp;W文件里发现，并有可能浪费大量时间去调试代码。 语法高亮还可以捕获不匹配的括号。不匹配的“)”会以鲜红的高亮背景显示。你可以使用%命令去查看它们如何匹配，并在合适的位置插入一个“(”或“)”。 其他常见的错误也能被迅速发现，例如使用“#included &lt;stdio.h&gt;”而不是“#include &lt;stdio.h&gt;”，这在B&amp;W文件里会被轻易错过的错误。但是你会很快发现“include”是高亮显示的，而“included”不会。 一个更复杂的例子：使用一个针对英语文本的、包含所有单词的长列表。不在此列内的任何单词可能是一个错字。你可以使用语法文件高亮显示所有没有包含在这个列表内的单词。你可以使用一些额外的宏来添加单词到词库，从而让它们不再被标记为错误。这就像你所期待的字处理器一样。它在Vim里用脚本实现，你可以进一步根据需要调整。例如，只去检查程序里注释的拼写错误。 第2部分：编辑多个文件4.**只有一个文件的情况很少**人们不只是工作在一个文件上，大多数情况会有许多相关文件，你一个接一个编辑它们，或者几个同时编辑。你应该能充分利用你的编辑器，使编辑几个文件更高效率。 之前提到的标签机制也适用于文件之间移动。通常的做法是为整个正在工作的项目生成一个标签文件。然后，你可以在项目里所有文件间寻找函数、机构、类型等的定义。相比较手动搜索，这节省的时间非常可观。创造一个标签文件是我浏览程序时要做的第一件事。 另一个强大的机制是在一组文件里使用:grep命令找到一个名字出现的所有位置。Vim建立一个所有匹配的列表，并跳转到第一个匹配。:cn命令带你依次到下一个匹配。如果你需要改变一个函数调用的参数数目，这会非常有用。 Include文件包含有用的信息，但是找到一个包含你需要看到的声明很花时间。Vim知道include文件并可以在它们中搜索你要找的单词。最常见的动作是查找一个函数的原型。把光标放在你的文件里的函数名上，输入[I:，Vim将显示一个包含所有在include文件里匹配该函数名的列表。如果需要看到更多上下文，你可以直接跳转到声明。一个类似的命令可用来检查你是否包含了正确的头文件。 Vim中，你可以把文本区分成几个区域编辑不同的文件。然后，你可以在两个或多个文件中比较内容，复制（粘贴）文本。有很多命令打开和关闭窗口，在它们之间跳转，临时隐藏文件等等。同样，你需要应用三个基本步骤来选择你打算学会使用的命令集。 多窗口有更多用途。预览标签机制是一个很好的例子，它会打开一个特殊的预览窗口，同时保持光标在你正在工作的文件中。在预览窗口中会显示文本，例如光标下的函数名所对应的函数声明。如果移动光标到另一个名字并停留一秒钟，预览窗口将会显示那个名字的定义。这也可以是一个在项目include文件里声明的结构或者函数的名字。 5.**让我们共同努力** 编辑器用于编辑文本，电子邮件程序发送和接收消息，操作系统运行程序。每个程序有它自己的任务，并擅长于它。这种力量源自程序协同工作。 一个简单的例子：你需要些一个不超过500字的总结。选择当前段落写入“wc”程序:vip:w!wc –w。外部命令“wc -w”用作计算单词数目。很简单，不是吗？ 总会有一些你需要的功能没有包含在编辑器里。你可以从外部添加功能，使编辑器能使用另一个程序过滤文本。一直以来，Unix的精髓就是用不同的程序做好它们自己的工作，并协作执行一个更大的任务。不幸的是，大部分编辑器不能很好地同其它程序一起工作——例如，你不能用另一个编辑器去替换Netscape里的电子邮件编辑器。你会终止使用残缺的编辑器。另一个趋势是在编辑器里包含所有功能，Emacs是一个很好的例子来终止（有人称之为一个可被用来编辑文本的操作系统。） Vim试图与其它程序集成，但这仍然是一个挑战。目前，它可被用作MS-Developer Studio和Sniff的编辑器。一些像Mutt的电子邮件程序支持外部编辑器，可以使用Vim。与Sun工作站的集成在进行中。总之，在不久的将来这是一个必须加强的领域。只有这样我们才能得到一个优于各部分简单相加的系统。 6.**文本结构** 你会经常遇到具有某种结构的文本，但是和现有命令所支持的不同。然后，你将不得不退回到编辑器的“积木”，创造你自己的宏和插件来处理这个文本。我们在这里接触更复杂的东西。 更简单的事情之一是加快编辑-编译-修复周期。Vim有:make命令，开始编译，捕捉它产生的错误，并让你跳转到错误位置来修复问题。如果你使用不同的编辑器，错误信息将无法识别。你应该调整“错误格式”选项，而不是重回到老的“把它写下”系统。这告诉Vim你的错误是什么样子，以及如何获取文件名和行号。它适用于复杂的gcc错误消息，因此你应该能使其与几乎任何编辑器工作。 有时调整到一种文件只是设置一些选项或写一些宏。例如，为了在手册页面跳转，你可以写一个宏去获取光标下的单词，清理缓冲区，然后从手册页面把那个单词读到缓冲区。这是一个简单高效的方式来查询交叉引用。 使用者2三个基本步骤，你可以更高效地处理任何结构形式的文件。试想下你想要对文件做的动作，找到可以做它的命令，并开始使用它们。正如你听到的，这真的很简单。你只需要去做它。 第3部分：磨刀不误砍柴工7.**形成习惯**学开车需要努力。那是你保持骑自行车的理由么？不，你认识到需要投入时间去学习一门技能。文本编辑不一样。你需要学习新命令，并把它们变成一种习惯。 另一方面，你不应该试图学习编辑器提供的所有命令。那将是彻底的浪费时间。大部分人只需为他们的工作学习10%到20%的命令。但对每个人来说这套命令是不同的。它需要你不时回过头来思考是否有一些重复性任务可以被自动化。如果你做的任务，只有一次，并不期望去再做一次，那就不要试图去优化它。但是你可能意识到你已经花了一个小时重复好几次做某事，那就在文档里搜索一个可以更快做它的命令。或者写一个宏来做到这一点。当它是一个更大的任务，例如选出一种特别的文本，你可以浏览下新闻组或互联网，看看是不是有人已经为你解决了这个问题。 必不可少的基本步骤是最后一条。你能想到一个重复性的任务，找到一个好的解决方案，过了周末忘记你是怎么做的。这不起作用。你必须重复它知道你的手指可以自动去这样做。只有这样你才能达到你需要的效率。一次不要学太多，同时做一些就好。把你不经常使用的技巧记录在表格里，以备日后查用。无论如何，如果你坚持目标，你会发现让你编辑越来越高效地办法。 最后一句提醒，当人们忽略上述所提会发生什么：我仍然看到人们在电脑屏幕（VDU）后花了半天时间，抬头看着屏幕，然后低头看两个手指输入，再抬头看着屏幕，等等。——然后他们奇怪为什么如此累……用十指输入！这不只是速度更快，也能减少无聊。每天使用一个小时计算机程序，只需要几个星期就能学会按指法输入。 结语 标题的想法来自斯蒂芬-科维所著的成功书籍《高效能人士的七个习惯》。我向需要解决个人和职业问题人们（谁没有？）推荐这本书。虽然有些人会宣称它来自斯科特-亚当斯所著的《迪尔伯特——高度有缺陷人士的7年》（同样推荐）。 布莱姆·米勒写于 2000年11月 关于作者 布莱姆·米勒 (Bram Moolenaar) 是Vim的主要作者。他写了Vim功能核心，并且选择包含其他人提交的代码。他以电脑技师的身份毕业于代尔夫特技术大学。现在，它主要从事软件工作，但仍然懂得如何使用烙铁。他是ICCF（荷兰）的创始人和财务主管，帮助乌干达的孤儿。他是一名从事系统架构师工作的自由职业者，但是实际上花费大部分时间在开发Vim上。他的电子邮件地址：Bram@moolenaar.net。","tags":[{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"Sublime Text使用体验","date":"2016-10-28T04:08:32.000Z","path":"2016/10/28/arctile_1/","text":"​ 让我使用一种新编辑器是比较难的，但鉴于听到Sublime Text获得如此多的赞扬，我最终决定试一下。毕竟，比起我的又老又生硬的Vim，Sublime Text界面好看的多，布局更顺手——我是对界面很挑剔的。于是，在tuts+上看了几篇资料后，我就开始在工作中试用起来。下面就是我的一些体验。 先说Sublime Text的优点： Sublime Text跨平台。如果一种编辑器只能运行在一种平台上，我是绝对不会考虑它的，跨平台是必要条件。 Sublime Text不仅跨平台，而且在所有平台上看起来都很漂亮。很流畅，响应灵敏，很吸引眼球。 Sublime Text的一个独特的功能是支持多光标操作：它能让你对文本中的多个地方同时做修改，你可以看到多个地方在你输入的时候同时发生变化。重构时用它很方便，比如修改一个变量名。 Sublime Text的command palette能够让你轻松的做任何操作，勉去了记忆众多快捷键的痛苦。你只需要打开command palette ，输入几个字母，Sublime Text会用模糊查询给你提供建议和选项。跟直接使用快捷键几乎没区别。 所有的操作和选项都很直观的放在菜单里。虽然我并不是很多的使用菜单(感谢command palette)，但你可以在里面查找你想要的操作，学会这个编辑器里有哪些功能。 打开文件很快，而且可以通过Go to anything弹出面板转到文件中任何地方。我使用Vim时一直使用ctrlp来做这种事情，但Sublime Text支持转到某个位置和某行，非常方便。 编辑文件的同时你可以启动编译，看到输出结果，这种交互能让你快速发现编译错误。这点集成的非常好，非常顺滑，比Vim要好。 在Sublime Text里你可以使用Vim命令进行光标移到和编辑文本，很显然，如果你习惯Vim，你可以在Sublime Text了进行闪电般的快速编辑。 当然，Sublime Text里还提供了很多非常有用的文本操作命令，你可以设定快捷键绑定这些操作。 Sublime Text扩展性很好，它使用了Python式的插件系统。这显然是一个很大和活跃的社区，可以为它提供丰富的插件，这也意味着你可以在网上找的任何你想要的插件来集成你想要的功能。 不幸的是，Sublime Text也有不少缺点： 尽管Sublime Text是跨平台的，但它看起来并不是为同时在多个平台上的用户设计的。比如，快捷键在各个平台上都不同，这比由Cmd变成Ctrl要严重的多。这可能是由于Sublime Text的设计倾向于平台本地化。在不同的平台上记忆不同的快捷键无疑是讨厌的，经常切换平台时常会弄错。 Sublime Text的配置文件是存在固定格式、平台特定的文件里的。可能同样是因为Sublime Text希望最大化的和操作系统本地集成的原因。然而，这就使得你将配置文件存放在Git版本库里变得很麻烦，在不同的机器，不同的操作系统上不能共享。 Sublime Text使用JSON格式存放配置参数，这适合是无可非议，但确有个很大的缺点：设置的每一行结尾都需要一个逗号，除非最后一行。很多在我修改配置时都忘了这一点。使用JSON的另外一个缺点是，这种格式不是很强大：因为它基本上都是key/value值，你无法添加条件依赖(比如，在不同的机器上不同的配置)，或引用其它文件。 Sublime Text没有命令行界面。我经常需要编辑远程系统上的文件，通常只有一个命令行终端。这种情况下，我只能用其它编辑器。 Sublime Text很明显的另外一个缺点：它不开源，而且收费版的价格也不便宜。我并不是反对任何闭源软件，而且如果一个编辑器我需要天天使用它，我很愿意花钱买它。然而，有一些现实问题：我工作的那台机器无法运行Sublime Text，因为Sublime Text引用了一些旧的程序库，我机器上没有。我无法自己重新编译它，它就毫无用处了。而且，有一点我需要说的是，我不喜欢这种一个编辑器的生命依赖于某个人的专注和贡献，万一他被车撞了呢。如果他的开发终止了，也许会人能克隆一个来支持现有用户们，这是个未知数。 我只是试用了一下Sublime Text 2，虽然3也出来了，但是没去使用了。因为我说的这些问题都是根本性的，我不认为在未来的版本上在这方面会有所改进。我对这些事情不是很习惯，一次又一次的在使用时犯错，我最终决定重回Vim。然而，我认为Sublime Text是个很不错的编辑器，我认为它是至今为止发现的最有可能替代Vim的编辑器。","tags":[{"name":"sublime","slug":"sublime","permalink":"http://onethree.cn/tags/sublime/"},{"name":"IDE","slug":"IDE","permalink":"http://onethree.cn/tags/IDE/"}]}]