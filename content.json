[{"title":"Vim-plug：极简 Vim 插件管理器","date":"2018-06-22T04:22:24.000Z","path":"2018/06/22/arctile_19/","text":"当没有插件管理器时，Vim 用户必须手动下载 tarball 包形式的插件，并将它们解压到 ~/.vim 目录中。在少量插件的时候可以。但当他们安装更多的插件时，就会变得一团糟。所有插件文件分散在单个目录中，用户无法找到哪个文件属于哪个插件。此外，他们无法找到他们应该删除哪个文件来卸载插件。这时 Vim 插件管理器就可以派上用场。插件管理器将安装插件的文件保存在单独的目录中，因此管理所有插件变得非常容易。我们几个月前已经写了关于 Vundle 的文章。今天，我们将看到又一个名为 “Vim-plug” 的 Vim 插件管理器。Vim-plug 是一个自由、开源、速度非常快的、极简的 vim 插件管理器。它可以并行地安装或更新插件。你还可以回滚更新。它创建浅层克隆shallow clone最小化磁盘空间使用和下载时间。它支持按需加载插件以加快启动时间。其他值得注意的特性是支持分支/标签/提交、post-update 钩子、支持外部管理的插件等。 安装安装和使用起来非常容易。你只需打开终端并运行以下命令：curl -fLo ~/.vim/autoload/plug.vim --create-dirslink123Neovim 用户可以使用以下命令安装 Vim-plug：```$ curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 用法安装插件要安装插件，你必须如下所示首先在 Vim 配置文件中声明它们。一般 Vim 的配置文件是 ~/.vimrc，Neovim 的配置文件是 ~/.config/nvim/init.vim。请记住，当你在配置文件中声明插件时，列表应该以 call plug#begin(PLUGIN_DIRECTORY) 开始，并以 plug#end() 结束。 例如，我们安装 “lightline.vim” 插件。为此，请在 ~/.vimrc 的顶部添加以下行。plug#begin('~/.vim/plugged')```1```Plug &apos;itchyny/lightline.vim&apos; plug#end()```123在 vim 配置文件中添加上面的行后，通过输入以下命令重新加载：```:source ~/.vimrc 或者，只需重新加载 Vim 编辑器。现在，打开 vim 编辑器：vim```12使用以下命令检查状态：```:PlugStatus 然后输入下面的命令，然后按回车键安装之前在配置文件中声明的插件。12345#### 更新插件要更新插件，请运行：```:PlugUpdate 更新插件后，按下 d 查看更改。或者，你可以之后输入 :PlugDiff。 审查插件有时，更新的插件可能有新的 bug 或无法正常工作。要解决这个问题，你可以简单地回滚有问题的插件。输入 :PlugDiff 命令，然后按回车键查看上次 :PlugUpdate的更改，并在每个段落上按 X 将每个插件回滚到更新前的前一个状态。 删除插件删除一个插件删除或注释掉你以前在你的 vim 配置文件中添加的 plug 命令。然后，运行 :source ~/.vimrc 或重启 Vim 编辑器。最后，运行以下命令卸载插件：1234567该命令将删除 vim 配置文件中所有未声明的插件。#### 升级 Vim-plug要升级vim-plug本身，请输入：```:PlugUpgrade 如你所见，使用 Vim-plug 管理插件并不难。它简化了插件管理。现在去找出你最喜欢的插件并使用 Vim-plug 来安装它们。","tags":[{"name":"Vim","slug":"Vim","permalink":"http://onethree.cn/tags/Vim/"},{"name":"插件","slug":"插件","permalink":"http://onethree.cn/tags/插件/"}]},{"title":"你在抖音刷段子，我在网易云看情话","date":"2018-04-18T14:12:24.000Z","path":"2018/04/18/arctile_18/","text":"网易云的评论区，从来就是个不缺故事的地方，收集了一些情话，不知道说给谁听，发出来共享一下吧。 1.@你背后有光ya： “在吗” “在啊咋了” “我发现了一个外国人和中国的区别” “什么区别？” “外国人喜欢一个人很直接说I love you” “那中国人呢？” “中国人很委婉会小心翼翼的问他在吗” 来自单曲如常-房东的猫 2.@那你有小鱼干吗： 周恩来给妻子写的信上说：“你的信太过官方，都不说想我。” 她回信说：“纸短情长，吻你万千。” 来自单曲纸短情长-烟把儿 3.@七亿仙男的梦： 不想撞南墙了 想撞先生的胸膛 来自单曲起风了-买辣椒也用券 4.@团子汐回复： 曾经我自半个诗人，见山是深情伟岸，见海是热情澎湃，见花见草信他们皆有故事，云海江潮，虫鸣鸟啼都暗藏情愫。唯独见了 你，山川沉默，海面静谧，云海不再翻涌，江潮不再澎湃，花鸟鱼虫被光与尘凝固，世界万籁俱寂，只剩下你。 @我是绘梨衣啊： 我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。 来自单曲起风了-买辣椒也用券 5.@苏弥生：这里荒芜寸草不生， 后来你来这走了一遭， 奇迹般万物生长， 这里是我的心。 ——《沙漠》 喜欢倒着读这首小诗 来自单曲「喜欢你，但害怕]-戴尔基 6.@韩先森爱鱼小妹： 现在想想，最美妙的时刻不是热恋，而是有人忽然闯进你心里的那一瞬间。仿佛拥有了新的世界，叫人相信所有的剧本都是为你我而写。 来自单曲小永远-何洁 7.@帐号已注销： 江湖太远了我不去了 我爱上了给你做饭陪你睡觉. 来自单曲123我爱你（男声版） 8.@猫姐姐-： 我北上看到的冰川是你， 我南下追寻的极光是你， 我西去流浪的经幡是你， 我东去皈依的梵经也是你。 来自单曲浮生-刘莱斯 9.@妖么嬷： “我有一个办法让你快速瘦三斤哦~” ？” “把你的心给我” 来自单曲123我爱你（男声版） 10.@Sun_小瑶： “一腔情意喂了狗，谁再回头谁是狗。 “汪.… 来自单曲一腔诗意喂了狗-花粥 11.@八月间下雨很正常：“你听什么歌呢？”“歌名太长太难说了”“那就说前几个字吧~””我喜欢你。。。” 来自单曲我喜欢你胜过削好的水果周末的零食延后的死线冰镇西瓜正中间那一口肆无忌惮的赖床和空调房里盖棉被的感觉但我就是不敢告诉你 12.@亿万少女的怀春梦： 我看过春风十里，见过夏至未至，试过秋光潋滟，爱过冬日暖阳，全都抵不过你一句我想见你。 来自单曲好想你-沈以诚 13.@愿风带走伤和痛： 老师让用两个字来形容爱情。有个同学写下“瓶邪”老师不知，问该如何解释。同学淡定回答道：“瓶字，可以拆分为并瓦，意为并肩屋檐下。邪字，牙耳，可以理解为鬓边私语。两个字合起来，意思就是，我与你，在屋檐下并肩而坐，悄悄地在耳边说着些别人不懂的秘密。“然后，整个课堂都沸腾了。 来自单曲好想你-沈以诚 14.@大概上辈子是个狐狸： 我喜欢吃草莓，草莓汁不行，草莓蛋糕不行，不是草莓不行。 我喜欢你，长得像你不行，性格像你不行，不是你不行。 来自单曲我多喜欢你，你会知道 15.@我要变成长颈鹿了： “其实有很多事情不用那么拐弯抹角。与其说我喜欢夏天，不如说我喜欢西瓜冰淇淋小短裙；与其说我喜欢大海，不如说我喜欢海水漫过脚踝；与其说我喜欢笑起来很阳光的人，不如说我喜欢你。” 来自单曲Say Hello-Rosie Thomas 16.@HalfBrokeHorse: “何为归途？” “夜鸟荒路漫漫无期。” “可否具体？” “碎言华灯喧嚣无际。” “可否再具体？” “一诗一酌不觉千里。” “仍是不解。” “与你，四处为安。” 来自单曲浮生-刘莱斯 17.@蔡小卿Yoki: 你看到了我眼里的沙丘河流，也看到了我眼里的星辰黄昏，你可曾看到我心里，嘘在那里，你一直都那里。 来自单曲嘘（Acoustic)-愚青","tags":[{"name":"情话","slug":"情话","permalink":"http://onethree.cn/tags/情话/"},{"name":"网易云","slug":"网易云","permalink":"http://onethree.cn/tags/网易云/"}]},{"title":"Linux 目录结构：/lib 分析","date":"2017-04-25T03:23:12.000Z","path":"2017/04/25/arctile_16/","text":"原文出处： Surendra Anne 我们在之前的文章中已经分析了其他重要系统目录，比如 /bin、/boot、/dev、 /etc 等。可以根据自己的兴趣进入下列链接了解更多信息。本文中，让我们来看看 /lib 目录都有些什么。 目录结构分析：/bin 文件夹 目录结构分析：/boot 文件夹 目录结构分析：/dev 文件夹 目录结构分析：/etc 文件夹 目录结构分析：/lost+found 文件夹 目录结构分析：/home 文件夹 Linux 中，/lib 文件夹是什么？/lib 文件夹是 库文件目录 ，包含了所有对系统有用的库文件。简单来说，它是应用程序、命令或进程正确执行所需要的文件。在 /bin 或 /sbin 目录中的命令的动态库文件正是在此目录中。内核模块同样也在这里。 以 pwd 命令执行为例。执行它需要调用一些库文件。让我们来探索一下 pwd 命令执行时都发生了什么。我们需要使用 strace 命令 找出调用的库文件。 示例： root@linuxnix:~# strace -e open pwdopen(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3open(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_CLOEXEC) = 3/root+++ exited with 0 +++root@linuxnix:~# 如果你注意到的话，会发现我们使用的 pwd 命令的执行需要调用两个库文件。 Linux 中 /lib 文件夹内部信息正如之前所说，这个文件夹包含了目标文件和一些库文件，如果能了解这个文件夹的一些重要子文件，想必是极好的。下面列举的内容是基于我自己的系统，对于你的来说，可能会有所不同。 root@linuxnix:/lib# find . -maxdepth 1 -type d./firmware./modprobe.d./xtables./apparmor./terminfo./plymouth./init./lsb./recovery-mode./resolvconf./crda./modules./hdparm./udev./ufw./ifupdown./systemd./modules-load.d /lib/firmware – 这个文件夹包含了一些硬件、固件Firmware代码。 硬件和固件之间有什么不同？ 为了使硬件正常运行，很多设备软件由两部分软件组成。加载到实际硬件的代码部分就是固件，用于在固件和内核之间通讯的软件被称为驱动程序。这样一来，内核就可以直接与硬件通讯，并确保硬件完成内核指派的工作。 /lib/modprobe.d – modprobe 命令的配置目录。 /lib/modules – 所有的可加载内核模块都存储在这个目录下。如果你有多个内核，你会在这个目录下看到代表美国内核的目录。 /lib/hdparm – 包含 SATA/IDE 硬盘正确运行的参数。 /lib/udev – 用户空间 /dev 是 Linux 内核设备管理器。这个文件夹包含了所有的 udev 相关的文件和文件夹，例如 rules.d 包含了 udev 规范文件。 /lib 的姊妹文件夹：/lib32 和 /lib64这两个文件夹包含了特殊结构的库文件。它们几乎和 /lib 文件夹一样，除了架构级别的差异。 Linux 其他的库文件/usr/lib – 所有软件的库都安装在这里。但是不包含系统默认库文件和内核库文件。 /usr/local/lib – 放置额外的系统文件。这些库能够用于各种应用。 /var/lib – 存储动态数据的库和文件，例如 rpm/dpkg 数据和游戏记录。","tags":[{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"}]},{"title":"如何识别人的技术能力和水平？","date":"2017-04-12T13:23:17.000Z","path":"2017/04/12/arctile_17/","text":"原文出处： ACE开发者 这个题目是比较复杂的，它包含的东西比较多，认真讨论估计能写几万字。如果是专业研究，我看能写一本书了。这里打算根据自己的学习过程和工作经验，谈一下要点问题，均属个人看法，欢迎讨论。 写这篇文章的初衷，跟前段时间跟朋友们聊招聘有关。因为技术招聘除了考察人的协作精神和工作态度，一大目标便是判断人的技术能力和实际水平。在这件事情上多做观察、思考是很有意义的。 对于考察人的技术等级，学界是有认真的研究的。参见：*德雷福斯模型解说*。 德雷福斯模型把人的技能水平，分成5级：新手、高级新手、胜任者、精通者、专家。 对不同技能等级的认定是这样的： 新手：依靠指令清单，必须按部就班。就是必须给出详细而具体的操作规则，才能工作。比如你做一道从未做过的菜，需要看菜谱的说明，第一步做什么，第二步做什么等等，直到最后烹饪结束。 高级新手：有限的情景洞察力，同等对待工作的各个方面。对全局性、体系性的东西没兴趣。这是小工的水平。比如他能跟着师傅干点活，打打下手。可以靠着反复检索搜索引擎、StackOverflow解决具体的小问题。 胜任者：能够独立解决各种各样的领域内问题。这是一般的企业招聘，比较希望招到的等级，招进来稍作适应就能干活了，省心省力。 精通者：经验丰富，可以自我纠正、自我改进。这类等级的人，思考可以指向内在，通过反省、反馈改善技能。这种在企业可以算上高手、大拿了，培养不易。 专家：依靠直觉工作，不需要解释和理由。实际你让他解释，他可能也说不出个所以然，就是直觉给出答案，然后还是对的。专家人数稀少，需要很长时间训练、实践。通常的说法是10年出专家，10000小时定律。 这个是理论上的研究，实践中比较缺乏操作性，难以迅速的判定应聘者的实际情况。不信你打开收进来的大把简历，刚毕业的学生，每个技能名词上面都是一堆堆的“精通” – 你相信么？但它可以当成一个职业技能等级判定的参照标准。 于是乎，各家企业开启了各种“笔试”、“机试”，多轮面试，并且严格要求学历以及出身院校，试图以此过滤掉不合意的应征者，留下合格的人选。它当然是可行的，但是效果一般，而且容易出错，错失有思想有水平的人。不然也不会催生出各类“推荐式”的招聘。看重学历、学校当然也有其优点：它是快速过滤的手段，毕竟能考上好学校的人智商不会太差吧。但在大数字公司的一朋友说，公司里面还有初中毕业，一直精研安全领域的人，技术能力也是十分出色。如果严苛对待背景，这些人就会错过了。因为人的生活多种多样，有各种历史的背景因素影响经历。而部分人的经历，就是跟一些人不同的，可是不妨碍他们同样可以变得优秀。招聘，实际上是建立信任关系。如果有充足的信息证明，应聘者足够优秀，这就够了。条条框框只是辅助手段，并不是目的。 任正非的洞察力一流 推荐式的招聘实际要靠谱的多，因为人很容易了解熟悉的人的水平。这是靠推荐者的信用背书。人平时沟通时说什么话，日常看什么书，关注哪些领域，琢磨过啥问题，哪些东西很熟，这个经常聊的熟人往往都知道。可是，这类招聘局限性也很大：面窄、靠机缘。靠推荐能招几个好手啊？好手往往是各家争抢的对象，窗口期有限，基本不会缺工作的。 说了一圈，还是要在技能水准判定上有更高效率的办法，招进合适的人来。 回到开头的德雷福斯模型，既然人的技能是分级的，那么对待不同的职位要求，也应该侧重不同的考察角度。如果千篇一律的走招聘流程，就容易出问题了。比如你明明要找的是“精通者”，可上来就让人一堆笔试、机试，这是不合适的。对方会十分的厌烦。体现高水平技术能力的并不在默写什么“字符串算法”那里。这反倒是刚毕业的人占便宜，因为才学过不久，印象深。不信你让工作10年的人跟计算机专业应届生比比写排序算法，真未必能赢。但是这并不重要 – 你干活不看手册不查文档吗？聪明人从不死记硬背。重要的地方在于对问题域的准确、深刻的理解，对各类技术优劣点、各种条件平衡的评判和把握。 对待初阶新人，应着重考察的是基本功是否扎实，专业成绩是否优秀。更重要的，是他对职业的热情，学习能力和研究精神。某类人要说起技术来，滔滔不绝，两眼放光，充满热情，对未知的、新生的各类概念、技术非常好奇，这种人想差都难。因为他会自我驱动，不用督促，自己就钻研前进。反之，觉得这个职业待遇高，只是想混饭吃的人，很少走得长远。这类初阶新人以毕业生、工作年限少者为多。测试考核，可以笔试查看其对基础概念的理解是否准确，知识领域的大致范围。甚至，布置一个有点挑战性的小任务，让他尝试解决，说明思路。 考察胜任、精通者的策略不一样。笔试做题没啥用，原因前面说了。这类招聘是重头戏，企业都喜欢找这样的，能干活。所以考核评估的地方也较多。我觉得可以分成几个方面去看。意识是否先进，是否会反省思考；是否善于解决问题，富有创造性；是否有比较深的积累和广阔的知识面。 业界的开发思想也是在不断变化，工具链一直在革新。聪明的人不用蛮力，而爱用工具提升效率，喜欢自动化操作解放人力。要查看人用什么开发工具链，用什么开发环境，解释下为什么？好的开发者会及时注意新出现的工具，挖掘它能解决什么问题，并尝试吸收，解决自己的需求。如果没有这个思想意识，工作效率就会打折扣了。因为你会落后行业发展水平。人善于自我反省，则会催动自我纠正，这正是精通者的特征。参考：*优秀的开发者为什么要学习研究新的编程语言？* 解决问题的能力是重头戏，也是企业招聘人的主因。人要善于解决实际问题，而且，要学会聪明的解决问题。解决问题要看思路，看手段，看是否有创造性，这是真正考验人能力的地方。好的开发者，会考虑很多可能选项，预估各种优劣，给出一个较优的方案。 遇到难题，会用各种方法尝试。经验丰富的人，常常会使用技术的组合手段来处理难题，而不是一个语言一个工具到处用。所以，要查看下过往的项目经历遇到的问题、困难，是如何解决的，思路如何。一些公司据说不招聘不会用谷歌的工程师。谷歌打不开？嘿嘿，这就是你要克服的困难啊。这你都解决不了，还做什么研发。谷歌是人类最全、最新知识的总索引，充分利用事半功倍。 考察知识的深度、广度，对重要领域的概念是否有深刻的理解和掌握，以及从各类工作经验中得到的认知。问问他看过什么书，研究过什么东西。说白了，知道的东西是否多。一些公司很喜欢用CheckList模式来考核，列一堆领域的知识点、概念，问人懂不懂，知道就是水平好，不懂就是水平差。实际情况并非如此。人的工作过程是独立的，一些事情如果没有工作机会去接触并解决，那么一些冷僻的问题就永远都碰不上。当然也就不知道。但你能说没做过就一定做不好么？ 另外，人的技能树，其实也是“犬牙交错、参差不齐”的。什么意思？技术领域非常的广阔，你真的没办法每个领域都很精通，实际上是这个做的多，懂的多，那个用的少，知道的少。这个时候，应看具体知识领域，是哪一类。它是否需要复杂的、难度较高的背景。门槛高的技术，需要的配套技能多得多，比如AI、机器学习。而一般产品应用领域则不然，了解核心概念、设计意图，看着手册、最佳实践，也就能上手了。这个暂时不会，实际无关紧要的，工作一段学的认真点就会了。但是门槛高的领域，就需要很长时间的学习了。这是本质的差别。 我曾看见某公司放出的职员技能树，包罗万象，几乎一切IT领域的知识技能都在里面了，还声称要求“全部精通”。我不知道它如何定义的“精通”，如果按德雷福斯模型的定义，能做到的那是神，不是人类。这个纯属吹牛皮，我压根就不信。如果真有这样的人，出来让我膜拜下。因为每个稍大点的领域，都足够让你钻研一辈子，因为它们也在迅速发展呀。业内流传“全栈工程师”的说法，鼓吹自己是全栈的人经常是前端工程师。而研究后端工作领域的技术高手经常鄙视这类人：真以为会点Node.js就能解决一堆后端的事务了么？我也懂一些前端，也能号称“全栈”，但在不同领域的专业性是什么水准，自己明白的很。前端要解决的事情也有很多复杂性。全栈实际是反专业化的，是人力资源稀缺时候的低成本选择。 更高一层，则是考察人本身了。人的视野够广阔么？其它领域的知识有了解吗？一些问题的解答并不在问题域本身，而是在外面的领域。所谓“功夫在诗外”。公司讲求团队协作，总要面临不同的分工合作问题。比如产品、运营的人提需求，可以换位思考吗？合作意识强么？谁也不想招个刺头进来吧？把团队的气氛和人际关系搞的一团糟，大家做事都不痛快、不顺心，又如何安心做好工作？最终只能让团队工作效率下降，甚至瓦解。 要说专家，实际上有研究者认为是需要刻意练习+充分实践才能功成。并不是每个人经过足够的工作年限，都自动成为专家。有的人工作10年，可能后面9年都在重复第一年的工作任务，毫无改进。而职业上的训练机会，又跟大环境乃至运气息息相关，并不是每个人都有机缘的。但是把个人的职业技能做到胜任乃至精通，则是完全可行的，这只需要认真和勤奋，工作态度问题。","tags":[{"name":"杂记","slug":"杂记","permalink":"http://onethree.cn/tags/杂记/"},{"name":"职场","slug":"职场","permalink":"http://onethree.cn/tags/职场/"},{"name":"技术","slug":"技术","permalink":"http://onethree.cn/tags/技术/"},{"name":"能力","slug":"能力","permalink":"http://onethree.cn/tags/能力/"}]},{"title":"使用 Git上传代码到coding.net代码仓库详解","date":"2017-03-28T06:58:22.000Z","path":"2017/03/28/arctile_15/","text":"看到网上许许多多关于Git使用的文档，要么文章过于详细，不便于新手快速上手，要么过于简洁，甚至好多是错误的······怀疑未经实践便一个个转载而来，故通过一篇博客每步的记录下使用Git上传代码到代码库（支持Git代码托管的平台比较多，而且都是免费的，此处以coding.NET为例子，速度快，功能与开源中国相似，同样一个账号最多可以创建1000个项目，也支持任务的创建等。 1.生成ssh在电脑桌面上右键，选择Git Bash Here，进入操作界面，输入ssh-keygen -t rsa -C “username@example.com”(注：此处填写的是注册coding时绑定的邮箱，第一个易错点，引号要使用汉语的引号，非英文”“)，接下来点击enter键即可(注意：Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址,如果使用非默认地址可能需要配置 .ssh/config)，之后继续输入$cat id_rsa.pub（打开id_rsa.pub文件）2.配置ssh复制其中全部内容，添加到账户“SSH 公钥”页面 中，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。 如果提示ssh格式错误，请检查自己粘贴是否符合要求，如符合要求，仍然提示ssh格式错误，打开c:/user/bigface(你自己的用户名)/.ssh文件夹（下图以程新松为例） 找到拓展名为pub的文件，以记事本方式打开它，将内容粘贴到网页中的SSH-RSA公钥内容对话框中，去掉后面的邮箱（即新松@saucxs）后点击添加按钮。 ssh应该配置成功。 3.创建本地代码库 在本地创建一个文件夹，作为你上传代码的本地仓库，接下来就要把这个仓库与coding服务器端进行配置 在这个文件夹内点击右键，选择Git Bash Here，首先要初始化本地仓库，输入”git init”命令 接下来进行远程代码库克隆（前提：自行在coding中建立一个项目，空项目即可），输入”git clone https：//xxxxxx”命令，命令中的url获取方式如图： 左下角HHTPS处即为要输入的url 将这个url粘贴到命令中，进行远程仓库的克隆，克隆时会出现输入账号密码的环节（coding注册时的账号和密码） 输入账号密码之后便可以完成克隆。 4.代码推送 克隆之后在原来的文件夹中会多出一个文件夹（即从代码库中下载的文件夹），例如 这时候，本地仓库的配置就完成了，将要上传的代码文件放入这个文件夹中，接下来要查看一下本地仓库的状态，一检查配置是否成功，进而进行代码的推送，输入命令”git status” 例如放入了一个“stringKMP.c”文件之后输入命令”git status” 输入git status命令后，会发现以红色字体打印出来的“stringKMP.c”，说明该文件存在于本地仓库，但并未推送到云端， 接下来，输入”git add 文件名”命令，可以再输入命令”git status”进行状态检查，如下 会发现出现了“new file”。 接下来， 输入”git commit -m “代码备注随便写” “命令提交 然后输入”git push origin master”命令推送到云端，origin是服务器，master是分枝。 一切结束后，输入”git status”查看本地代码状态，会用绿字显示，表示上传成功，进入coding.Net的项目主页，你会发现自己在本地推送的代码已经出现在项目中。 以上就是使用Git上传代码到coding的流程，希望对大家有所帮助。","tags":[{"name":"git","slug":"git","permalink":"http://onethree.cn/tags/git/"},{"name":"coding","slug":"coding","permalink":"http://onethree.cn/tags/coding/"}]},{"title":"纯CSS实现一个微信logo，需要几个标签？","date":"2017-03-25T05:58:22.000Z","path":"2017/03/25/arctile_14/","text":"纯CSS实现一个微信logo并不难，难的是怎样用最少的html标签实现。我一直在想怎样用一个标签就能实现，最后还是没想出来，就只好用两个标签了。 首先需要两个标签元素： 123&lt;div class=&quot;bg&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 先画个背景： 1234567.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative;&#125; 再画个大的椭圆： 123456789.inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 35px;&#125; 小的椭圆利用.inner的::before伪元素实现： 1234567891011&amp;::before &#123; content: &quot;&quot;; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 90px; border: 2px solid #08c406;&#125; 下图时现在的结果： 里面的四个圆怎么画呢？可以利用CSS3的box-shadow属性实现，一般重复性的东西都会用这个属性，因为它可以制造出无数个一模一样的东西出来。 利用.bg的::before伪元素实现这些圆： 123456789101112&amp;::before &#123; content: &quot;&quot;; position: absolute; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; top: 150px; left: 155px; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406;&#125; ::before本身会实现一个圆(一个小圆),然后利用box-shadow属性实现其它的三个圆。 来看看现在的效果： 现在就剩下两个角了，想想还有哪些东西没用上？还有两个伪元素，分别是.bg的::after和.inner的::after，刚好可以实现两个角。 这两个角其实就是平常的小三角，然后再旋转个45度，CSS实现小三角太常见了： 123456789101112131415161718192021.bg::after &#123; content: &quot;&quot;; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 182px; left: 50px; transform: rotate(45deg);&#125;.inner::after &#123; content: &quot;&quot;; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 155px; left: 200px; transform: rotate(-45deg);&#125; 最终效果： 全部css代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@mixin pos($left, $top) &#123; position: absolute; left: $left; top: $top;&#125;.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative; &amp;::before &#123; @include pos(155px, 150px); content: &quot;&quot;; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406; &#125; &amp;::after &#123; @include pos(50px, 182px); content: &quot;&quot;; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(45deg); &#125; .inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; @include pos(35px, 60px); &amp;::before &#123; @include pos(90px, 60px); content: &quot;&quot;; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; border: 2px solid #08c406; &#125; &amp;::after &#123; @include pos(200px, 155px); content: &quot;&quot;; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(-45deg); &#125; &#125;&#125; 画这个logo最难的地方应该就是实现四个小圆的时候，因为CSS3不太熟的人可能不会想到利用box-shadow去实现。","tags":[{"name":"css","slug":"css","permalink":"http://onethree.cn/tags/css/"},{"name":"logo","slug":"logo","permalink":"http://onethree.cn/tags/logo/"}]},{"title":"线条之美，玩转SVG线条动画","date":"2017-03-20T05:58:22.000Z","path":"2017/03/20/arctile_12/","text":"通常来说web前端实现动画效果主要通过下面几种方案： css动画；利用css3的样式效果可以将dom元素做出动画的效果来。 canvas动画；利用canvas提供的API，然后利用清除-渲染这样一帧一帧的做出动画效果。 svg动画；同样svg也提供了不少的API来实现动画效果，并且兼容性也不差，本文主要讲解一下如何制作svg线条动画。 来看几个效果： demodemo demo 以上这些效果都是利用SVG线条动画实现的，只用了css3和svg，没有使用一行javascript代码，这一点和canvas比起来要容易一些，下面就说明一下实现这些效果的原理。 关于SVG的基础知识，我这里就不再叙述了，大家可以直接在文档中查看相关的API，这里只说一下实现线条动画主要用到的：path （路径） 标签命令 M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Belzier curve T = smooth quadratic Belzier curveto A = elliptical Arc Z = closepath 利用path的这些命令我们可以实现我们想要的任何线条组合，以一段简单的线条为例： 效果： 呵呵，看起来很简单，但是，如何让这个线条动起来呢？这里就要明白到SVG里的path的一些主要属性： stroke：标识路径的颜色； d：标识路径命令的集合，这个属性主要决定了线条的形状。 stroke-width：标识路径的宽度，单位是px； stroke-dasharray：它是一个和数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2； stroke-dashoffset：标识的是整个路径的偏移值； 以一张图来解释stroke-dasharray和stroke-dashoffset更容易理解一些： 因此，我们之前的路径就会变成这个样子： 效果： 理解了stroke-dasharray的作用之后，下面我们就可以使用css3的animation来让这个路径动起来。 效果： 511这个值是整个路径的长度，可以用js的document.getElementById(‘path’).getTotalLength()得到 stroke-dasharray: 0, 511; 表示实线和空隙的长度分别为 0 和 511，所以一开始整个路径都是空隙，所以是空的。然后过渡到 stroke-dasharray: 511, 511; 因为整个线条的长度就是 511，而实线的长度也慢慢变成511，所以整个线条就出现了。 同样利用stroke-dashoffset也可以实现这个效果，原理就是最初线条分为511实线，和511空隙，但是由于设置了offset使线条偏移不可见了，当不断修改offset后，线条慢慢出现。 效果： 当我们掌握了上述的方法后，整个利用SVG实现线条动画的原理就已经清楚了，我们需要的就是一个SVG路径了，但是总画一些简单的线条还是不美啊，那我们如何才能得到复杂的svg路径呢？ 找UI设计师要一个。 自己利用PS和AI做一个，只需要简单的2步。 以部落LOGO为例： 1，得到部落LOGO的png图片。 2，右键图层，然后点击从选区生成工作路径，我们就可以得到： 3，文件–导出–路径到AI，将路径导出在AI里面打开。 4，在AI里面选择保存成svg格式的文件，然后用sublime打开svg文件，将path的d拷贝出来即可。 5，利用上文介绍的实现动画的方法，我们就可以轻松的得到了下面这个效果。 线条动画进阶： 可以看到上面的动画效果和文章最初显示的动画效果还是有区别的，要想实现文章最初的动画效果，需要用到SVG的 和 来实现，读者可以在网上查一下这两个标签的用法。 思路就是： 1，将原来只有一条path的路径替换成两条，并且这两条的路径是完全重合的。 2，分别设置两条路径的stroke-dasharray和stroke-dashoffset的css3的animation动画，注意两条路径的动画不能完全一样要有差值。 3，设置成功之后就可以利用animation动画触发的时机和改变程度来实现多条动画效果。 效果： 那么如何实现alloyteam的文字动画呢，其实原理也是利用了stroke-dasharray和stroke-dashoffset，这两个属性不仅可以作用在上，同样可以作用在上。 这里用了5条完全重合的路径，并且每个路径的颜色和动画效果都不一样。 效果： 开启愉快的svg线条之旅吧！","tags":[{"name":"CSS","slug":"CSS","permalink":"http://onethree.cn/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://onethree.cn/tags/JS/"}]},{"title":"编程能力与编程年龄","date":"2017-03-18T10:08:32.000Z","path":"2017/03/18/arctile_11/","text":"程序员这个职业究竟可以干多少年，在中国这片神奇的土地上，很多人都说只能干到30岁，然后就需要转型，就像《程序员技术练级攻略》这篇文章很多人回复到这种玩法会玩死人的一样。我在很多面试中，问到应聘者未来的规划都能听到好些应聘都说程序员是个青春饭。因为，大多数程序员都认为，编程这个事只能干到30岁，最多35岁吧。每每我听到这样的言论，都让我感到相当的无语，大家都希望能像《21天速成C++》那样速成，好多时候超级有想和他们争论的冲动，但后来想想算了，因为你无法帮助那些只想呆在井底思维封闭而且想走捷径速成的人。 今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。 论文首先，我们先来看一篇论文《Is Programming Knowledge Related to Age?》（PDF链接），这篇论文是两个北卡罗莱纳州立大学计算机科学系的两个人Patrick Morrison 和 Emerson Murphy-Hill 对StackOverflow.com上的用户做了相关的数据挖掘得出来的一些数据。（我们知道StackOverflow.com上的数据是公开的，任何人都可以用来分析和统计，所以这篇论文的真实性是有的） 数据采样和清洗条件如下：（数据全量是1694981用户，平均年龄30.3岁） 15-70岁之间的用户（这年龄段的用户被称做“Working age”），当然，有很多用户没有输入年龄，这些用户都被过滤了。 用户在2012年内都回答过问题。因为StackOverflow在2012年对问题和答案的质量要求得比以前高了一倍，所以更能反映程序员的真实水平。 Reputation声望在2-100K之间。（注：StackOverflow的用户Reputation是得到社会认可的，在面试和招聘中是硬通货币。比大学的学分更有价值） 上述的条件一共过滤出84,248名程序员，平均年龄：29.02岁，平均Reputaion在1073.9分。 年龄分布图下面我们来看一下他们的年龄分布图：我们可以看到程序员年纪的正态分布（高点在25岁左右，但是中点在29岁左右） 能力和年龄分布图然后，计算每个人每个月的Reputation，这样可以找到这个用户的真正的活跃时间，这样便于计算这个程序员的真实能力。（总声望 / 活跃时间），可以得到他平均每个月得来的Reputation。 我们来看看程序员的能力和年龄段的分布图：（你可能会大吃一惊） 上图中我们可以看到，程序员的能力在从25岁左右开始上升，一直到50岁后才会开始下降。所以说，程序员吃的不是青春饭。只有码农，靠蛮力，用体力而不是用脑力的程序员才是吃青春饭的人。 年纪大的人是否跟不上新技术论文的作者分析了Tag，用了最近5年内比较流行的技术Tag，然后用了一套比较严谨的算法来查看那些所谓的“老程序员”是否在新技术上跟上不了，所谓跟不上，也就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是37岁以上的程序员（就是我现在的年纪）。 得到了下表：可以看到，老程序员和年轻的程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。 结论论文的结论是： 1）程序员技术能力上升是可以到50岁或60岁的。 2）老程序员在获取新技术上的能力并不比年轻的程序员差。 我的一些感受最后，我说一说我的一些感受： 这些年来的对于外企和国内感受—— 国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。 对年轻程序员的感受——国内新一代的程序员们太浮燥了。老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员。所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。","tags":[{"name":"随记","slug":"随记","permalink":"http://onethree.cn/tags/随记/"}]},{"title":"3 个在 Linux 中永久并安全删除文件和目录的方法","date":"2017-03-12T11:02:12.000Z","path":"2017/03/12/arctile_9/","text":"在大多数情况下，我们习惯于使用 Delete 键、垃圾箱或 rm 命令从我们的计算机中删除文件，但这不是永久安全地从硬盘中（或任何存储介质）删除文件的方法。 该文件只是对用户隐藏，它驻留在硬盘上的某个地方。它有可能被数据窃贼、执法取证或其它方式来恢复。 假设文件包含密级或机密内容，例如安全系统的用户名和密码，具有必要知识和技能的攻击者可以轻松地恢复删除文件的副本并访问这些用户凭证（你可以猜测到这种情况的后果）。 在本文中，我们将解释一些命令行工具，用于永久并安全地删除 Linux 中的文件。 1、 shred – 覆盖文件来隐藏内容shred 会覆盖文件来隐藏它的内容，并且也可以选择删除它。 ‘shred -zvu -n 5 passwords.list’ 在下面的命令中，选项有： ‘-z - 用零覆盖以隐藏碎片-v - 显示操作进度-u - 在覆盖后截断并删除文件-n - 指定覆盖文件内容的次数（默认值为3）’ shred – 覆盖文件来隐藏它的内容 你可以在 shred 的帮助页中找到更多的用法选项和信息： ‘Shell’ 2、 wipe – 在 Linux 中安全删除文件wipe 命令可以安全地擦除磁盘中的文件，从而不可能恢复删除的文件或目录内容。 首先，你需要安装 wipe 工具，运行以下适当的命令： ‘$ sudo apt-get install wipe [Debian 及其衍生版]$ sudo yum install wipe [基于 RedHat 的系统]’ 下面的命令会销毁 private 目录下的所有文件。 ‘wipe -rfi private/*’ 当使用下面的标志时： ‘-r - 告诉 wipe 递归地擦除子目录-f - 启用强制删除并禁用确认查询-i - 显示擦除进度’ wipe – 在 Linux 中安全擦除文件 注意：wipe 仅可以在磁性存储上可以可靠地工作，因此对固态磁盘（内存）请使用其他方法。 阅读 wipe 手册以获取其他使用选项和说明： Shell 1 $ man wipe 3、 Linux 中的安全删除工具集secure-delete 是一个安全文件删除工具的集合，它包含用于安全删除文件的 srm（secure_deletion）工具。 首先，你需要使用以下相关命令安装它： Shell 12 $ sudo apt-get install secure-delete [Debian 及其衍生版]$ sudo yum install secure-delete [基于 RedHat 的系统] 安装完成后，你可以使用 srm 工具在 Linux 中安全地删除文件和目录。 Shell 1 $ srm -vz private/* 下面是使用的选项： Shell 12 -v – 启用 verbose 模式-z – 用0而不是随机数据来擦除最后的写入 srm – 在 Linux 中安全删除文件 阅读 srm 手册来获取更多的使用选项和信息： Shell 1 $ man srm 4、 sfill -安全免费的磁盘 / inode 空间擦除器sfill 是 secure-deletetion 工具包的一部分，是一个安全免费的磁盘和 inode 空间擦除器，它以安全的方法删除可用磁盘空间中的文件。 sfill 会检查指定分区上的可用空间，并使用来自 /dev/urandom 的随机数据填充它。 以下命令将在我的根分区上执行 sfill，使用 `-v’ 选项启用 verbose 模式： Shell 1 $ sudo sfill -v /home/aaronkilik/tmp/ 假设你创建了一个单独的分区 /home 来存储正常的系统用户主目录，你可以在该分区上指定一个目录，以便在其上应用 sfill： Shell 1 $ sudo sfill -v /home/username 你可以在 sfill 的手册上看到一些限制，你也可以看到额外的使用标志和命令： Shell 1 $ man sfill 注意：secure-deletetion 工具包中的另外两个工具（sswap 和 sdmem）与本指南的范围不直接相关，但是，为了将来的使用和传播知识的目的，我们会在下面介绍它们。 5、 sswap – 安全 swap 擦除器它是一个安全的分区擦除器，sswap 以安全的方式删除 swap 分区上存在的数据。 警告：请记住在使用 sswap 之前卸载 swap 分区！ 否则你的系统可能会崩溃！ 要找到交换分区（并检查分页和交换设备/文件是否已经使用，请使用 swapon 命令），接下来，使用swapoff 命令禁用分页和交换设备/文件（使 swap 分区不可用）。 然后在（关闭的） swap 分区上运行 sswap 命令： Shell 1234 $ cat /proc/swaps$ swapon$ sudo swapoff /dev/sda6$ sudo sswap /dev/sda6 #这个命令要花费一些时间，默认要进行 38 遍擦除 sswap – 安全 swap 擦除器 阅读 sswap 的手册来获取更多的选项和信息： Shell 1 $ man sswap 6、 sdmem – 安全内存擦除器sdmem 是一个安全的内存擦除器，其设计目的是以安全的方式删除存储器（RAM）中的数据。 它最初命名为 smem，但是因为在 Debain 系统上存在另一个包 smem – 报告每个进程和每个用户的内存消耗，开发人员决定将它重命名为 sdmem。 Shell 1 $ sudo sdmem -f -v 关于更多的使用信息，阅读 sdmen 的手册： Shell 1 $ man sdmem","tags":[{"name":"Linux","slug":"Linux","permalink":"http://onethree.cn/tags/Linux/"}]},{"title":"Git 与 Repo 入门","date":"2017-02-27T12:18:33.000Z","path":"2017/02/27/arctile_8/","text":"版本控制版本控制是什么已不用在说了，就是记录我们对文件、目录或工程等的修改历史，方便查看更改历史，备份以便恢复以前的版本，多人协作。。。 一、原始版本控制最原始的版本控制是纯手工的版本控制：修改文件，保存文件副本。有时候偷懒省事，保存副本时命名比较随意，时间长了就不知道哪个是新的，哪个是老的了，即使知道新旧，可能也不知道每个版本是什么内容，相对上一版作了什么修改了，当几个版本过去后，很可能就是下面的样子了： 二、本地版本控制手工管理比较麻烦且混乱，所以出现了本地版本控制系统，记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件。比如RCS。 三、集中版本控制但是本地版本控制系统偏向于个人使用，或者多个使用的人必须要使用相同的设备，如果需要多人协作就不好办了，于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生，比如Subversion，Perforce。 在CVCS中，所有的版本数据都保存在服务器上，一起工作的人从服务器上同步更新或上传自己的修改。 但是，所有的版本数据都存在服务器上，用户的本地设备就只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。。 而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。 四、分布式版本控制针对CVCS的以上缺点，出现了分布式版本控制系统( Distributed Version Control System,简称 DVCS )，如GIT，Mercurial。 DVCS不是复制指定版本的快照，而是把所有的版本信息仓库全部同步到本地，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，所以，只要有一个用户的设备没有问题就可以恢复所有的数据。 当然，这增加了本地存储空间的占用。 GIT必须要了解GIT的原理，才能知道每个操作的意义是什么，才能更容易地理解在什么情况下用什么操作，而不是死记命令。当然，第一步是要获得一个GIT仓库。一、获得GIT仓库有两种获得GIT仓库的方法，一是在需要用GIT管理的项目的根目录执行： git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地，而不是取某一个特定版本，所以用clone而不是checkout： git clone 二、GIT中版本的保存记录版本信息的方式主要有两种： 记录文件每个版本的快照 记录文件每个版本之间的差异 GIT采用第一种方式。像Subversion和Perforce等版本控制系统都是记录文件每个版本之间的差异，这就需要对比文件两版本之间的具体差异，但是GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和。 GIT能正常工作完全信赖于这种SHA-1校验和，当一个文件的某一个版本被记录之后会生成这个版本的一个快照，但是一样要能引用到这个快照，GIT中对快照的引用，对每个版本的记录标识全是通过SHA-1校验和来实现的。 当一个文件被改变时，它的校验和一定会被改变（理论上存在两个文件校验和相同，但机率小到可以忽略不计），GIT就以此判断文件是否被修改，及以些记录不同版本。 在工作目录的文件可以处于不同的状态，比如说新添加了一个文件，GIT发觉了这个文件，但这个文件是否要纳入GIT的版本控制还是要由我们自己决定，比如编译生成的中间文件，我们肯定不想纳入版本控制。下面就来看下文件状态。 三、GIT文件操作版本控制就是对文件的版本控制，对于Linux来说，设备，目录等全是文件，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 文件状态GIT仓库所在的目录称为工作目录，这个很好理解，我们的工程就在这里，工作时也是在这里做修改。 在工作目录中的文件被分为两种状态，一种是已跟踪状态(tracked)，另一种是未跟踪状态(untracked)。只有处于已跟踪状态的文件才被纳入GIT的版本控制。如下图： 当我们往工作目录添加一个文件的时候，这个文件默认是未跟踪状态的，我们肯定不希望编译生成的一大堆临时文件默认被跟踪还要我们每次手动将这些文件清除出去。用以下命令可以跟踪文件： git add 上图中右边3个状态都是已跟踪状态，其中的灰色箭头只表示untrackedtracked的转换而不是untrackedunmodified的转换，新添加的文件肯定算是被修改过的。那么，staged状态又是什么呢？这就要搞清楚GIT的三个工作区域：本地数据（仓库）目录，工作目录，暂存区，如下图所示： git directory就是我们的本地仓库.git目录，里面保存了所有的版本信息等内容。 working driectory，工作目录，就是我们的工作目录，其中包括未跟踪文件及已跟踪文件，而已跟踪文件都是从git directory取出来的文件的某一个版本或新跟踪的文件。 staging area，暂存区，不对应一个具体目录，其时只是git directory中的一个特殊文件。 当我们修改了一些文件后，要将其放入暂存区然后才能提交，每次提交时其实都是提交暂存区的文件到git仓库，然后清除暂存区。而checkout某一版本时，这一版本的文件就从git仓库取出来放到了我们的工作目录。 文件状态的查看那么，我们怎么知道当前工作目录的状态呢？哪些文件已被暂存？有哪些未跟踪的文件？哪些文件被修改了？所有这些只需要一个命令，git status，如下图所示: GIT在这一点做得很好，在输出每个文件状态的同时还说明了怎么操作，像上图就有怎么暂存、怎么跟踪文件、怎么取消暂存的说明。 文件暂存在上图中我们可以很清楚地看到，filea未跟踪，fileb已被暂存（changes to be committed），但是怎么还有一个fileb是modified但unstaged呢？这是因为当我们暂存一从此文件时，暂存的是那一文件当时的版本，当暂存后再次修改了这个文件后就会提示这个文件暂存后的修改是未被暂存的。 接下来我们就看怎么暂存文件，其实也很简单，从上图中可以看到GIT已经提示我们了：use “git add …” to update what will be committed，通过 git add … 就可以暂存文件，跟踪文件同样是这一个命令。在这个命令中可以使用glob模式匹配，比如”file[ab]”，也可以使用”git add .”添加当前目录下的所有文件。 取消暂存文件是 git reset HEAD … 若修改了一个文件想还原修改可用 git checkout — … 查看文件修改后的差异当我们修改过一些文件之后，我们可能想查看我们都修改了什么东西，用”git status”只能查看对哪些文件做了改动，如果要看改动了什么，可以用： git diff 比如下图： —a表示修改之前的文件，+++b表示修改后的文件，上图表示在fileb的第一行后添加了一行”bb”，原来文件的第一行扩展为了修改后的1、2行。 但是，前面我们明明用”git status”看到filesb做了一些修改后暂存了，然后又修改了fileb，理应有两次修改的，怎么只有一个？ 因为”git diff”显示的是文件修改后还没有暂存起来的内容，那如果要比较暂存区的文件与之前已经提交过的文件呢，毕竟实际提交的是暂存区的内容，可以用以下命令： /dev/null表示之前没有提交过这一个文件，这是将是第一次提交，用： git diff –staged 是等效的，但GIT的版本要大于1.6.1。 再次执行”git add”将覆盖暂存区的内容。 忽略一些文件 如果有一些部件我们不想纳入版本控制，也不想在每次”git status”时看到这些文件的提示，或者很多时候我们为了方便会使用”git add .”添加所有修改的文件，这时就会添加上一些我们不想添加的文件，怎么忽略这些文件呢？ GIT当然提供了方法，只需在主目录下建立”.gitignore”文件，此文件有如下规则： 所有以#开头的行会被忽略 可以使用glob模式匹配 匹配模式后跟反斜杠（/）表示要忽略的是目录 如果不要忽略某模式的文件在模式前加”!” 比如： # 此为注释 – 将被 Git 忽略.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 移除文件当我们要删除一个文件时，我们可能就直接用GUI删除或者直接rm [file]了，但是看图： 我们需要将文件添加到暂存区才能提交，而移除文件后是无法添加到暂存区的，那么怎么移除一个文件让GIT不再将其纳入版本控制呢？上图中GIT已经给出了说明： git rm … 执行以上命令后提交就可以了，有时我们只是想将一些文件从版本控制中剔除出去，但仍保留这些文件在工作目录中，比如我们一不小心将编译生成的中间文件纳入了版本控制，想将其从版本控制中剔除出去但在工作目录中保留这些文件（不然再次编译可要花费更多时间了），这时只需要添加”–cached”参数。 如果我们之前不是通过”git rm”删除了很多文件呢？比如说通过patch或者通过GUI，如果这些文件命名没有规则，一个一个地执行”git rm”会搞死人的，这时可以用以下命令： 移动文件和移除文件一样，移动文件不可以通过GUI直接重命令或用”mv”命令，而是要用”git mv”，不然同移除文件一样你会得到如下结果： 如果要重命名文件可以使用 git mv old_name new_name 这个命令等效于 mv old_name new_name git rm old_name git add new_name 交互式暂存使用git add -i可以开启交互式暂存，如图所示，系统会列出一个功能菜单让选择将要执行的操作。 移除所有未跟踪文件 git clean [options] 一般会加上参数-df，-d表示包含目录，-f表示强制清除。 储藏-Stashing可能会遇到这样的情况，你正在一个分支上进行一个特性的开发，或者一个Bug的修正，但是这时突然有其他的事情急需处理，这时该怎么办？不可能就在这个工作进行到一半的分支上一起处理，先把修改的Copy出去？太麻烦了。这种情况下就要用到Stashing了。假如我们现在的工作目录是这样子的 此时如果想切换分支就可以执行以下命令 $ git stashSaved working directory and index state“WIP on master: 049d078 added the index file”HEAD is now at 049d078 added the index file(To restore them type “git stash apply”) 这时你会发现你的工作目录变得很干净了，就可以随意切分支进行其他事情的处理了。 我们可能不只一次进行”git stash”，通过以下命令可以查看所有stash列表 $ git stash liststash@{0}: WIP on master: 049d078 added the index filestash@{1}: WIP on master: c264051… Revert “added file_size” 当紧急事情处理完了，需要重新回来这里进行原来的工作时，只需把Stash区域的内容取出来应用到当前工作目录就行，命令就是 git stash apply 如果不基参数就应用最新的stash，或者可以指定stash的名字，如：stash@{1}，可能通过 git stash show 显示stash的内容具体是什么，同git stash apply一样，可以选择指定stash的名字。 git stash apply之后再git stash list会发现，apply后的stash还在stash列表中，如果要将其从stash列表中删除可以用 git stash drop 丢弃这个stash，stash的命令参数都可选择指定stash名字，否则就是最新的stash。 一般情况下apply stash后应该就可以把它从stash列表删除了，先apply再drop还是比较繁琐的，使用以下一条命令就可以同时完成这两个操作 git stash pop 如果我们执行git stash时工作目录的状态是部分文件已经加入了暂存区，部分文件没有，当我们执行git stash apply之后会发现所有文件都变成了未暂存的，如果想维持原来的样子操持原来暂存的文件仍然是暂存状态，可以加上–index参数 git stash apply –index 还有这么一种情况，我们把原来的修改stash了，然后修复了其他一些东西并进行了提交，但是，这些提交的文件有些在之前已经被stash了，那么git stash apply时就很可能会遇到冲突，这种情况下就可以在stash时所以提交的基础上新建一个分支，然后再apply stash，当然，这两个步骤有一人简单的完成方法 git stash branch 四、提交与历史了解了文件的状态，我们对文件进行了必要的修改后，就要把我们所做的修改放入版本库了，这样以后我们就可以在需要的时候恢复到现在的版本，而要恢复到某一版，一般需要查看版本的历史。 提交提交很简单，直接执行”git commit”。执行git commit后会调用默认的或我们设置的编译器要我们填写提示说明，但是提交说明最好按GIT要求填写：第一行填简单说明，隔一行填写详细说明。因为第一行在一些情况下会被提取使用，比如查看简短提交历史或向别人提交补丁，所以字符数不应太多，40为好。下面看一下查看提交历史。 查看提交历史查看提交历史使用如下图的命令 如图所示，显示了作者，作者邮箱，提交说明与提交时间，”git log”可以使用放多参数，比如： 仅显示最新的1个log，用”-n”表示。 显示简单的SHA-1值与简单提交说明，oneline仅显示提交说明的第一行，所以第一行说明最好简单点方便在一行显示。 “git log –graph”以图形化的方式显示提交历史的关系，这就可以方便地查看提交历史的分支信息，当然是控制台用字符画出来的图形。 “git log”的更多参数可以查看命令帮助。 不经过暂存的提交如果我们想跳过暂存区直接提交修改的文件，可以使用”-a”参数，但要慎重，别一不小心提交了不想提交的文件 git commit -a 如果需要快捷地填写提交说明可使用”-m”参数 git commit -m ‘commit message’ 修订提交如果我们提交过后发现有个文件改错了，或者只是想修改提交说明，这时可以对相应文件做出修改，将修改过的文件通过”git add”添加到暂存区，然后执行以下命令： git commit –amend 然后修改提交说明覆盖上次提交，但只能重写最后一次提交。 重排提交通过衍合(rebase)可以修改多个提交的说明，并可以重排提交历史，拆分、合并提交，关于rebase在讲到分支时再说，这里先看一下重排提交。 假设我们的提交历史是这样的： 如果我们想重排最后两个提交的提交历史，可以借助交互式rebase命令： git rebase -i HEAD~2 或 git rebase -i 3366e1123010e7d67620ff86040a061ae76de0c8 HEAD~2表示倒数第三个提交，这条命令要指定要重排的最旧的提交的父提交，此处要重排Second commit与Third commit，所以要指定Initial commit的Commit ID。如图所示： 注释部分详细说明了每个选项的作用，如果我们想交互这两个提交，只需把开头的这两行交换下位置就OK了，交换位置后保存，然后看下提交历史： 可以看到提交历史已经变了，而且最新的两个提交的Commit ID变了，如果这些提交已经push到了远程服务器，就不要用这个命令了。 删除提交与修改提交说明如果要删除某个提交，只需要删除相应的行就可以了，而要修改某个提交的提交说明的话，只需要把相应行的pick改为reward。 合并提交-squashing合并提交也很简单，从注释中的说明看，只需要把相应的行的pick改为squash就可以把这个提交全并到它上一行的提交中。 拆分提交至于拆分提交，由于Git不可能知道你要做哪里把某一提交拆分开，把以我们就需要让Git在需要拆分的提交处停下来，由我们手动修改提交，这时要把pick改为edit，这样Git在处理到这个提交时会停下来，此时我们就可以进行相应的修改并多次提交来拆分提交。 撤销提交前面说了删除提交的方法，但是如果是多人合作的话，如果某个提交已经Push到远程仓库，是不可以用那种方法删除提交的，这时就要撤销提交 git revert 这条命令会把指定的提交的所有修改回滚，并同时生成一个新的提交。 Resetgit reset会修改HEAD到指定的状态，用法为 git reset [options] 这条命令会使HEAD提向指定的Commit，一般会用到3个参数，这3个参数会影响到工作区与暂存区中的修改： –soft: 只改变HEAD的State，不更改工作区与暂存区的内容 –mixed(默认): 撤销暂存区的修改，暂存区的修改会转移到工作区 –hard: 撤销工作区与暂存区的修改 cherry-pick当与别人和作开发时，会向别人贡献代码或者接收别人贡献的代码，有时候可能不想完全Merge别人贡献的代码，只想要其中的某一个提交，这时就可以使用cherry-pick了。就一个命令 git cherry-pick filter-branch这条命令可以修改整个历史，如从所有历史中删除某个文件相关的信息，全局性地更换电子邮件地址。 五、GIT分支分支被称之为GIT最强大的特性，因为它非常地轻量级，如果用Perforce等工具应该知道，创建分支就是克隆原目录的一个完整副本，对于大型工程来说，太费时费力了，而对于GIT来说，可以在瞬间生成一个新的分支，无论工程的规模有多大，因为GIT的分支其实就是一指针而已。在了解GIT分支之前，应该先了解GIT是如何存储数据的。 前面说过，GIT存储的不是文件各个版本的差异，而是文件的每一个版本存储一个快照对象，然后通过SHA-1索引，不只是文件，包换每个提交都是一个对象并通过SHA-1索引。无论是文本文件，二进制文件还是提交，都是GIT对象。 GIT对象每个对象(object) 包括三个部分：类型，大小和内容。大小就是指内容的大小，内容取决于对象的类型，有四种类型的对象：”blob”、”tree”、 “commit” 和”tag”。 “blob”用来存储文件数据，通常是一个文件。 “tree”有点像一个目录，它管理一些“tree”或是 “blob”（就像文件和子目录） 一个“commit”指向一个”tree”，它用来标记项目某一个特定时间点的状态。它包括一些关于时间点的元数据，如提交时间、提交说明、作者、提交者、指向上次提交（commits）的指针等等。 一个“tag”是来标记某一个提交(commit) 的方法。 比如说我们执行了以下代码进行了一次提交： $ git add README test.rb LICENSE2$ git commit -m ‘initial commit of my project’ 现在,Git 仓库中有五个对象:三个表示文件快照内容的 blob 对象;一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象;以及一个包含指向 tree 对象(根目录)的索引和其他提交信息元数据的 commit 对象。概念上来说,仓库中的各个对象保存的数据和相互关系看起来如下图： 如果进行多次提交，仓库的历史会像这样： 分支引用所谓的GIT分支，其实就是一个指向某一个Commit对象的指针，像下面这样，有两个分支，master与testing： 而我们怎么知道当前在哪一个分支呢？其实就是很简单地使用了一个名叫HEAD的指针，如上图所示。HEAD指针的值可以为一个SHA-1值或是一个引用，看以下例子： git的所有版本信息都保存了Working Directory下的.git目录，而HEAD指针就保存在.git目录下，如上图所有，目前为止已经有3个提交，通过查看HEAD的值可以看到我们当前在master分支：refs/heads/master，当我们通过git checkout取出某一特定提交后，HEAD的值就是成了我们checkout的提交的SHA-1值。 记录我们当前的位置很简单，就是能过HEAD指针，HEAD指向某一提交的SHA-1值或是某一分支的引用。 新建分支 git branch 有时需要在新建分支后直接切换到新建的分支，可以直接用checkout的-b选项 git checkout -b 删除分支 git branch -d 如果在指定的分支有一些unmerged的提交，删除分支会失败，这里可以使用-D参数强制删除分支。 git branch -D 检出分支或提交检出某一分支或某一提交是同一个命令 git checkout | 分支合并(merge)当我们新建一个分支进行开发，并提交了几次更新后，感觉是时候将这个分支的内容合回主线了，这是就可以取出主线分支，然后把分支的更新merge回来： git checkout master git merge testing 如果master分支是testing分支的直接上游，即从master延着testing分支的提交历史往前走可以直接走到testing分支的最新提交，那么系统什么也不需要做，只需要改变master分支的指针即可，这被称之为”Fast Forward”。 但是，一般情况是这样的，你取出了最新的master分支，比如说master分支最新的提交是C2（假设共3次提交C0 merge后的提交是按时间排序的，比如下图，我们在rename提交处新建分支test，在test上提交Commit from branch test，然后回到master提交commit in master after committing in branch，再将test分支merge进master，这时看提交提交历史，Commit from branch test是在commit in master…之前的，尽管在master上我们是在rename的基础上提交的commit in master…而GIT会在最后添加一个新的提交（Merge branch ‘test’）表示我们在此处将一个分支merge进来了。 这种情况会有一个问题，比如说在rename提交处某人A从你这里Copy了一个GIT仓库，然后你release了一个patch（通过git format-patch）给A，这时候test分支还没有merge进来，所以patch中只包含提交：commit in master…然后你把test分支merge了进来又给了A一个patch，这个patch会包含提交：Commit from branch test，而这个patch是以rename为base的，如果commit in master…和Commit from branch test修改了相同的文件，则第二次的patch可能会打不上去，因为以rename为base的patch可能在新的Code上找不到在哪个位置应用修改。 分支衍合(rebase)有两种方法将一个分支的改动合并进另一个分支，一个就是前面所说的分支合并，另一个就是分支衍合，这两种方式有什么区别呢？ 分支合并（merge）是将两个分支的改动合并到一起，并生成一个新的提交，提交历史是按时间排序的，即我们实际提交的顺序，通过git log –graph或一些图形化工具，可能很明显地看到分支的合并历史，如果分支比较多就很混乱，而且如果以功能点新建分支，等功能点完成后合回主线，由于merge后提交是按提交时间排序的，提交历史就比较乱，各个功能点的提交混杂在一起，还可能遇到上面提到的patch问题。 而分支衍合（rebase）是找到两个分支的共同祖先提交，将要被rebase进来的分支的提交依次在要被rebase到的分支上重演一遍，即回到两个分支的共同祖先，将branch（假如叫experiment）的每次提交的差异保存到临时文件里，然后切换到要衍合入的分支（假如是master），依次应用补丁文件。experiment上有几次提交，在master就生成几次新的提交，而且是连在一起的，这样合进主线后每个功能点的提交就都在一起，而且提交历史是线性的 对比merge与rebase的提交历史会是下图这样的（图来自Pro-GIt）： rebase后C3提交就不存在了，取而代之的是C3’，而master也成为了experiment的直接上游，只需一次Fast Forward（git merge）后master就指向了最新的提交，就可以删除experiment分支了。 衍合–onto git rebase –onto master server client 这条命令的意思是：检出server分支与client分支共同祖先之后client上的变化，然后在master上重演一遍。 父提交HEAD表示当前所在的提交，如果要查看当前提交父提交呢？git log查看提交历史，显然太麻烦了，而且输入一长串的Commit-ID也不是一个令人愉悦的事。这时可借助两个特殊的符号：~与^。 ^ 表示指定提交的父提交，这个提交可能由多个交提交，^之后跟上数字表示第几个父提交，不跟数字等同于^1。 ~n相当于n个^，比如~3=^^^，表示第一个父提交的第一个父提交的第一个父提交。 远程分支远程分支以(远程仓库名)/(分支名)命令，远程分支在本地无法移动修改，当我们clone一个远程仓库时会自动在本地生成一个名叫original的远程仓库，下载远程仓库的所有数据，并新建一个指向它的分支original/master，但这个分支我们是无法修改的，所以需要在本地重新一个分支，比如叫master，并跟踪远程分支。 Clone了远程仓库后，我们还会在本地新建其他分支，并且可能也想跟踪远程分支，这时可以用以下命令： git checkout -b [branch_name] –track|-t / 和新建分支的方法一样，只是加了一个参数–track或其缩写形式-t，可以指定本地分支的名字，如果不指定就会被命名为remote-branch。 要拉取某个远程仓库的数据，可以用git fetch: git fetch 当拉取到了远程仓库的数据后只是把数据保存到了一个远程分支中，如original/master，而这个分支的数据是无法修改的，此时我们可以把这个远程分支的数据合并到我们当前分支 git merge / 如果当前分支已经跟踪了远程分支，那么上述两个部分就可以合并为一个 git pull 当在本地修改提交后，我们可能需要把这些本地的提交推送到远程仓库，这里就可以用git push命令，由于本地可以由多个远程仓库，所以需要指定远程仓库的名字，并同时指定需要推的本地分支及需要推送到远程仓库的哪一个分支 git push : 如果本地分支与远程分支同名，命令可以更简单 git push 等价于 git push refs/heads/:refs/for/ 如果本地分支的名字为空，可以删除远程分支。 前面说过可以有不止一个远程分支f，添加远程分支的方法为 git remote add 六、标签-tag作为一个版本控制工具，针对某一时间点的某一版本打tag的功能是必不可少的，要查看tag也非常简单，查看tag使用如下命令 git tag 参数”-l”可以对tag进行过滤 git tag -l “v1.1.*” Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。 轻量级标签只需在git tag后加上tag的名字，如果tag名字 git tag &lt;tag_name&gt; 含附注的标签需要加上参数-a（annotated），同时加上-m跟上标签的说明 git tag -a &lt;tag_name&gt; -m “&lt;tag_description&gt;” 如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s（signed） 查看标签的内容用 git show &lt;tag_name&gt; 验证已签署的标签用-v（verify） git tag -v &lt;tag_name&gt; 有时在某一个版本忘记打tag了，可以在后期再补上，只需在打tag时加上commit-id 要将tag推送到远程服务器上，可以用 git push &lt;tag_name&gt; 或者可以用下面的命令推送所有的tag git push –tags 七、Git配置使用”git config”可以配置Git的环境变量，这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global选项，读写的就是这个文件。 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖/etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:Documents and Settings$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 最基础的配置是配置git的用户，用来标识作者的身份 git config –global user.name git config –global user.email 文本编辑器也可以配置，比如在git commit的时候就会调用我们设置的文本编辑器 git config –global core.editor vim 另一个常用的是diff工具，比如我们想用可视化的对比工具 git config –global merge.tool meld 要查看所有的配置，可以用 git config –list 或者可以在git config后加上配置项的名字查看具体项的配置 git config user.name 作为一个懒人，虽然checkout、status等命令只是一个单词，但是还是嫌太长了，我们还可以给命令设置别名如 git config –global alias.co checkout 这样git co就等于git checkout 前面说地，git配置项都保存在那3个文件里，可以直接打开相应的配置文件查看配置，也可以直接修改这些配置文件来配置git，想删除某一个配置，直接删除相应的行就行了 八、其他关于GIT各命令的说明可以查看相关帮助文档，通过以下方法： git help 或git –help REPO repo start &lt;topic_name&gt; 开启一个新的主题，其实就是每个Project都新建一个分支。 repo init -u [OPTIONS] 在当前目录下初始化repo，会在当前目录生生成一个.repo目录，像Git Project下的.git一样，-u指定url，可以加参数-m指定manifest文件，默认是default.xml，.repo/manifests保存manifest文件。.repo/projects下有所有的project的数据信息，repo是一系列git project的集合，每个git project下的.git目录中的refs等目录都是链接到.repo/manifests下的。 repo manifest 可以根据当前各Project的版本信息生成一个manifest文件 repo sync [PROJECT1…PROJECTN] 同步Code。 repo status 查看本地所有Project的修改，在每个修改的文件前有两个字符，第一个字符表示暂存区的状态。 – no change same in HEAD and index A added not in HEAD, in index M modified in HEAD, modified in index D deleted in HEAD, not in index R renamed not in HEAD, path changed in index C copied not in HEAD, copied from another in index T mode changed same content in HEAD and index, mode changed U unmerged conflict between HEAD and index; resolution required 每二个字符表示工作区的状态 letter meaning description – new/unknown not in index, in work tree m modified in index, in work tree, modified d deleted in index, not in work tree repo prune 删除已经merge的分支 repo abandon 删除分支，无论是否merged repo branch或repo branches 查看所有分支 repo diff 查看修改 repo upload 上传本地提交至服务器 repo forall [PROJECT_LIST]-c COMMAND 对指定的Project列表或所有Project执行命令COMMAND，加上-p参数可打印出Project的路径。 repo forall -c ‘git reset –hard HEAD;git clean -df;git rebase –abort’ 这个命令可以撤销整个工程的本地修改。","tags":[{"name":"git","slug":"git","permalink":"http://onethree.cn/tags/git/"},{"name":"repo","slug":"repo","permalink":"http://onethree.cn/tags/repo/"}]},{"title":"SVG 线条动画入门","date":"2017-02-17T13:09:22.000Z","path":"2017/02/17/arctile_7/","text":"通常我们说的 Web 动画，包含了三大类。 CSS3 动画 javascript 动画（canvas） html 动画（SVG） 个人认为 3 种动画各有优劣，实际应用中根据掌握情况作出取舍，本文讨论的是我认为 SVG 中在实际项目中非常有应用价值 SVG 线条动画。 举个栗子SVG 线条动画，在一些特定的场合下可以解决使用 CSS 无法完成的动画。尤其是在进度条方面，看看最近项目里的一个小需求，一个这种形状的进度条： 把里面的进度条单独拿出来，也就是需要实现这样一个效果： 脑洞大开一下，使用 CSS3 如何实现这样一个进度条呢。 CSS3 是可以做到的，就是很麻烦。但是如果采用 SVG 的话，迎刃而解。 我们假定你在阅读本文的时候有了一定的 SVG 基础，上面代码看看就懂了，好了，本文到此结束。 好吧，还是一步一步解释，上面进度条的主要 SVG 代码如下： ‘ ‘ SVG 为何可缩放矢量图形，即SVG，是W3C XML的分枝语言之一，用于标记可缩放的矢量图形。（摘自MDN） 上面代码中，先谈谈 svg 标签： version： 表示 的版本，目前只有 1.0，1.1 两种 xmlns：http://www.w3.org/2000/svg 固定值 xmlns:xlink：http://www.w3.org/1999/xlink 固定值 xml:space：preserve 固定值，上述三个值固定，表示命名空间，当数据单独存在svg文件内时，这3个值不能省略 class：就是我们熟悉的 class width | height： 定义 svg 画布的大小 viewbox： 定义了画布上可以显示的区域，当 viewBox 的大小和 svg 不同时，viewBox 在屏幕上的显示会缩放至 svg 同等大小（暂时可以不用理解） 有了 svg 标签，我们就可以愉快的在内部添加 SVG 图形了，上面，我在 svg 中定义了两个 polyline 标签。 ## SVG 基本形状polyline：是SVG的一个基本形状，用来创建一系列直线连接多个点。 其实，polyline 是一个比较不常用的形状，比较常用的是path，rect，circle 等。这里我使用polyline 的原因是需要使用 stroke-linejoin 和 stroke-linecap 属性，在线段连接处创建圆滑过渡角。 SVG 中定义了一些基本形状，在继续下文之前，建议点进去先了解一些基本图形的标签及写法： ## SVG 线条动画好，终于到本文的重点了。 上面，我们给两个 polyline 都设置了 class，SVG 图形的一个好处就是部分属性样式可以使用 CSS 的方式书写，更重要的是可以配合 CSS 动画一起使用。 上面，主要的 CSS 代码： ‘.g-rect-path{ fill: none; stroke-width:10; stroke:#d3dce6; stroke-linejoin:round; stroke-linecap:round;} .g-rect-fill{ fill: none; stroke-width:10; stroke:#ff7700; stroke-linejoin:round; stroke-linecap:round; stroke-dasharray: 0, 1370; stroke-dashoffset: 0; animation: lineMove 2s ease-out infinite;} @keyframes lineMove { 0%{ stroke-dasharray: 0, 1350; } 100%{ stroke-dasharray: 1350, 1350; }}’ 这尼玛是什么 CSS？怎么除了 animation 全都不认识？ 莫慌，其实很多和 CSS 对比一下非常好理解，只是换了个名字： fill：类比 css 中的 background-color，给 svg 图形填充颜色； stroke-width：类比 css 中的 border-width，给 svg 图形设定边框宽度； stroke：类比 css 中的 border-color，给 svg 图形设定边框颜色； stroke-linejoin | stroke-linecap：上文稍微提到过，设定线段连接处的样式； stroke-dasharray：值是一组数组，没数量上限，每个数字交替表示划线与间隔的宽度； stroke-dashoffset：则是虚线的偏移量 重点讲讲能够实现线条动画的关键属性 stroke-dasharray 。 属性 stroke-dasharray 可控制用来描边的点划线的图案范式。 它是一个和数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2。 解释很苍白，直接看例子： See the Pen stroke-dasharray by Chokcoco (@Chokcoco) on CodePen. 上面，填充进度条，使用了下面这个动画 ： ‘@keyframes lineMove { 0%{ stroke-dasharray: 0, 1350; } 100%{ stroke-dasharray: 1350, 1350; }}’ stroke-dasharray: 0, 1350;，表示线框短划线和缺口的长度分别为 0 和 1350，所以一开始整个图形都是被缺口占据，所以在视觉效果上长度为 0。 然后过渡到 stroke-dasharray: 1350, 1350，表示线框短划线和缺口的长度分别为 1350 和 1350，因为整个图形的长度就是 1350，所以整个进度条会被慢慢填充满。 掌握了这个技巧后，就可以使用 stroke-dasharray 和 stroke-dashoffset 制作很多不错的交互场景： SVG 线条动画实现按钮交互 SVG 线条动画实现圆形进度条多 SVG 图形线条动画配合之前我司一个 h5 里面应用过的，多SVG 图形线条动画配合，可以制作一些比较酷炫的动画，很有科技感。 正文结束，我在我的 Github 上，使用 SVG 实现了一些图形 — SVG奇思妙想，Demo可以戳这里。 下篇文章将会详述非规则图形，如何使用 PS + AI 生成 path 路径，实现 SVG 动画，放个 Demo，敬请期待。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://onethree.cn/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://onethree.cn/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://onethree.cn/tags/HTML/"}]},{"title":"为什么程序员一定要会用Google和Stack Overflow？","date":"2017-01-10T05:58:22.000Z","path":"2017/01/10/arctile_13/","text":"内容简介 前言 为什么用Google不用百度 为什么用Stack Overflow 小结 前言 下文中，谷歌统一用Google表示。 作为程序员，用Google比用百度更节省时间，此话不假。 虽说我离编程大牛还相距甚远，但是： 这些年编程的一个很深的感触就是：95%的问题都可以在Google和Stack Overflow找到答案。 真的能达到95%吗？达不到怎么办呢？ 我觉得很多时候不是Google或Stack Overflow的问题，而是不少朋友不太懂得如何快速有效地搜索到有用的信息，可以参看下面这篇知乎的帖子： 如何用好谷歌等搜索引擎？ 相比于国内的小伙伴们用Google需要“番茄”， 在国外确实相对便利，因此我平时基本不用百度，只有很难得才会用百度来查一些资料。 Stack Overflow网站的jquery需要跨域调用Google Javascript API，网站顶部总会提示”Stack Overflow requires external JavaScript from another domain, which is blocked or failed to load” ，Google”躺枪”后Stack Overflow也被拉下水了。 下面两个值得一看： Stormzhang的文章：你为什么一定要使用 Google ？ 知乎上的讨论：如何优雅地使用 Stack Overflow？ 不过， 要能在Google和Stack Overflow“畅游”， 还需要比较良好的英语， 因为很多好的资料是英语的， 很多API只有英语解释， 等等。 为什么用Google不用百度 一言不合就用Google！ 首先，百度是一个以中文信息为主要对象的搜索引擎， 因此对于因为英语信息的收录量和收录精确性就差很多。 但是作为程序员，我们如果不会英语，是会错过很多好资源与好的学习机会的，可以参看一下我这篇文章：对于程序员, 为什么英语比数学更重要? 如何学习 不过百度也是有其用途的，比如查找一些中文资源的时候。 百度比之Google还有很多劣势： 用百度，第一屏的结果往往充斥着广告。而且不少都是用金钱买来的广告位。虽然Google也有广告位，但相比百度还是有良心很多的。相信经过不少的事件，例如魏泽西，大家对百度已经诟病不少了。 百度的界面比Google难看：是的，作为“视觉生物”，要我在Google的界面和百度的界面之间选择，我会毫不犹豫选择前者。 假如不是在国内，那么Google的速度是很快的，因为世界各地有很多Google的集成服务器。 对于“android学习”，Google的搜索结果 对于“android学习”，百度的搜索结果 可以感觉出来，Google的搜索结果很清爽，而且“直击要害”；百度的结果有不少并不是我们想要的，你还需要自己甄别，很麻烦。 更可怕的是，我都开了Chrome上屏蔽广告的插件，百度的搜索结果第一页第一个竟然还是广告！ 当然了，Google也不是没有缺陷的。不过，人生短暂，我用Google。 我当年刚开始接触编程的时候，也不怎么用Google，基本都是“百度之”。但是我渐渐发现，百度的标语“百度一下，你就知道”，其实应该更正为“百度一下，也许你就更不知道了”。 最后， 假如你不信我说的，可以试用一下Google。 不过，友情提示：到时候，你爱上Google，不能自拔的，每天不用一下Google搜索就“不爽不舒服斯基”的时候，不要来找我“算账”。 为什么用Stack Overflow 如果说Google对于非程序员也很有用，那Stack Overflow就基本是极客的选择了。 什么是Stack Overflow ？ Stack是英语“栈”的意思，Overflow是英语“溢出”的意思，因此Stack Overflow的直译就是“栈溢出”。 栈溢出是缓冲区溢出的一种。由于缓冲区溢出而使得有用的存储单元被改写,往往会引发不可预料的后果。程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区。如果向缓冲区中写入超过其本身长度的数据，以致于缓冲区无法容纳，就会造成缓冲区以外的存储单元被改写，这种现象就称为缓冲区溢出。缓冲区​长度一般与用户自己定义的缓冲变量的类型有关。 老外就是喜欢取别具一格的名字～ Stack Overflow简单来说是一个IT技术问答网站。其实网站本身技术实现并不是很难，国内也有模仿者，例如https://segmentfault.com/ Stack Overflow 由 Jeff Atwood 和 Joel Spolsky 这两个非常著名的 Blogger 在 2008 年创建，7月小范围的进行 Beta 测试，直到 9 月份才开始公开的 Beta 测试。Stack Overflow 面向编程人员群体。到2010年年末，Stack Overflow 单个站点在 Alexa 的Rank 是 160 ，月度独立访客超过 1600 万，每月Page View 超过 7200 万 (refer)。Stack Exchange Network 在 2010 年 5 月接受了来自 Union Square Ventures 的 600 万美元的投资，在 2010 年扩大并完善了整个团队，从三个全职工程师发展到了 20 多人的队伍，搬进了 7500 平方英尺的豪华装修的办公室（当然每个人都坐着1000美元一把的椅子）。之后，发展就算比较顺利。 但是，Stack Overflow之所以成功，因为： 整个圈子氛围不错 问答基数大 回复及时 大牛很多 基于英语 问题审核严格 基本你想得到的编程知识点在上面都有相关问题 可以看一下知乎的这篇帖子：国内为什么没有好的 Stack Overflow 的模仿者？ 这些年，很多编程难题，我都是先Google，然后Google会很优先地把结果导向到Stack Overflow，我在Stack Overflow可以很容易找到解决我的问题的答案。有些问题甚至很偏门，但是Stack Overflow还是有解决办法，简直神器！ 小结 至于Google和Stack Overflow的组合对于程序员的助力有多大，那你必须使用了才能体会到啊。如果需要“番茄”，那还是去买付费的VPN比较好，毕竟“便宜没好货”。 像我这么“耿直”的人，怎么会坑您呢？对吧～ – 转载至简书作者 谢恩铭","tags":[{"name":"google","slug":"google","permalink":"http://onethree.cn/tags/google/"},{"name":"stack overflow","slug":"stack-overflow","permalink":"http://onethree.cn/tags/stack-overflow/"}]},{"title":"Vim 起步的五个技巧","date":"2017-01-02T05:02:22.000Z","path":"2017/01/02/arctile_5/","text":"​ 多年来，我一直想学 Vim。如今 Vim 是我最喜欢的 Linux 文本编辑器，也是开发者和系统管理者最喜爱的开源工具。我说的学习，指的是真正意义上的学习。想要精通确实很难，所以我只想要达到熟练的水平。我使用了这么多年的 Linux ，我会的也仅仅只是打开一个文件，使用上下左右箭头按键来移动光标，切换到插入模式，更改一些文本，保存，然后退出。 但那只是 Vim 的最最基本的操作。我的技能水平只能让我在终端使用 Vim 修改文本，但是它并没有任何一个我想象中强大的文本处理功能。这样我完全无法用 Vim 发挥出胜出 Pico 和 Nano 的能力。 所以到底为什么要学习 Vim？因为我花费了相当多的时间用于编辑文本，而且我知道还有很大的效率提升空间。为什么不选择 Emacs，或者是更为现代化的编辑器例如 Atom？因为 Vim 适合我，至少我有一丁点的使用经验。而且，很重要的一点就是，在我需要处理的系统上很少碰见没有装 Vim 或者它的弱化版（Vi）。如果你有强烈的欲望想学习对你来说更给力的 Emacs，我希望这些对于 Emacs 同类编辑器的建议能对你有所帮助。 花了几周的时间专注提高我的 Vim 使用技巧之后，我想分享的第一个建议就是必须使用它。虽然这看起来就是明知故问的回答，但事实上它比我所预想的计划要困难一些。我的大多数工作是在网页浏览器上进行的，而且每次我需要在浏览器之外打开并编辑一段文本时，就需要避免下意识地打开 Gedit。Gedit 已经放在了我的快速启动栏中，所以第一步就是移除这个快捷方式，然后替换成 Vim 的。 为了更好的学习 Vim，我尝试了很多。如果你也正想学习，以下列举了一些作为推荐。 Vimtutor通常如何开始学习最好就是使用应用本身。我找到一个小的应用叫 Vimtutor，当你在学习编辑一个文本时它能辅导你一些基础知识，它向我展示了很多我这些年都忽视的基础命令。Vimtutor 一般在有 Vim 的地方都能找到它，如果你的系统上没有 Vimtutor，Vimtutor 可以很容易从你的包管理器上安装。 GVim我知道并不是每个人都认同这个，但就是它让我从使用终端中的 Vim 转战到使用 GVim 来满足我基本编辑需求。反对者表示 GVim 鼓励使用鼠标，而 Vim 主要是为键盘党设计的。但是我能通过 GVim 的下拉菜单快速找到想找的指令，并且 GVim 可以提醒我正确的指令然后通过敲键盘执行它。努力学习一个新的编辑器然后陷入无法解决的困境，这种感觉并不好受。每隔几分钟读一下 man 出来的文字或者使用搜索引擎来提醒你该用的按键序列也并不是最好的学习新事物的方法。 键盘表当我转战 GVim，我发现有一个键盘的“速查表”来提醒我最基础的按键很是便利。网上有很多这种可用的表，你可以下载、打印，然后贴在你身边的某一处地方。但是为了我的笔记本键盘，我选择买一沓便签纸。这些便签纸在美国不到 10 美元，当我使用键盘编辑文本，尝试新的命令的时候，可以随时提醒我。 Vimium上文提到，我工作都在浏览器上进行。其中一条我觉得很有帮助的建议就是，使用 Vimium 来用增强使用 Vim 的体验。Vimium 是 Chrome 浏览器上的一个开源插件，能用 Vim 的指令快捷操作 Chrome。我发现我只用了几次使用快捷键切换上下文，就好像比之前更熟悉这些快捷键了。同样的扩展 Firefox 上也有，例如 Vimerator。 其它人毫无疑问，最好的学习方法就是求助于在你之前探索过的人，让他给你建议、反馈和解决方法。 如果你住在一个大城市，那么附近可能会有一个 Vim meetup 小组，或者还有 Freenode IRC 上的 #vim 频道。#vim 频道是 Freenode 上最活跃的频道之一，那上面可以针对你个人的问题来提供帮助。听上面的人发发牢骚或者看看别人尝试解决自己没有遇到过的问题，仅仅是这样我都觉得很有趣。 那么，现在怎么样了？到现在为止还不错。为它所花的时间是否值得就在于之后它为你节省了多少时间。但是当我发现一个新的按键序列可以来跳过词，或者一些相似的小技巧，我经常会收获意外的惊喜与快乐。每天我至少可以看见，一点点的回报，正在逐渐配得上当初的付出。 学习 Vim 并不仅仅只有这些建议，还有很多。我很喜欢指引别人去 Vim Advantures，它是一种使用 Vim 按键方式进行移动的在线游戏。而在另外一天我在 Vimgifts.com 发现了一个非常神奇的虚拟学习工具，那可能就是你真正想要的：用一个小小的 gif 动图来描述 Vim 操作。 你有花时间学习 Vim 吗？或者是任何需要大量键盘操作的程序？那些经过你努力后掌握的工具，你认为这些努力值得吗？效率的提高有没有达到你的预期？分享你们的故事在下面的评论区吧。","tags":[{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"编辑器之战:Vim 的复仇","date":"2016-12-22T08:03:22.000Z","path":"2016/12/22/arctile_4/","text":"​ 我极少在这些网页上读到如此无聊的报道！Al Williams的一篇关于“Emacs 和Vim之战”的报道，并不合我们Hackaday的口味。本着“不偏不倚”的精神，他用七句话概率了Vim编辑器。仅仅七句！我顿时怒气冲天。 正如你们大多数人一样，Al认为他“懂得如果使用vi”。实话告诉你，其实他并不懂。除非你独自在只有食物、饮料、笔记本 和VimGolf在喜马拉雅山脉的一个高高的洞穴里生活几年，否则你不会懂如何使用vi。我并不自认为精通Vim，但我仍将用Vim撰文真情吐露我对它的溢美之词。 我写本文并不是为了延续“vi和Emacs之战”。那种想法很愚蠢。而且极有可能是Emacs用户们编造出来用来抢vi的风头的。你懂得，“vi和Emacs之战”话题的讨论是为了转移读者注意力。Vi和vim以及你用的其他编辑器有如此大的差异和不同，以至于拿Emacs来作无聊的对比：它仅仅是一个具备良好拓展性能的普通编辑器，可怕的组合键也都可能导致腕管综合征，代码膨胀可以比肩Microsoft Word。如果你能熟练使用Pico 、Nano 、 Joe、 Notepad++ 、 Gedit 、 Kate中的任一款或者任何其它的编辑器。你在一个月左右的时间就可以熟练使用Emacs，它无非是另外一款编辑器。 Vi却与此不同。它是一个伪装成编辑器的用来编辑文本的一种编程语言。如果你像普通文本编辑器那样用它，你会觉得很遭罪。但是如果你能将繁杂的文本编辑像封装代码到方法中时，你才真正开始理解Vi. 模式和移动 正如Al所指出的那样，vi和Vim都使用了模式的概念。键入文本时有一种“插入模式”，在普通编辑器里，这种模式是默认开启的。用我们使用Vim编辑时，大多数时间是在“普通模式”(按键像命令一样)，如移动鼠标、剪切、粘贴、查找、替换、编写宏命令、将一个html标签转换成另外一个以及普通编辑。 当你开始用Vim时，它会提醒你键入:help 以及给你展示教程，教你怎样通过鼠标进行操作。你应该按照按照它的提示进行操作，那就是它存在的意义。它不会让你精通它但是你将能够学到基本的使用方法。在这时，不要到处宣扬你“懂如何用Vim”。那会使你看起来很傻。你将学会如何通过鼠标进行操作、剪切、粘贴、输入和编辑文本。简而言之，你将像Emacs一样编辑： 一个猴子 。 文本编辑编程Vim的神秘之处在于它普通模式时使用一种介于自然语言和编程语言中间的语言。 它包含动词（方法）、形容词（修饰语）、和名词（对象）。输入c命令代表“编辑”某些文本。但是仅仅输入一个c不起作用，因为它还需要一个对象。但如果你输入caw（“修改一个单词”），光标所选中的单词将被删除，Vim进入插入模式，等待你键入单词的替换词，通过按Esc键（退出键）就可以返回普通模式。如果你想编辑整句，输入cas来删除它然后然后输入新句子即可。想改变C函数括号内的所有参数吗？ci)“改变括号内的内容”. (ca)删除整体，括号和所有。数字也同样适用。通过c**5w**命令可以修改后面的5个单词。就Vim的语法是模块化且可拓展的角度而言，它还是挺容易学的。 以上那些只是雕虫小技。.命令才是亮点。编辑动作的阶段性重复构成了一个单元。所以如果你仅仅想把一个单词改为“Hackaday”后返回到普通模式，就把光标移动到那个单词上键入cawHackaday后再按.键就可将其修改为“Hackaday”。将移动命令也加入其中，w命令将光标移动到下一个单词的开头。现在如果交换.和w那么文档中所有单词都会变成“Hackaday”。只需要按两个键。试想一下如果杰克·尼克尔逊在《闪灵》中用Vim和.命令写作，那该多高效啊。 虽然听起来好像不是特别实用，但是想想有多少次你需要把所有“foo()”方法替换为“getFooInstantanceMethod()”方法就不难理解了。 当然了在Vim中那只是很“普通”的搜索和替换方法，但是其实大多数情况下你没必要那样做。为啥呢？因为/foo搜索“foo”而且caw将修改光标选中的单词。 通过;可以实现搜索的可重复性。在搜索和替换部分（几乎）同时是任意编辑动作的情况下，交替使用; 和.与搜索和替换是等价的。 不需要输入“y”和“n”来对每个匹配的单词进行修改确认，你只需要找到需要的地方输入.即可。 关于vim的讨论非常热闹，以至于在 StackOverflow上，它已经成为一个经典的热门话题，在另一方面，文本编辑经常视为一贯重复性行为。Vim却将这些动作作为单一的单元，使得复现和将它们链接在一起非常容易。如果你是一个程序员，这很像编程里的活动 — 将整个任务拆分成多个方法并运行。如果你理解编程，你就更容易理解Vim。 可视模式和命令模式在你通往精通Vim的路上，你会接触到更多模式。可视模式下你可以先选择文本的区域然后再使用命令来操作它。偶尔用用挺好的，因为可视模式下选择区域很难转换成普通方法，所以不要像我学习的时候那样用的那么频繁。然而有很多针对可视模式有用的插件。 命令模式是Vim的主要模式。它本质上像ed这种原始的行编辑器。:17,25d在不移动鼠标情况下删除17到25行。:-3t.复制当行的前面三行。:v/foobar/s/thang/thing/g 将不含有“foobar”的文档里所有“thang”替换为 “foobar”。在这里你也可以使用所有存储的正则表达式。 另外，如全局搜索、替换、删除或者复制整行文字这样的简单的操作在命令行下非常容易。%s/one/two/gc把所有的“one”替换成 “two”，每个搜索和替换需要用户确认。(%代表整篇文章。这里你也可以使用行数范围。当然:e命令功能是打开一个文件编辑， :wq 的功能是保存当前文件并退出。你不需要记住太多的命令行模式的命令，但是有些命令超实用。 寄存器和宏接下来将介绍寄存器。像编程语言的变量那样，Vim 在寄存器中存储文本（或命令）。你可以从寄存器剪切或者粘贴数据，前十个主要是一个剪切缓冲区。寄存器是存储你剪切但不确定是否扔掉的文本的好地方。“zdi} 将删除所有方法括号内的所有代码，保存在“z”寄存器中。你可以在任何时候通过“zp将其粘贴回来。 你也可以像宏一样记录和回放寄存器中的Vim的命令序列。毕竟Vim命令大多数情况下都仅仅是文字。q用来开始和停止宏的录制，qw将一个宏录制到“w”寄存器中。 在此之后你可以用@w来重复运行。宏像其编写者那样强大。我只用一些宏，但是只要我用过的都会频繁使用。 例如，有一个宏我一天用无数次。我用Markdown写Hackaday文章然后将其编译成HTML语言发表。在Markdown中超链接的用法类似这样：link text。 S]f]a(“+pa)用“[]”将当前选中的文本括在里面。添加一个左圆括号，退出插入模式，粘贴粘贴板中的内容，添加一个右圆括号，返回到普通模式。但是现在，我复制浏览器中一个超链接，选择文本然后在Vim中键入@l 这样获得了链接到该网址的Markdown超链接。 插件想其他任何的编辑器一样，Vim也拥有难以置信的可拓展性。如果有任何不能制作成宏的特性，用户通常都可以为此编写插件。依我看来，Vimscript 没Lisp那样好编写，所以我就把拓展的编写留个其他用户吧。有人已经写了一个几乎你所需的所有模块。但是在刚开始的时候不要过度使用插件。即使你是刚学习Vim，它也会使你的工作量减轻很多。 如果你经不住诱惑安装了一些插件，我建议你一次只装一个，直到能给非常熟练的使用后再安装另外的插件。我建议依次安装和学习如下插件：vim-sensible, vim-airline, vim-abolish, ctrlp.vim, UltiSnips, vim-surround, vim-easy-align。 VIM最佳命令如果你在用Vim，但是没充分使用如下的命令，说明你还没用好它。 l I和 A 分别插入文本到行首或尾部。 l m设置标记然后通过“`就可以跳回到此标记位置。 这对轻松在长篇文章中跳转非常有效。 l g; 跳转到上次编辑位置。就是说“在去其他地方之前，先返回之前编辑的地方”。这非常有用。但这还不是全部–它追踪编辑历史以便可以复现前5此编辑。g,返回前一个编辑历史。 l CTRL-] 跳转到鼠标所在函数的定义位置，CTRL-t跳回。CTRL-t可以使你会一直返回，直到返回到开始位置。(为了使其生效你需要一个标签文件。) 这几乎达到像eclipse这种IDE价值的一半，却没他们那样造成屏幕凌乱。 l 一个IDE的另外一半是长变量或者方法名的tab完成功能。在Vim中用CTRL-n和 CTRL-p 来预选列表中上滚和下滚。如果你使用的是标签文件或者如果你在Vim中其他文件定义了标签，它将对变量名和方法名自动完成。 l gg=G跳转到文档顶部(gg) 自动缩进(=) 直到到达文档末尾 (G)。这使得你打开和关闭的大括号排成一行，很容易找到你忘记配对的大括号。 l U撤销最后一个命令。CTRL-r重做。:earlier 2m 恢复到两分钟前的状态。如果你不再进行撤销，继续编辑然后想重做之前的一些改动，就可以考虑用这个命令。g+ 和g- 则在恢复树种上下切换。它变得更加复杂。 l /和f 都是搜索命令，这两个命令在符合命令中起着至关重要的作用。d**f**,从当前光标位置上的字符一直删除到遇到逗号（包括逗号)。d/foo 一直删除直到第一次匹配“foo”的位置。如果你喜欢，你可以用这来代替其他动作。 l :r 读取一个文件。:!在shell中运行命令。:r! 粘贴命令的结果输出到文档中。:r!ls whatever*比输入文件名更快。在此我并不打算介绍UNIXy中怎样通过shell脚本运行文本。 无处不在的VI一旦你习惯于Vim的移动命令，你会乐在其中。当然了你也可以直接使用鼠标，但如果你能熟练使用Vim移动命令，你将很少用鼠标了。手一直在键盘上比时不时腾出手来操作鼠标操作要会更快很多。铁杆Vim用户会重新映射Escape 键（返回到普通模式）到其他更加方便的功能。我设置的是 Caps Lock键，在我左手小手指下面。 (我其实是通过xcapse插件映射它和Control键复合键使用。) 是的，这确实有点极端，但是比 现在已经不存在的避免Emacs导致腕管综合征的键盘设计 强多了。 如果你在Unix使用Bash shell，set -o vi 这种用法来读取行的方法几乎和vi一样。你的浏览器也可以Vim化，火狐浏览器、cVim或vimium中有Vimperator 和Pentadactyl 插件。谷歌浏览器中有ViChrome插件 。如果你想合二为一，qutebrowser是目前最好的原生Vim风格网页浏览器，而且还将会更加完善。 你若搜索 “vi keybindings”你会发现它不仅支持Visual Studio、Eclipse 还支持Emacs。 为什么Emacs里有Vi模拟模式，但Vim中却没Emacs的模拟模式呢？ 稍加思索你就会明白，编辑器之战已经有了结果。 想用惯Vim需要花费一些时日。程序员想要擅长Vim，需要要摆正心态勤加练习。从1994到20011年间我用Emacs写代码、写我的学位论文、我所代课的学生的论文和学术论文。从2011年起我就开始用Vim来编写更多代码、写书、写邮件和我在Hackaday上的文章。 我仍然在不断提高，五六年间每天使用Vim 6到8小时，每月将自己总结的技巧写在指令表中。虽然Vim像任何值其他值得深入探索的东西一样，用起来有点难，但是却非常值得。不要轻信任何人告诉你他们“懂”Vim。:wq. 资源There’s really too much to say about Vim. Here’s a short list of great resources: 关于Vim要说的实在是太多了，这里提供一些相关极有价值的参考资源： 如果你刚开始用输入 :help tutor Vim FAQ Vim Tips Wiki One of many good tutorials on the web Some cheat-sheets: (One, Two, Three, and Four) A video to push intermediate Vimmers over the edge Posted in Hackaday Columns, news, slider","tags":[{"name":"css","slug":"css","permalink":"http://onethree.cn/tags/css/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"如何将Vim打造成一个成熟的IDE","date":"2016-11-24T11:18:29.000Z","path":"2016/11/24/arctile_2/","text":"​ 如果你稍微写过一点代码，就能知道“集成开发环境”（IDE）是多么的便利。不管是Java、C还是Python，当IDE会帮你检查语法、后台编 译，或者自动导入你需要的库时，写代码就变得容易许多。另外，如果你工作在Linux上，你也会知道Vim在进行文本编辑的时候是多么的方便。所以，你可 能会想从Vim中也获取这些IDE特性。 事实上，很少有方法可以帮你做到。有些人可能会想到试着把Vim打造成C语言IDE的，比如c.vim；也有把Vim集成到Eclipse里的 Eclim 。但是我想要告诉你的是一个更加通用的，只用插件实现的方案。你肯定不想因为安装了太多的面板和特性而让你的编辑器变得臃肿不堪。只用插件实现的方案可以 让你只选择那些你想要集成到Vim的特性。这样做的额外的一个好处是，这个IDE不是专门针对某一种语言的，可以让你写任何类型的代码。下面就来看一下我 的 把IDE特性带进Vim的前10款插件 吧。 先来个福利： Pathogen首先，可能不是所有人都熟悉Vim的插件，并知道该怎么安装这些插件。所以，我推荐的第一个插件就是Pathogen，因为这个插件会让你更容易安装其他插件。如果你要安装另外的没有在这里列出来的插件，用Pathogen会变得非常简单。它的官方页面的文档写的非常好，去下载安装一个吧。接下来插件的安装也会变得容易很多。 1. SuperTab 我们习惯于IDE的第一个原因就是它的自动补全功能。所以，我喜欢这个非常方便的，给了Tab键“超能力”的 SuperTab 插件。 2. Syntastic 如果你需要使用一种以上的语言进行编程，有时候是非常容易混淆不同语言之间的语法的。幸运的是，syntastic 会帮你检查，然后告诉你是否应该加上圆括号或者方括号，或者告诉你在某个地方，你忘了一个分号。 3. Auto Pairs另外一件让程序员们抓狂的事是：我是不是少加了最后一个括号？！每个人都讨厌用手指去数那些隔的非常远的括号。为了处理这个问题，我用 Auto Pairs 插件，这个插件会自动插入和格式化方括号和圆括号。 4. NERD Commenter如果你在找一个可以支持多种程序语言的注释代码的快捷键，你可以试试 NERD Commenter。即使你不是程序员，我也非常非常推荐这款插件，因为它会让你在注释bash脚本或者其他任何东西的时候都会变得非常高效。 5. Snipmate任何一个程序员都知道，好的码农写代码，杰出的码神重用代码。snipmate可以容易的插入代码片段到你的文件里面，大大的减少了你敲键盘的次数。它默认的包含了很多各种语言的代码片段，你也可以非常容易的添加你自己的。 6. NERDTree 管理一个大的项目时，把代码分散到不同的文件里面是非常好的主意。也是一个基本的编码原则。NERDTree 是一个不错的可以直接在Vim里使用的文件浏览器，它可以让你随时想到所有的文件。 7. MiniBufferExplorer 为了打造一个文件浏览器，支持同时打开多个文件，没有什么比一个好的缓冲区管理器更重要了。MiniBufferExplorer 就可以非常漂亮和高效地完成这个工作。它甚至为你的缓冲区设置了不同的颜色和切换快捷键。 8. Tag List 当你同时有多个文件打开时，很容易忘了你都在这些文件里添加了什么。为了防止你忘记，Tag List 这个代码查看器将会用一种漂亮简洁的格式展示其中的的变量和函数。 9. undotree 对于我们之中那些喜欢undo，redo然后又undo某些更改，然后依据这些来查看整个编辑完成过程的人来说， undotree 是一个不错插件，可以以一棵树的形式看到你的undo和redo历史。这个功能跟代码完全没有关系，所以这是我非常喜欢的一个插件。 10. gdbmgr最后，但并非不重要，每个人都在某个时刻需要一个调试器。如果你喜欢gdb，那么gbdmgr就是为你准备的，因为它集成了那个著名的调试器到Vim中。 总结一下，不管你是不是一个疯狂的coder，能有一些额外的Vim功能在手总是非常方便的。像我在简介里说到的，如果你不需要，你不用安装这里所有的这些插件。或者你想要安装另外的也行，这些其实只是一个基础入门级的插件。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://onethree.cn/tags/IDE/"},{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"七个高效的文本编辑习惯（以Vim为例）","date":"2016-11-18T11:02:22.000Z","path":"2016/11/18/arctile_3/","text":"​ 如果你花很多时间输入纯文本、写程序或HTML，那么通过高效地使用一个好的编辑器，你可以节省大部分时间。本文将提供指导和提示，让你更迅速地做这些工作，并且少犯错误。 本文用开源文本编辑器Vim（Vi IMproved）来演示如何高效编辑，本文方法同样适用于其他的编辑器。选择合适的编辑器，实际上是进行高效编辑的第一步。我们避免去讨论哪个编辑器最适合你，因为这个话题将占用太多篇幅。如果你不知道选用那个编辑器，或者你对目前使用的编辑器不满意，那就试试Vim；你将不会失望。 第1部分：编辑一个文件1.**快速移动**大部分时间都花在阅读、检查错误和寻找正确的位置去工作，而不是插入新的文本或修改它。在文本内导航非常频繁，因此你应该学会如何迅速做到这一点。 很多时候，当你希望搜索一些已存在的文本，或在所有行里寻找某个用到的单词或短语时，你可以简单地使用搜索命令、模式去找到它。但是也有更智能的方法： 如果你看到一个特定的单词，并想搜索它出现的其他地方，就使用命令*。它会从光标下面定位找到这个单词，并且搜索下一个。 如果设置了“incsearch”选项，当你还在输入时，Vim将会显示第一个匹配模式的文本。这能迅速显示一个模式错误。 如果设置了“hlsearch”选项，Vim将用黄色背景高亮显示所有匹配的模式，让你对搜索命令的结果有个快速概览。它可以显示一个变量在程序代码哪个位置被使用。你甚至不需要移动光标去看匹配的文本。 在结构化的文本中还有更多可能性快速移动。Vim有针对C（以及类似语言，如C++和Java）程序的特定命令： 使用%从一个左括号跳转到与其配对的右括号，或从一个“#if”到配对的“#endif”。实际上%可以跳转到许多不同的匹配项目。它对检查if()和{}的结构完整性非常有用。 使用 [{ 跳回当前代码块起始的“{”。 使用 gd 从变量的调用跳转到它的局部声明。 当然还有更多的，重点是你需要知道这些命令。你也许认为不可能了解所有这些命令——有几百种不同的移动命令，有些简单，有些非常灵活——需要花费几个星期的训练去学会它们。然而，你不需要这样做。相反，你需要知道自己具体的编辑方式，并且只学习那些能让你的编辑更高效的命令。 三个基本步骤： 当你正在编辑时，留意那些重复的和（或者）花费相当多时间的动作。 寻找一个能更快完成这个动作的编辑器命令。你可以阅读文档，询问朋友，或者看看别人是怎么做的。 练习使用这个命令，直到无需思考你的手指就能输入。 让我们用例子来说明这是如何工作的： 你会发现，当编辑C程序文件时，你经常花时间寻找一个函数被定义的地方。目前你使用 * 命令去搜寻该函数名字出现的其他位置，但是最终会遍历许多函数被使用的匹配，而不是被定义的。你会想到必须得有一个更快的方法。 查阅快速参考，你会找到关于跳转到标签的注释。文档说明如何使用它去跳转到一个你在查找的函数定义。 你试验一下使用包含Vim的ctags程序去生成一个标签文件。学会使用 CTRL-] 命令后，你会发现节省了大量的时间。更容易的办法是在你的Makefile里添加几行，从而自动生成标签文件。 使用这三个步骤时需要注意的一些事： “我想把工作做好，我没有时间去翻阅文档寻找一些新命令。”如果你这样想，你将会停留在计算石器时代。有些人什么事都使用Notepad，然后惊讶于其他人使用一半的时间完成了工作。 过犹不及。如果你总是试图找到完美的命令去做每件小事情，你将没有时间去思考实际上要去做的工作。只要挑选出那些超出必要时间的动作，练习相关命令直到你在使用它们时不需要去想。然后你就可以集中精力在文本上了。 以下章节会建议一些大多数人需要去处理的动作。你可以从中受到启发，在你的工作中使用这三个基本步骤。 2.**不要输入两次** 我们输入的是一组有限的单词，甚至是有限的短语和句子，特别是在计算机程序中。显然，你不想把同样的东西输入两次。 很多时候，你想修改一个单词。如果是在整个文件中，你可以使用:s（substitute）命令。如果只是几个地方需要修改，一种快速的方法是使用 * 命令去找到下一个出现的单词，使用cw命令修改它。然后输入n去找到下一个单词，输入英文逗点 . 去重复cw命令。 . 命令重复上次的修改。修改在这里就是插入、删除或者替换文本。能够重复是一个非常强大的机制。如果你基于它来安排你的编辑，许多修改将变得只是敲.键。留意其间的其他修改，因为它会替代你原来要重复的修改。相反，你可以用m命令先标记这个位置，继续重复你的修改，稍后再返回到这个位置。 一些函数和变量名可以被笨拙的输入。你能快速输入“XpmCreatePixmapFromData”，不带一个错字，并且不用查询它么？Vim有一个完整的机制使它更容易。它在你正在编辑的文件里查询单词，这也包括#include文件。你可以输入“XpmCr”，然后按下CTRL-N，Vim会把它扩展为“XpmCreatePixmapFromData”。这不仅节省了输入时间，更能避免错字，并且避免稍后编译器报错时去修复它。 当你多次输入一个短语或句子时，这有一个更快捷的办法。Vim有一个录制宏的机制。你输入qa启动录制到寄存器“a”。然后像往常一样，你输入命令，最后再次按下q以终止录制。当你需要重复所录制的命令时，输入@a。一共有26个寄存器可用。 录制功能可以重复许多不同的动作，不只是插入文本。当你要重复一些东西时，记住这一点。 有一点需要注意，录制的命令将会完全按照你输入的回放。你必须知道移动的文本可能跟所重复的命令不同。左移四个字符也许适合你正在录制的文本，但是在你重复命令的地方可能需要五个字符。这往往需要使用命令移到文本对象（词，句子）或者移到一个特定的字符。 当你需要重复的命令越复杂，一次正确输入它们就越困难。不要去录制它们，相反，你应该写一个脚本或宏。这对制作你的部分代码的模板非常有用。例如，一个函数头。你可以把它做得如你所愿的灵活。 3. **错误要修正** 输入时候出错很正常，没有人能够避免。关键是要迅速发现并纠正它们。编辑器应该能帮助你，但你得告诉它什么是错误的、什么是正确的。 往往你会一遍又一遍地犯同样的错误。你的手指输入的并不是你打算要做的。这可以被缩写纠正。举几个例子： 123 :abbr Lunix Linux:abbr accross across:abbr hte the 在你输入这些单词后，它们会被自动纠正。 使用相同的机制，你可以只输入几个字符来得到一个长单词。这对于那些很难输入的单词很有用，避免了输入错误。示例： 12 :abbr pn penguin:abbr MS Mandrake Software 然而，当你不想扩展到完整的单词时，会觉得很困难在文本里插入“MS”。最好去使用没有字面意思的短的单词。 Vim有一个灵活的高亮显示机制在你的文本里发现错误。这实际上被用作程序的语法高亮显示，但他也可以捕获并高亮显示错误。 语法高亮用色彩显示注释。这听起来并不像一个重要的功能，然而一旦开始用它，你会发现它有很大帮助。你能够迅速发现本应该是注释却没有被高亮显示的文本（可能使你忘记了注释标记）。或者看到以行代码被高亮显示成注释（你忘记去插入一个“*/”）。这些错误很难在B&amp;W文件里发现，并有可能浪费大量时间去调试代码。 语法高亮还可以捕获不匹配的括号。不匹配的“)”会以鲜红的高亮背景显示。你可以使用%命令去查看它们如何匹配，并在合适的位置插入一个“(”或“)”。 其他常见的错误也能被迅速发现，例如使用“#included &lt;stdio.h&gt;”而不是“#include &lt;stdio.h&gt;”，这在B&amp;W文件里会被轻易错过的错误。但是你会很快发现“include”是高亮显示的，而“included”不会。 一个更复杂的例子：使用一个针对英语文本的、包含所有单词的长列表。不在此列内的任何单词可能是一个错字。你可以使用语法文件高亮显示所有没有包含在这个列表内的单词。你可以使用一些额外的宏来添加单词到词库，从而让它们不再被标记为错误。这就像你所期待的字处理器一样。它在Vim里用脚本实现，你可以进一步根据需要调整。例如，只去检查程序里注释的拼写错误。 第2部分：编辑多个文件4.**只有一个文件的情况很少**人们不只是工作在一个文件上，大多数情况会有许多相关文件，你一个接一个编辑它们，或者几个同时编辑。你应该能充分利用你的编辑器，使编辑几个文件更高效率。 之前提到的标签机制也适用于文件之间移动。通常的做法是为整个正在工作的项目生成一个标签文件。然后，你可以在项目里所有文件间寻找函数、机构、类型等的定义。相比较手动搜索，这节省的时间非常可观。创造一个标签文件是我浏览程序时要做的第一件事。 另一个强大的机制是在一组文件里使用:grep命令找到一个名字出现的所有位置。Vim建立一个所有匹配的列表，并跳转到第一个匹配。:cn命令带你依次到下一个匹配。如果你需要改变一个函数调用的参数数目，这会非常有用。 Include文件包含有用的信息，但是找到一个包含你需要看到的声明很花时间。Vim知道include文件并可以在它们中搜索你要找的单词。最常见的动作是查找一个函数的原型。把光标放在你的文件里的函数名上，输入[I:，Vim将显示一个包含所有在include文件里匹配该函数名的列表。如果需要看到更多上下文，你可以直接跳转到声明。一个类似的命令可用来检查你是否包含了正确的头文件。 Vim中，你可以把文本区分成几个区域编辑不同的文件。然后，你可以在两个或多个文件中比较内容，复制（粘贴）文本。有很多命令打开和关闭窗口，在它们之间跳转，临时隐藏文件等等。同样，你需要应用三个基本步骤来选择你打算学会使用的命令集。 多窗口有更多用途。预览标签机制是一个很好的例子，它会打开一个特殊的预览窗口，同时保持光标在你正在工作的文件中。在预览窗口中会显示文本，例如光标下的函数名所对应的函数声明。如果移动光标到另一个名字并停留一秒钟，预览窗口将会显示那个名字的定义。这也可以是一个在项目include文件里声明的结构或者函数的名字。 5.**让我们共同努力** 编辑器用于编辑文本，电子邮件程序发送和接收消息，操作系统运行程序。每个程序有它自己的任务，并擅长于它。这种力量源自程序协同工作。 一个简单的例子：你需要些一个不超过500字的总结。选择当前段落写入“wc”程序:vip:w!wc –w。外部命令“wc -w”用作计算单词数目。很简单，不是吗？ 总会有一些你需要的功能没有包含在编辑器里。你可以从外部添加功能，使编辑器能使用另一个程序过滤文本。一直以来，Unix的精髓就是用不同的程序做好它们自己的工作，并协作执行一个更大的任务。不幸的是，大部分编辑器不能很好地同其它程序一起工作——例如，你不能用另一个编辑器去替换Netscape里的电子邮件编辑器。你会终止使用残缺的编辑器。另一个趋势是在编辑器里包含所有功能，Emacs是一个很好的例子来终止（有人称之为一个可被用来编辑文本的操作系统。） Vim试图与其它程序集成，但这仍然是一个挑战。目前，它可被用作MS-Developer Studio和Sniff的编辑器。一些像Mutt的电子邮件程序支持外部编辑器，可以使用Vim。与Sun工作站的集成在进行中。总之，在不久的将来这是一个必须加强的领域。只有这样我们才能得到一个优于各部分简单相加的系统。 6.**文本结构** 你会经常遇到具有某种结构的文本，但是和现有命令所支持的不同。然后，你将不得不退回到编辑器的“积木”，创造你自己的宏和插件来处理这个文本。我们在这里接触更复杂的东西。 更简单的事情之一是加快编辑-编译-修复周期。Vim有:make命令，开始编译，捕捉它产生的错误，并让你跳转到错误位置来修复问题。如果你使用不同的编辑器，错误信息将无法识别。你应该调整“错误格式”选项，而不是重回到老的“把它写下”系统。这告诉Vim你的错误是什么样子，以及如何获取文件名和行号。它适用于复杂的gcc错误消息，因此你应该能使其与几乎任何编辑器工作。 有时调整到一种文件只是设置一些选项或写一些宏。例如，为了在手册页面跳转，你可以写一个宏去获取光标下的单词，清理缓冲区，然后从手册页面把那个单词读到缓冲区。这是一个简单高效的方式来查询交叉引用。 使用者2三个基本步骤，你可以更高效地处理任何结构形式的文件。试想下你想要对文件做的动作，找到可以做它的命令，并开始使用它们。正如你听到的，这真的很简单。你只需要去做它。 第3部分：磨刀不误砍柴工7.**形成习惯**学开车需要努力。那是你保持骑自行车的理由么？不，你认识到需要投入时间去学习一门技能。文本编辑不一样。你需要学习新命令，并把它们变成一种习惯。 另一方面，你不应该试图学习编辑器提供的所有命令。那将是彻底的浪费时间。大部分人只需为他们的工作学习10%到20%的命令。但对每个人来说这套命令是不同的。它需要你不时回过头来思考是否有一些重复性任务可以被自动化。如果你做的任务，只有一次，并不期望去再做一次，那就不要试图去优化它。但是你可能意识到你已经花了一个小时重复好几次做某事，那就在文档里搜索一个可以更快做它的命令。或者写一个宏来做到这一点。当它是一个更大的任务，例如选出一种特别的文本，你可以浏览下新闻组或互联网，看看是不是有人已经为你解决了这个问题。 必不可少的基本步骤是最后一条。你能想到一个重复性的任务，找到一个好的解决方案，过了周末忘记你是怎么做的。这不起作用。你必须重复它知道你的手指可以自动去这样做。只有这样你才能达到你需要的效率。一次不要学太多，同时做一些就好。把你不经常使用的技巧记录在表格里，以备日后查用。无论如何，如果你坚持目标，你会发现让你编辑越来越高效地办法。 最后一句提醒，当人们忽略上述所提会发生什么：我仍然看到人们在电脑屏幕（VDU）后花了半天时间，抬头看着屏幕，然后低头看两个手指输入，再抬头看着屏幕，等等。——然后他们奇怪为什么如此累……用十指输入！这不只是速度更快，也能减少无聊。每天使用一个小时计算机程序，只需要几个星期就能学会按指法输入。 结语 标题的想法来自斯蒂芬-科维所著的成功书籍《高效能人士的七个习惯》。我向需要解决个人和职业问题人们（谁没有？）推荐这本书。虽然有些人会宣称它来自斯科特-亚当斯所著的《迪尔伯特——高度有缺陷人士的7年》（同样推荐）。 布莱姆·米勒写于 2000年11月 关于作者 布莱姆·米勒 (Bram Moolenaar) 是Vim的主要作者。他写了Vim功能核心，并且选择包含其他人提交的代码。他以电脑技师的身份毕业于代尔夫特技术大学。现在，它主要从事软件工作，但仍然懂得如何使用烙铁。他是ICCF（荷兰）的创始人和财务主管，帮助乌干达的孤儿。他是一名从事系统架构师工作的自由职业者，但是实际上花费大部分时间在开发Vim上。他的电子邮件地址：Bram@moolenaar.net。","tags":[{"name":"linux","slug":"linux","permalink":"http://onethree.cn/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://onethree.cn/tags/vim/"}]},{"title":"Sublime Text使用体验","date":"2016-10-28T04:08:32.000Z","path":"2016/10/28/arctile_1/","text":"​ 让我使用一种新编辑器是比较难的，但鉴于听到Sublime Text获得如此多的赞扬，我最终决定试一下。毕竟，比起我的又老又生硬的Vim，Sublime Text界面好看的多，布局更顺手——我是对界面很挑剔的。于是，在tuts+上看了几篇资料后，我就开始在工作中试用起来。下面就是我的一些体验。 先说Sublime Text的优点： Sublime Text跨平台。如果一种编辑器只能运行在一种平台上，我是绝对不会考虑它的，跨平台是必要条件。 Sublime Text不仅跨平台，而且在所有平台上看起来都很漂亮。很流畅，响应灵敏，很吸引眼球。 Sublime Text的一个独特的功能是支持多光标操作：它能让你对文本中的多个地方同时做修改，你可以看到多个地方在你输入的时候同时发生变化。重构时用它很方便，比如修改一个变量名。 Sublime Text的command palette能够让你轻松的做任何操作，勉去了记忆众多快捷键的痛苦。你只需要打开command palette ，输入几个字母，Sublime Text会用模糊查询给你提供建议和选项。跟直接使用快捷键几乎没区别。 所有的操作和选项都很直观的放在菜单里。虽然我并不是很多的使用菜单(感谢command palette)，但你可以在里面查找你想要的操作，学会这个编辑器里有哪些功能。 打开文件很快，而且可以通过Go to anything弹出面板转到文件中任何地方。我使用Vim时一直使用ctrlp来做这种事情，但Sublime Text支持转到某个位置和某行，非常方便。 编辑文件的同时你可以启动编译，看到输出结果，这种交互能让你快速发现编译错误。这点集成的非常好，非常顺滑，比Vim要好。 在Sublime Text里你可以使用Vim命令进行光标移到和编辑文本，很显然，如果你习惯Vim，你可以在Sublime Text了进行闪电般的快速编辑。 当然，Sublime Text里还提供了很多非常有用的文本操作命令，你可以设定快捷键绑定这些操作。 Sublime Text扩展性很好，它使用了Python式的插件系统。这显然是一个很大和活跃的社区，可以为它提供丰富的插件，这也意味着你可以在网上找的任何你想要的插件来集成你想要的功能。 不幸的是，Sublime Text也有不少缺点： 尽管Sublime Text是跨平台的，但它看起来并不是为同时在多个平台上的用户设计的。比如，快捷键在各个平台上都不同，这比由Cmd变成Ctrl要严重的多。这可能是由于Sublime Text的设计倾向于平台本地化。在不同的平台上记忆不同的快捷键无疑是讨厌的，经常切换平台时常会弄错。 Sublime Text的配置文件是存在固定格式、平台特定的文件里的。可能同样是因为Sublime Text希望最大化的和操作系统本地集成的原因。然而，这就使得你将配置文件存放在Git版本库里变得很麻烦，在不同的机器，不同的操作系统上不能共享。 Sublime Text使用JSON格式存放配置参数，这适合是无可非议，但确有个很大的缺点：设置的每一行结尾都需要一个逗号，除非最后一行。很多在我修改配置时都忘了这一点。使用JSON的另外一个缺点是，这种格式不是很强大：因为它基本上都是key/value值，你无法添加条件依赖(比如，在不同的机器上不同的配置)，或引用其它文件。 Sublime Text没有命令行界面。我经常需要编辑远程系统上的文件，通常只有一个命令行终端。这种情况下，我只能用其它编辑器。 Sublime Text很明显的另外一个缺点：它不开源，而且收费版的价格也不便宜。我并不是反对任何闭源软件，而且如果一个编辑器我需要天天使用它，我很愿意花钱买它。然而，有一些现实问题：我工作的那台机器无法运行Sublime Text，因为Sublime Text引用了一些旧的程序库，我机器上没有。我无法自己重新编译它，它就毫无用处了。而且，有一点我需要说的是，我不喜欢这种一个编辑器的生命依赖于某个人的专注和贡献，万一他被车撞了呢。如果他的开发终止了，也许会人能克隆一个来支持现有用户们，这是个未知数。 我只是试用了一下Sublime Text 2，虽然3也出来了，但是没去使用了。因为我说的这些问题都是根本性的，我不认为在未来的版本上在这方面会有所改进。我对这些事情不是很习惯，一次又一次的在使用时犯错，我最终决定重回Vim。然而，我认为Sublime Text是个很不错的编辑器，我认为它是至今为止发现的最有可能替代Vim的编辑器。","tags":[{"name":"sublime","slug":"sublime","permalink":"http://onethree.cn/tags/sublime/"},{"name":"IDE","slug":"IDE","permalink":"http://onethree.cn/tags/IDE/"}]}]